/**
 * @file     rcm.h (180.ARM_Peripherals/Project_Headers/rcm.h)
 *
 * @brief    Reset Control Module interface
 */

#ifndef HEADER_RCM_H
#define HEADER_RCM_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"
#include "stringFormatter.h"

// $/RCM/prototypes not found

namespace USBDM {
/**
 * @addtogroup RCM_Group RCM, Reset Control Module
 * @brief Abstraction for Reset Control Module
 * @{
 */
/**
 * Peripheral information for RCM, Reset Control Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Reset pin filter select in low power modes
    * (rcm_rpfc_rstfltss)
    *
    * Controls the reset reset pin filter in STOP and VLPS modes
    * On exit from VLLS mode, this bit should be reconfigured before clearing PMC_REGSC[ACKISO]
    */
   enum RcmResetPinStopFilter {
      RcmResetPinStopFilter_Disabled             = RCM_RPFC_RSTFLTSS(0),  ///< No filter
      RcmResetPinStopFilter_LowPowerOscillator   = RCM_RPFC_RSTFLTSS(1),  ///< LPO clock based filter
   };

   /**
    * Reset pin filter select in run and wait modes
    * (rcm_rpfc_rstfltsrw)
    *
    * Controls the reset reset pin filter in RUN and WAIT modes
    */
   enum RcmResetPinRunWaitFilter {
      RcmResetPinRunWaitFilter_Disabled             = RCM_RPFC_RSTFLTSRW(0),  ///< No filter
      RcmResetPinRunWaitFilter_BusClock             = RCM_RPFC_RSTFLTSRW(1),  ///< Bus clock based filter
      RcmResetPinRunWaitFilter_LowPowerOscillator   = RCM_RPFC_RSTFLTSRW(2),  ///< LPO clock based filter
   };

   /**
    * Reset pin filter bus clock select
    * (rcm_rpfw_rstfltsel)
    *
    * Selects the reset pin filter width
    */
   enum RcmResetFilter {
      RcmResetFilter_1Cycles    = RCM_RPFW_RSTFLTSEL(0),   ///< 1 Cycles
      RcmResetFilter_2Cycles    = RCM_RPFW_RSTFLTSEL(1),   ///< 2 Cycles
      RcmResetFilter_3Cycles    = RCM_RPFW_RSTFLTSEL(2),   ///< 3 Cycles
      RcmResetFilter_4Cycles    = RCM_RPFW_RSTFLTSEL(3),   ///< 4 Cycles
      RcmResetFilter_5Cycles    = RCM_RPFW_RSTFLTSEL(4),   ///< 5 Cycles
      RcmResetFilter_6Cycles    = RCM_RPFW_RSTFLTSEL(5),   ///< 6 Cycles
      RcmResetFilter_7Cycles    = RCM_RPFW_RSTFLTSEL(6),   ///< 7 Cycles
      RcmResetFilter_8Cycles    = RCM_RPFW_RSTFLTSEL(7),   ///< 8 Cycles
      RcmResetFilter_9Cycles    = RCM_RPFW_RSTFLTSEL(8),   ///< 9 Cycles
      RcmResetFilter_10Cycles   = RCM_RPFW_RSTFLTSEL(9),   ///< 10 Cycles
      RcmResetFilter_11Cycles   = RCM_RPFW_RSTFLTSEL(10),  ///< 11 Cycles
      RcmResetFilter_12Cycles   = RCM_RPFW_RSTFLTSEL(11),  ///< 12 Cycles
      RcmResetFilter_13Cycles   = RCM_RPFW_RSTFLTSEL(12),  ///< 13 Cycles
      RcmResetFilter_14Cycles   = RCM_RPFW_RSTFLTSEL(13),  ///< 14 Cycles
      RcmResetFilter_15Cycles   = RCM_RPFW_RSTFLTSEL(14),  ///< 15 Cycles
      RcmResetFilter_16Cycles   = RCM_RPFW_RSTFLTSEL(15),  ///< 16 Cycles
      RcmResetFilter_17Cycles   = RCM_RPFW_RSTFLTSEL(16),  ///< 17 Cycles
      RcmResetFilter_18Cycles   = RCM_RPFW_RSTFLTSEL(17),  ///< 18 Cycles
      RcmResetFilter_19Cycles   = RCM_RPFW_RSTFLTSEL(18),  ///< 19 Cycles
      RcmResetFilter_20Cycles   = RCM_RPFW_RSTFLTSEL(19),  ///< 20 Cycles
      RcmResetFilter_21Cycles   = RCM_RPFW_RSTFLTSEL(20),  ///< 21 Cycles
      RcmResetFilter_22Cycles   = RCM_RPFW_RSTFLTSEL(21),  ///< 22 Cycles
      RcmResetFilter_23Cycles   = RCM_RPFW_RSTFLTSEL(22),  ///< 23 Cycles
      RcmResetFilter_24Cycles   = RCM_RPFW_RSTFLTSEL(23),  ///< 24 Cycles
      RcmResetFilter_25Cycles   = RCM_RPFW_RSTFLTSEL(24),  ///< 25 Cycles
      RcmResetFilter_26Cycles   = RCM_RPFW_RSTFLTSEL(25),  ///< 26 Cycles
      RcmResetFilter_27Cycles   = RCM_RPFW_RSTFLTSEL(26),  ///< 27 Cycles
      RcmResetFilter_28Cycles   = RCM_RPFW_RSTFLTSEL(27),  ///< 28 Cycles
      RcmResetFilter_29Cycles   = RCM_RPFW_RSTFLTSEL(28),  ///< 29 Cycles
      RcmResetFilter_30Cycles   = RCM_RPFW_RSTFLTSEL(29),  ///< 30 Cycles
      RcmResetFilter_31Cycles   = RCM_RPFW_RSTFLTSEL(30),  ///< 31 Cycles
      RcmResetFilter_32Cycles   = RCM_RPFW_RSTFLTSEL(31),  ///< 32 Cycles
   };

   /**
    * EZP_MS_B pin state
    * (rcm_mr_ezp_ms)
    *
    * Reflects the state of the EZP_MS pin during the last Chip Reset
    */
   enum RcmModePinEZP {
      RcmModePinEZP_Negated    = RCM_MR_EZP_MS(0),  ///< Negated (logic 1)
      RcmModePinEZP_Asserted   = RCM_MR_EZP_MS(1),  ///< Asserted (logic 0)
   };

class RcmBasicInfo {

public:
}; // class RcmBasicInfo 

class RcmInfo : public RcmBasicInfo {

public:
   /*
    * Template:rcm_mk10d5
    */
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = RCM_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<RCM_Type> rcm = baseAddress;
   
}; // class RcmInfo



#if false // /RCM/_BasicInfoGuard
/**
 * Indicates reason for reset
 */
enum RcmSource {
   RcmSource_Wakeup  = (1<<0),   ///<  Low Leakage Wake-up Reset
   RcmSource_lvd     = (1<<1),   ///<  Low-Voltage Detect Reset
   RcmSource_Loc     = (1<<2),   ///<  Loss-of-Clock Reset
   RcmSource_Lol     = (1<<3),   ///<  Loss-of-Lock Reset
   RcmSource_4       = (1<<4),   ///<  Reserved
   RcmSource_Wdog    = (1<<5),   ///<  Watchdog
   RcmSource_Pin     = (1<<6),   ///<  External Reset Pin
   RcmSource_Por     = (1<<7),   ///<  Power-On Reset
   RcmSource_Jtag    = (1<<8),   ///<  JTAG Generated Reset
   RcmSource_Lockup  = (1<<9),   ///<  Core Lockup
   RcmSource_Sw      = (1<<10),  ///<  Software
   RcmSource_Mdm_Ap  = (1<<11),  ///<  MDM-AP System Reset Request
   RcmSource_Ezpt    = (1<<12),  ///<  EzPort Reset
   RcmSource_Sackerr = (1<<13),  ///<  Stop Mode Acknowledge Error Reset
   RcmSource_14      = (1<<14),  ///<  Reserved
   RcmSource_15      = (1<<15),  ///<  Reserved
};

#ifdef RCM_FM_FORCEROM_MASK
/**
 * Force ROM boot options
 */
enum RcmRomBoot {
   RcmRomBoot_None              = RCM_FM_FORCEROM(0b00), ///< Default boot action (as for POR)
   RcmRomBoot_ForceRom_Pin      = RCM_FM_FORCEROM(0b01), ///< Force boot from ROM with getBootSource() = RcmBootSource_Rom_Pin on next reset
   RcmRomBoot_ForceRom_Fopt     = RCM_FM_FORCEROM(0b10), ///< Force boot from ROM with getBootSource() = RcmBootSource_Rom_Fopt on next reset
   RcmRomBoot_ForceRom_Fopt_Pin = RCM_FM_FORCEROM(0b11), ///< Force boot from ROM with getBootSource() = RcmBootSource_Rom_Fopt_Pin on next reset
};
#endif // RCM_FM_FORCEROM_MASK

#ifdef RCM_MR_BOOTROM_MASK
/**
 * Force ROM boot options
 */
enum RcmBootSource {
   RcmBootSource_Flash        = RCM_MR_BOOTROM(0b00), ///< Booted from Flash
   RcmBootSource_Rom_Pin      = RCM_MR_BOOTROM(0b01), ///< Booted from ROM due to BOOTCFG0 pin assertion
   RcmBootSource_Rom_Fopt     = RCM_MR_BOOTROM(0b10), ///< Booted form ROM due to FOPT[7] configuration
   RcmBootSource_Rom_Fopt_Pin = RCM_MR_BOOTROM(0b11), ///< Booted from ROM due to both BOOTCFG0 pin assertion and FOPT[7] configuration
};
#endif // RCM_MR_BOOTROM_MASK


/**
 * Template class providing interface to Reset Control Module.
 *
 * @tparam info      Information class for RCM
 *
 * @code
 * using rcm = RcmBase<RcmInfo>;
 *
 *  rcm::configure();
 *
 * @endcode
 */
class RcmBase : public RcmInfo {

public:
   /** Hardware instance pointer */
   static constexpr HardwarePtr<RCM_Type> rcm = baseAddress;

public:
// /RCM/publicMethods not found

   /**
    * Returns a bit mask indicating the source of the last reset.
    * See RcmSource for bit masks to use.
    *
    * @return Bit mask representing sources
    */
   static uint32_t getResetSource() {
      return (rcm->SRS1<<8)|rcm->SRS0;
   }

#ifdef RCM_SSRS0_SWAKEUP_MASK
   /**
    * Returns a bit mask indicating the cumulative reset sources since last cleared.
    *
    * @return Bit mask representing sources
    */
   static uint32_t getStickyResetSource() {
      return (rcm->SSRS1<<8)|rcm->SSRS0;
   }

   /**
    * Returns a bit mask indicating the cumulative reset sources since last cleared.
    * The cumulative value is cleared.
    *
    * @return Bit mask representing sources
    */
   static uint32_t getAndClearStickyResetSource() {
      uint32_t snapShot = (rcm->SSRS1<<8)|rcm->SSRS0;
      rcm->SSRS0 = 0xFF;
      rcm->SSRS1 = 0xFF;
      return snapShot;
   }
#endif

   /**
    * Returns a string indicating the source of the reset indicated by source.
    *
    * @param source Pointer to string in SHARED static buffer representing reset sources
    */
   static const char *getResetSourceDescription(uint32_t source) {
      static const char *names[] = {
            "Wakeup",
            "Lvd",
            "Loc",
            "Lol",
            "4",
            "Wdog",
            "Pin",
            "Por",
            "Jtag",
            "Lockup",
            "Sw",
            "Mdm_Ap",
            "Ezpt",
            "Sackerr",
            "14",
            "15",
      };
      static char buff[20];
      USBDM::StringFormatter stringFormatter(buff);
      bool commaFlag = false;
      for (unsigned index=0; index<(sizeof(names)/sizeof(names[0])); index++) {
         if (source&(1<<index)) {
            if (commaFlag) {
               stringFormatter.write(",");
            }
            stringFormatter.write(names[index]);
            commaFlag = true;
         }
      }
      return buff;
   }
   /**
    * Returns a string indicating the source of the last reset.
    */
   static const char *getResetSourceDescription() {
      return getResetSourceDescription(getResetSource());
   }

#ifdef RCM_FM_FORCEROM_MASK
   /**
    * ROM Boot loader entry
    */
   static __attribute__((always_inline)) void romBootloader() {
      reinterpret_cast<void (*)()>(0x1c00001c)();
   }

   /**
    * Set Force boot from ROM options
    * This setting is preserved through non-POR resets and affects the boot behaviour of the chip.
    */
   static void setRomBootOption(RcmRomBoot rcmRomBoot) {
      rcm->MR = rcmRomBoot;
   }
#endif // RCM_FM_FORCEROM_MASK

#ifdef RCM_MR_BOOTROM_MASK
   /**
    * Indicates the boot source.
    * The boot source remains set until the next System Reset or software can clear these bits.
    * While non-zero, the NMI input is disabled and the vector table is relocated to the ROM base address
    * at 0x1C00_0000.
    */
   static RcmBootSource getBootSource() {
      return RcmBootSource(rcm->MR&RCM_MR_BOOTROM_MASK);
   }

   /**
    * Clear the boot source flags.
    * This disables the vector table relocation and restores NMI operation (if enabled)
    */
   static void clearBootSource() {
      rcm->MR = RCM_MR_BOOTROM_MASK;
   }
#endif // RCM_MR_BOOTROM_MASK

};

// No static declarations found

#endif  // /RCM/_BasicInfoGuard

/**
 * End RMC_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_RCM_H */
