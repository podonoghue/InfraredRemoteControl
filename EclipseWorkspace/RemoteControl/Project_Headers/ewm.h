/**
 * @file     ewm.h (180.ARM_Peripherals/Project_Headers/ewm.h)
 * @brief    External Watchdog Monitor
 */

#ifndef HEADER_EWM_H_
#define HEADER_EWM_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"

// No handler defined for EWM


namespace USBDM {

/**
 * @addtogroup EWM_Group EWM, External Watchdog Monitor
 * @brief Abstraction for External Watchdog Monitor
 * @{
 */
/**
 * Peripheral information for EWM, External Watchdog Monitor.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * EWM enable
    * (ewm_ctrl_ewmen)
    *
    * Enables the EWM module
    * This is a write-once value
    */
   enum EwmMode : uint8_t {
      EwmMode_Disabled   = EWM_CTRL_EWMEN(0),  ///< Disabled
      EwmMode_Enabled    = EWM_CTRL_EWMEN(1),  ///< Enabled
   };

   /**
    * Action on event
    * (ewm_ctrl_inten)
    *
    * Action taken on EWM event
    */
   enum EwmAction : uint8_t {
      EwmAction_None        = EWM_CTRL_INTEN(0),  ///< None
      EwmAction_Interrupt   = EWM_CTRL_INTEN(1),  ///< Interrupt
   };

   /**
    * Input pin control
    * (ewm_ctrl_input)
    *
    * Enables and selects the polarity of the EWM_in pin
    * This is a write-once value
    */
   enum EwmInputPin : uint8_t {
      EwmInputPin_Disabled     = EWM_CTRL_INEN(0)|EWM_CTRL_ASSIN(0),  ///< Input disabled
      EwmInputPin_ActiveLow    = EWM_CTRL_INEN(1)|EWM_CTRL_ASSIN(0),  ///< Input active-low
      EwmInputPin_ActiveHigh   = EWM_CTRL_INEN(1)|EWM_CTRL_ASSIN(1),  ///< Input active-high
   };

   /**
    * Values to write to service the EWM
    * (ewm_serv_service)
    *
    * The EWM service mechanism requires the CPU to write two values to the SERV register:
    * - a first data byte of 0xB4, 
    * - followed by a second data byte of 0x2C.
    */
   enum EwmService : uint8_t {
      EwmService_First    = EWM_SERV_SERVICE(0xB4),  ///< First value in sequence
      EwmService_Second   = EWM_SERV_SERVICE(0x2C),  ///< Second value in sequence
   };

class EwmBasicInfo {

public:
}; // class EwmBasicInfo 

class EwmInfo : public EwmBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: EWM_IN               = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: EWM_OUT_b            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:ewm_int
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with EWM
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with EWM
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = EWM_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Ewm
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_EWM_MASK;
   }
   
   /**
    *  Disable clock to Ewm
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_EWM_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = EWM_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<EWM_Type> ewm = baseAddress;
   
}; // class EwmInfo




/**
 * End EWM_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_EWM_H_ */
