/**
 * @file     cmp.h (180.ARM_Peripherals/Project_Headers/cmp.h)
 * @brief    Analogue Comparator
 */

#ifndef PROJECT_HEADERS_CMP_H_
#define PROJECT_HEADERS_CMP_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

#if false // /CMP/_BasicInfoGuard

namespace USBDM {
// Forward declaration
struct CmpStatus;
}

// No handler defined for CMP0
// No handler defined for CMP1


namespace USBDM {

/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */

/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Action on transition
    * (cmp_scr_interrupt)
    *
    * Enables interrupt request on comparator transition
    */
   enum CmpEvent : uint8_t {
      CmpEvent_Disabled    = CMP_SCR_IER(0)|CMP_SCR_IEF(0),  ///< Disabled
      CmpEvent_OnRising    = CMP_SCR_IER(1)|CMP_SCR_IEF(1),  ///< Rising edge
      CmpEvent_OnFalling   = CMP_SCR_IER(1)|CMP_SCR_IEF(0),  ///< Falling edge
      CmpEvent_OnEither    = CMP_SCR_IER(1)|CMP_SCR_IEF(0),  ///< Either edge
   };

   /**
    * DMA Enable Control
    * (cmp_scr_dmaen)
    *
    * Enables the DMA transfer triggered from the CMP module (If DMA supported by device)
    * When this field is set, a DMA request is asserted when CFR or CFF is set
    */
   enum CmpDma : uint8_t {
      CmpDma_Disabled   = CMP_SCR_DMAEN(0),  ///< Disabled
      CmpDma_Enabled    = CMP_SCR_DMAEN(1),  ///< Enabled
   };

   /**
    * Comparator hard block hysteresis control
    * (cmp_cr0_hystctr)
    *
    * Defines the programmable hysteresis level.
    * The hysteresis values associated with each level are device specific
    */
   enum CmpHysteresis : uint8_t {
      CmpHysteresis_Level_0   = CMP_CR0_HYSTCTR(0),  ///< Level 0
      CmpHysteresis_Level_1   = CMP_CR0_HYSTCTR(1),  ///< Level 1
      CmpHysteresis_Level_2   = CMP_CR0_HYSTCTR(2),  ///< Level 2
      CmpHysteresis_Level_3   = CMP_CR0_HYSTCTR(3),  ///< Level 3
   };

   /**
    * Power Mode Select
    * (cmp_cr1_pmode)
    *
    * Selects trade-off between speed and power consumption
    */
   enum CmpPower : uint8_t {
      CmpPower_LowSpeed    = CMP_CR1_PMODE(0),  ///< Low-Speed
      CmpPower_HighSpeed   = CMP_CR1_PMODE(1),  ///< High-Speed
   };

   /**
    * Comparator Invert
    * (cmp_cr1_inv)
    *
    * Allows selection of the polarity of the analog comparator function
    */
   enum CmpPolarity : uint8_t {
      CmpPolarity_Normal     = CMP_CR1_INV(0),  ///< Not inverted
      CmpPolarity_Inverted   = CMP_CR1_INV(1),  ///< Inverted
   };

   /**
    * Comparator output pin source
    * (cmp_cr1_output)
    *
    * Selects whether the output pin is driven by the filtered or unfiltered comparator output
    */
   enum CmpOutput : uint8_t {
      CmpOutput_Disabled   = CMP_CR1_OPE(0)|CMP_CR1_COS(0),  ///< Disabled
      CmpOutput_Direct     = CMP_CR1_OPE(1)|CMP_CR1_COS(1),  ///< Direct (unfiltered)
      CmpOutput_Filtered   = CMP_CR1_OPE(1)|CMP_CR1_COS(0),  ///< Filtered
   };

   /**
    * CMP Positive Input Select
    * (cmp_muxcr_psel_base)
    *
    * Selects the positive input source
    */
   enum CmpInputPlus : uint8_t {
      CmpInputPlus_0   = CMP_MUXCR_PSEL(0),  ///< External input 0
      CmpInputPlus_1   = CMP_MUXCR_PSEL(1),  ///< External input 1
      CmpInputPlus_2   = CMP_MUXCR_PSEL(2),  ///< External input 2
      CmpInputPlus_3   = CMP_MUXCR_PSEL(3),  ///< External input 3
      CmpInputPlus_4   = CMP_MUXCR_PSEL(4),  ///< External input 4
      CmpInputPlus_5   = CMP_MUXCR_PSEL(5),  ///< External input 5
      CmpInputPlus_6   = CMP_MUXCR_PSEL(6),  ///< External input 6
      CmpInputPlus_7   = CMP_MUXCR_PSEL(7),  ///< External input 7
   };

   /**
    * CMP0 Positive Input Select
    * (cmp_muxcr_psel)
    *
    * Selects the Cmp0 positive input source
    */
   static constexpr CmpInputPlus Cmp0InputPlus_0          = CmpInputPlus_0;  ///< CMP0_IN0 [-]
   static constexpr CmpInputPlus Cmp0InputPlus_1          = CmpInputPlus_1;  ///< CMP0_IN1 [-]
   static constexpr CmpInputPlus Cmp0InputPlus_2          = CmpInputPlus_2;  ///< CMP0_IN2 [-]
   static constexpr CmpInputPlus Cmp0InputPlus_3          = CmpInputPlus_3;  ///< CMP0_IN3 [-]
   static constexpr CmpInputPlus Cmp0InputPlus_5          = CmpInputPlus_5;  ///< CMP0_IN5 [VREF_OUT(p13)]
   static constexpr CmpInputPlus Cmp0InputPlus_Vref_out   = CmpInputPlus_5;  ///< Pin VREF_OUT
   static constexpr CmpInputPlus Cmp0InputPlus_6          = CmpInputPlus_6;  ///< CMP0_IN6 [BANDGAP(Internal)]
   static constexpr CmpInputPlus Cmp0InputPlus_Bandgap    = CmpInputPlus_6;  ///< Pin BANDGAP
   static constexpr CmpInputPlus Cmp0InputPlus_7          = CmpInputPlus_7;  ///< CMP0_IN7 [CMP_DAC(Internal)]
   static constexpr CmpInputPlus Cmp0InputPlus_Cmp_dac    = CmpInputPlus_7;  ///< Pin CMP_DAC


   /**
    * CMP Negative Input Select
    * (cmp_muxcr_msel_base)
    *
    * Selects the negative input source
    */
   enum CmpInputMinus : uint8_t {
      CmpInputMinus_0   = CMP_MUXCR_MSEL(0),  ///< External input 0
      CmpInputMinus_1   = CMP_MUXCR_MSEL(1),  ///< External input 1
      CmpInputMinus_2   = CMP_MUXCR_MSEL(2),  ///< External input 2
      CmpInputMinus_3   = CMP_MUXCR_MSEL(3),  ///< External input 3
      CmpInputMinus_4   = CMP_MUXCR_MSEL(4),  ///< External input 4
      CmpInputMinus_5   = CMP_MUXCR_MSEL(5),  ///< External input 5
      CmpInputMinus_6   = CMP_MUXCR_MSEL(6),  ///< External input 6
      CmpInputMinus_7   = CMP_MUXCR_MSEL(7),  ///< External input 7
   };

   /**
    * CMP0 Negative Input Select
    * (cmp_muxcr_msel)
    *
    * Selects the Cmp0 negative input source
    */
   static constexpr CmpInputMinus Cmp0InputMinus_0          = CmpInputMinus_0;  ///< CMP0_IN0 [-]
   static constexpr CmpInputMinus Cmp0InputMinus_1          = CmpInputMinus_1;  ///< CMP0_IN1 [-]
   static constexpr CmpInputMinus Cmp0InputMinus_2          = CmpInputMinus_2;  ///< CMP0_IN2 [-]
   static constexpr CmpInputMinus Cmp0InputMinus_3          = CmpInputMinus_3;  ///< CMP0_IN3 [-]
   static constexpr CmpInputMinus Cmp0InputMinus_5          = CmpInputMinus_5;  ///< CMP0_IN5 [VREF_OUT(p13)]
   static constexpr CmpInputMinus Cmp0InputMinus_Vref_out   = CmpInputMinus_5;  ///< Pin VREF_OUT
   static constexpr CmpInputMinus Cmp0InputMinus_6          = CmpInputMinus_6;  ///< CMP0_IN6 [BANDGAP(Internal)]
   static constexpr CmpInputMinus Cmp0InputMinus_Bandgap    = CmpInputMinus_6;  ///< Pin BANDGAP
   static constexpr CmpInputMinus Cmp0InputMinus_7          = CmpInputMinus_7;  ///< CMP0_IN7 [CMP_DAC(Internal)]
   static constexpr CmpInputMinus Cmp0InputMinus_Cmp_dac    = CmpInputMinus_7;  ///< Pin CMP_DAC


   /**
    * DAC Enable
    * (cmp_daccr_dacen)
    *
    * Enables the internal DAC
    */
   enum CmpDacEnable : uint8_t {
      CmpDacEnable_Disabled   = CMP_DACCR_DACEN(0),  ///< Disabled
      CmpDacEnable_Enabled    = CMP_DACCR_DACEN(1),  ///< Enabled
   };

   /**
    * DAC Reference Voltage Select
    * (cmp_daccr_vrsel)
    *
    * Supply Voltage Reference Source Select
    */
   enum CmpDacrefSel : uint8_t {
      CmpDacrefSel_VrefOut   = CMP_DACCR_VRSEL(0),  ///< Vin1 (Vref_OUT)
      CmpDacrefSel_Vdd       = CMP_DACCR_VRSEL(1),  ///< Vin2 (Vdd)
   };

   /**
    * DAC level
    * (cmp_daccr_vosel)
    *
    * Specifies the output level of the internal DAC
    */
   enum CmpDacLevel : int8_t {
   };

   /**
    * Comparator Filtering Mode
    * (cmp_mode)
    *
    * Comparitor mode of operation
    */
   enum CmpFilterMode : uint8_t {
      CmpFilterMode_Disabled               = 0,  ///< 1    Disabled
      CmpFilterMode_Continuous             = 1,  ///< 2a/b Continuous
      CmpFilterMode_External_NonFiltered   = 2,  ///< 3a   Externally sampled, Non-Filtered
      CmpFilterMode_Internal_NonFiltered   = 3,  ///< 3b   Internally sampled, Non-Filtered
      CmpFilterMode_External_Filtered      = 4,  ///< 4a   Externally sampled, Filtered
      CmpFilterMode_Internal_Filtered      = 5,  ///< 4b   Internally sampled, Filtered
      CmpFilterMode_Windowed               = 6,  ///< 5a/b Windowed
      CmpFilterMode_Windowed_Resampled     = 7,  ///< 6    Windowed, Re-sampled
      CmpFilterMode_Windowed_Filtered      = 8,  ///< 7    Windowed, Filtered
   };

   /**
    * Comparator Enable
    * (cmp_cr1_en)
    *
    * Enable comparator
    */
   enum CmpEnable : uint8_t {
      CmpEnable_Disabled   = CMP_CR1_EN(0),  ///< Comparator is disabled
      CmpEnable_Enabled    = CMP_CR1_EN(1),  ///< Comparator is enabled
   };

   /**
    * Windowing Enable
    * (cmp_cr1_we)
    *
    * Enable the use of an external signal to qualify the comparator output (before filtering).
    * The comparator output is held when the external signal is inactive and
    * clocked directly by the bus clock when enabled.
    * Usually a PDB output is available for this purpose.
    */
   enum CmpWindowEnable : uint8_t {
      CmpWindowEnable_Bypassed   = CMP_CR1_WE(0),  ///< Bypassed
      CmpWindowEnable_Enabled    = CMP_CR1_WE(1),  ///< Enabled
   };

   /**
    * Sample Enable
    * (cmp_cr1_se)
    *
    * Select between the divided bus clock and an external clock for the filter block
    */
   enum CmpSampleEnable : uint8_t {
      CmpSampleEnable_Internal   = CMP_CR1_SE(0),  ///< Internal clock
      CmpSampleEnable_External   = CMP_CR1_SE(1),  ///< External clock
   };

   /**
    * Filter Sample Count
    * (cmp_cr0_filter_cnt)
    *
    * Represents the number of consecutive samples that must agree prior 
    * to the comparator output filter accepting a new output state
    */
   enum CmpFilterSamples : uint8_t {
      CmpFilterSamples_Bypassed         = CMP_CR0_FILTER_CNT(0),  ///< Bypassed
      CmpFilterSamples_SimpleSampling   = CMP_CR0_FILTER_CNT(1),  ///< Simple sampling
      CmpFilterSamples_2                = CMP_CR0_FILTER_CNT(2),  ///< 2 samples must agree
      CmpFilterSamples_3                = CMP_CR0_FILTER_CNT(3),  ///< 3 samples must agree
      CmpFilterSamples_4                = CMP_CR0_FILTER_CNT(4),  ///< 4 samples must agree
      CmpFilterSamples_5                = CMP_CR0_FILTER_CNT(5),  ///< 5 samples must agree
      CmpFilterSamples_6                = CMP_CR0_FILTER_CNT(6),  ///< 6 samples must agree
      CmpFilterSamples_7                = CMP_CR0_FILTER_CNT(7),  ///< 7 samples must agree
   };

   /**
    * Operating mode
    * (cmp_cr1_mode)
    *
    * Selects operation in sampling or windowed mode
    */
   enum CmpMode : uint8_t {
      CmpMode_Direct     = CMP_CR1_SE(0)|CMP_CR1_WE(0),  ///< Direct
      CmpMode_Sampling   = CMP_CR1_SE(1)|CMP_CR1_WE(0),  ///< Sampling mode
      CmpMode_Windowed   = CMP_CR1_SE(0)|CMP_CR1_WE(1),  ///< Windowing mode
   };

   /**
    * Edge detection flag
    * (cmp_scr_edge)
    *
    * Indicates edge detected
    */
   enum CmpEventId : uint8_t {
      CmpEventId_None          = CMP_SCR_CFR(0)|CMP_SCR_CFF(0),  ///< None
      CmpEventId_RisingEdge    = CMP_SCR_CFR(1)|CMP_SCR_CFF(0),  ///< Rising Edge
      CmpEventId_FallingEdge   = CMP_SCR_CFR(0)|CMP_SCR_CFF(1),  ///< Falling Edge
      CmpEventId_BothEdges     = CMP_SCR_CFR(1)|CMP_SCR_CFF(1),  ///< Both Edges
   };

   /**
    * Comparator event identification
    */
   /**
    * Used to represent the comparator status for interrupt handler
    */
   struct CmpStatus {
      CmpEventId event:8;   //!< Event triggering handler
      bool       state:8;   //!< State of CMPO at event
   
      constexpr CmpStatus(CmpEventId event, uint8_t  state) : event(event), state(state) {}
   };
   
class CmpBasicInfo {

public:
}; // class CmpBasicInfo 

class Cmp0Info : public CmpBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: CMP0_IN0             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: CMP0_IN1             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: CMP0_IN2             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   3: CMP0_IN3             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   5: CMP0_IN5             = VREF_OUT(p13)                  */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   6: CMP0_IN6             = BANDGAP(Internal)              */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   7: CMP0_IN7             = CMP_DAC(Internal)              */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   8: CMP0_OUT             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:cmp0
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with CMP0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with CMP0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMP0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Cmp0
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_CMP_MASK;
   }
   
   /**
    *  Disable clock to Cmp0
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_CMP_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = CMP0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<CMP_Type> cmp = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
}; // class Cmp0Info

/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * CMP1 Positive Input Select
    * (cmp_muxcr_psel)
    *
    * Selects the Cmp1 positive input source
    */
   static constexpr CmpInputPlus Cmp1InputPlus_0           = CmpInputPlus_0;  ///< CMP1_IN0 [-]
   static constexpr CmpInputPlus Cmp1InputPlus_1           = CmpInputPlus_1;  ///< CMP1_IN1 [-]
   static constexpr CmpInputPlus Cmp1InputPlus_3           = CmpInputPlus_3;  ///< CMP1_IN3 [ADC0_SE23]
   static constexpr CmpInputPlus Cmp1InputPlus_Adc0_se23   = CmpInputPlus_3;  ///< Pin ADC0_SE23
   static constexpr CmpInputPlus Cmp1InputPlus_5           = CmpInputPlus_5;  ///< CMP1_IN5 [VREF_OUT(p13)]
   static constexpr CmpInputPlus Cmp1InputPlus_6           = CmpInputPlus_6;  ///< CMP1_IN6 [BANDGAP(Internal)]
   static constexpr CmpInputPlus Cmp1InputPlus_7           = CmpInputPlus_7;  ///< CMP1_IN7 [CMP_DAC(Internal)]


   /**
    * CMP1 Negative Input Select
    * (cmp_muxcr_msel)
    *
    * Selects the Cmp1 negative input source
    */
   static constexpr CmpInputMinus Cmp1InputMinus_0           = CmpInputMinus_0;  ///< CMP1_IN0 [-]
   static constexpr CmpInputMinus Cmp1InputMinus_1           = CmpInputMinus_1;  ///< CMP1_IN1 [-]
   static constexpr CmpInputMinus Cmp1InputMinus_3           = CmpInputMinus_3;  ///< CMP1_IN3 [ADC0_SE23]
   static constexpr CmpInputMinus Cmp1InputMinus_Adc0_se23   = CmpInputMinus_3;  ///< Pin ADC0_SE23
   static constexpr CmpInputMinus Cmp1InputMinus_5           = CmpInputMinus_5;  ///< CMP1_IN5 [VREF_OUT(p13)]
   static constexpr CmpInputMinus Cmp1InputMinus_6           = CmpInputMinus_6;  ///< CMP1_IN6 [BANDGAP(Internal)]
   static constexpr CmpInputMinus Cmp1InputMinus_7           = CmpInputMinus_7;  ///< CMP1_IN7 [CMP_DAC(Internal)]


class Cmp1Info : public CmpBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: CMP1_IN0             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: CMP1_IN1             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   3: CMP1_IN3             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   5: CMP1_IN5             = VREF_OUT(p13)                  */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   6: CMP1_IN6             = BANDGAP(Internal)              */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   7: CMP1_IN7             = CMP_DAC(Internal)              */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   8: CMP1_OUT             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:cmp0
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with CMP1
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with CMP1
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMP1_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Cmp1
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_CMP_MASK;
   }
   
   /**
    *  Disable clock to Cmp1
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_CMP_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = CMP1_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<CMP_Type> cmp = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 1;
   
}; // class Cmp1Info


// /CMP/InputMapping None Found


/**
 * End CMP_Group
 * @}
 */
} // End namespace USBDM

#endif // /ACMP/_BasicInfoGuard

#endif /* PROJECT_HEADERS_CMP_H_ */
