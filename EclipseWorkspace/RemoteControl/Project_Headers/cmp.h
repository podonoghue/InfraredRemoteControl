/**
 * @file     cmp.h (180.ARM_Peripherals/Project_Headers/cmp.h)
 * @brief    Analogue Comparator
 */

#ifndef PROJECT_HEADERS_CMP_H_
#define PROJECT_HEADERS_CMP_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

#if false // /CMP/_BasicInfoGuard

namespace USBDM {
// Forward declaration
struct CmpStatus;
}

// No handler defined for CMP0
// No handler defined for CMP1


namespace USBDM {

/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */

   /**
    * CMP Positive Input Select
    * (cmp_muxcr_psel_base)
    *
    * Selects the positive input source
    */
   enum class CmpInputPlus : uint8_t {
      CmpInputPlus_0   = CMP_MUXCR_PSEL(0),  ///< External input 0
      CmpInputPlus_1   = CMP_MUXCR_PSEL(1),  ///< External input 1
      CmpInputPlus_2   = CMP_MUXCR_PSEL(2),  ///< External input 2
      CmpInputPlus_3   = CMP_MUXCR_PSEL(3),  ///< External input 3
      CmpInputPlus_4   = CMP_MUXCR_PSEL(4),  ///< External input 4
      CmpInputPlus_5   = CMP_MUXCR_PSEL(5),  ///< External input 5
      CmpInputPlus_6   = CMP_MUXCR_PSEL(6),  ///< External input 6
      CmpInputPlus_7   = CMP_MUXCR_PSEL(7),  ///< External input 7
   };

   /**
    * CMP0 Positive Input Select
    * (cmp_muxcr_psel)
    *
    * Selects the Cmp0 positive input source
    */
   inline constexpr CmpInputPlus Cmp0InputPlus_0            = CmpInputPlus::CmpInputPlus_0; ///< CMP0_IN0 [-]
   inline constexpr CmpInputPlus Cmp0InputPlus_1            = CmpInputPlus::CmpInputPlus_1; ///< CMP0_IN1 [-]
   inline constexpr CmpInputPlus Cmp0InputPlus_2            = CmpInputPlus::CmpInputPlus_2; ///< CMP0_IN2 [-]
   inline constexpr CmpInputPlus Cmp0InputPlus_3            = CmpInputPlus::CmpInputPlus_3; ///< CMP0_IN3 [-]
   inline constexpr CmpInputPlus Cmp0InputPlus_5            = CmpInputPlus::CmpInputPlus_5; ///< CMP0_IN5 [VREF_OUT(p13)]
   inline constexpr CmpInputPlus Cmp0InputPlus_Vref_out     = CmpInputPlus::CmpInputPlus_5; ///< Pin VREF_OUT
   inline constexpr CmpInputPlus Cmp0InputPlus_6            = CmpInputPlus::CmpInputPlus_6; ///< CMP0_IN6 [BANDGAP(Internal)]
   inline constexpr CmpInputPlus Cmp0InputPlus_Bandgap      = CmpInputPlus::CmpInputPlus_6; ///< Pin BANDGAP
   inline constexpr CmpInputPlus Cmp0InputPlus_7            = CmpInputPlus::CmpInputPlus_7; ///< CMP0_IN7 [CMP_DAC(Internal)]
   inline constexpr CmpInputPlus Cmp0InputPlus_Cmp_dac      = CmpInputPlus::CmpInputPlus_7; ///< Pin CMP_DAC


   /**
    * CMP Negative Input Select
    * (cmp_muxcr_msel_base)
    *
    * Selects the negative input source
    */
   enum class CmpInputMinus : uint8_t {
      CmpInputMinus_0   = CMP_MUXCR_MSEL(0),  ///< External input 0
      CmpInputMinus_1   = CMP_MUXCR_MSEL(1),  ///< External input 1
      CmpInputMinus_2   = CMP_MUXCR_MSEL(2),  ///< External input 2
      CmpInputMinus_3   = CMP_MUXCR_MSEL(3),  ///< External input 3
      CmpInputMinus_4   = CMP_MUXCR_MSEL(4),  ///< External input 4
      CmpInputMinus_5   = CMP_MUXCR_MSEL(5),  ///< External input 5
      CmpInputMinus_6   = CMP_MUXCR_MSEL(6),  ///< External input 6
      CmpInputMinus_7   = CMP_MUXCR_MSEL(7),  ///< External input 7
   };

   /**
    * CMP0 Negative Input Select
    * (cmp_muxcr_msel)
    *
    * Selects the Cmp0 negative input source
    */
   inline constexpr CmpInputMinus Cmp0InputMinus_0            = CmpInputMinus::CmpInputMinus_0; ///< CMP0_IN0 [-]
   inline constexpr CmpInputMinus Cmp0InputMinus_1            = CmpInputMinus::CmpInputMinus_1; ///< CMP0_IN1 [-]
   inline constexpr CmpInputMinus Cmp0InputMinus_2            = CmpInputMinus::CmpInputMinus_2; ///< CMP0_IN2 [-]
   inline constexpr CmpInputMinus Cmp0InputMinus_3            = CmpInputMinus::CmpInputMinus_3; ///< CMP0_IN3 [-]
   inline constexpr CmpInputMinus Cmp0InputMinus_5            = CmpInputMinus::CmpInputMinus_5; ///< CMP0_IN5 [VREF_OUT(p13)]
   inline constexpr CmpInputMinus Cmp0InputMinus_Vref_out     = CmpInputMinus::CmpInputMinus_5; ///< Pin VREF_OUT
   inline constexpr CmpInputMinus Cmp0InputMinus_6            = CmpInputMinus::CmpInputMinus_6; ///< CMP0_IN6 [BANDGAP(Internal)]
   inline constexpr CmpInputMinus Cmp0InputMinus_Bandgap      = CmpInputMinus::CmpInputMinus_6; ///< Pin BANDGAP
   inline constexpr CmpInputMinus Cmp0InputMinus_7            = CmpInputMinus::CmpInputMinus_7; ///< CMP0_IN7 [CMP_DAC(Internal)]
   inline constexpr CmpInputMinus Cmp0InputMinus_Cmp_dac      = CmpInputMinus::CmpInputMinus_7; ///< Pin CMP_DAC



   // Bit operators for MUXCR register fields
   constexpr inline uint8_t operator|(CmpInputPlus op1, CmpInputMinus op2)  { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpInputMinus op1, CmpInputPlus op2)  { return uint8_t(op1)|uint8_t(op2); };
   
   /**
    * CMP1 Positive Input Select
    * (cmp_muxcr_psel)
    *
    * Selects the Cmp1 positive input source
    */
   inline constexpr CmpInputPlus Cmp1InputPlus_0             = CmpInputPlus::CmpInputPlus_0; ///< CMP1_IN0 [-]
   inline constexpr CmpInputPlus Cmp1InputPlus_1             = CmpInputPlus::CmpInputPlus_1; ///< CMP1_IN1 [-]
   inline constexpr CmpInputPlus Cmp1InputPlus_3             = CmpInputPlus::CmpInputPlus_3; ///< CMP1_IN3 [ADC0_SE23]
   inline constexpr CmpInputPlus Cmp1InputPlus_Adc0_se23     = CmpInputPlus::CmpInputPlus_3; ///< Pin ADC0_SE23
   inline constexpr CmpInputPlus Cmp1InputPlus_5             = CmpInputPlus::CmpInputPlus_5; ///< CMP1_IN5 [VREF_OUT(p13)]
   inline constexpr CmpInputPlus Cmp1InputPlus_Vref_out      = CmpInputPlus::CmpInputPlus_5; ///< Pin VREF_OUT
   inline constexpr CmpInputPlus Cmp1InputPlus_6             = CmpInputPlus::CmpInputPlus_6; ///< CMP1_IN6 [BANDGAP(Internal)]
   inline constexpr CmpInputPlus Cmp1InputPlus_Bandgap       = CmpInputPlus::CmpInputPlus_6; ///< Pin BANDGAP
   inline constexpr CmpInputPlus Cmp1InputPlus_7             = CmpInputPlus::CmpInputPlus_7; ///< CMP1_IN7 [CMP_DAC(Internal)]
   inline constexpr CmpInputPlus Cmp1InputPlus_Cmp_dac       = CmpInputPlus::CmpInputPlus_7; ///< Pin CMP_DAC


   /**
    * CMP1 Negative Input Select
    * (cmp_muxcr_msel)
    *
    * Selects the Cmp1 negative input source
    */
   inline constexpr CmpInputMinus Cmp1InputMinus_0             = CmpInputMinus::CmpInputMinus_0; ///< CMP1_IN0 [-]
   inline constexpr CmpInputMinus Cmp1InputMinus_1             = CmpInputMinus::CmpInputMinus_1; ///< CMP1_IN1 [-]
   inline constexpr CmpInputMinus Cmp1InputMinus_3             = CmpInputMinus::CmpInputMinus_3; ///< CMP1_IN3 [ADC0_SE23]
   inline constexpr CmpInputMinus Cmp1InputMinus_Adc0_se23     = CmpInputMinus::CmpInputMinus_3; ///< Pin ADC0_SE23
   inline constexpr CmpInputMinus Cmp1InputMinus_5             = CmpInputMinus::CmpInputMinus_5; ///< CMP1_IN5 [VREF_OUT(p13)]
   inline constexpr CmpInputMinus Cmp1InputMinus_Vref_out      = CmpInputMinus::CmpInputMinus_5; ///< Pin VREF_OUT
   inline constexpr CmpInputMinus Cmp1InputMinus_6             = CmpInputMinus::CmpInputMinus_6; ///< CMP1_IN6 [BANDGAP(Internal)]
   inline constexpr CmpInputMinus Cmp1InputMinus_Bandgap       = CmpInputMinus::CmpInputMinus_6; ///< Pin BANDGAP
   inline constexpr CmpInputMinus Cmp1InputMinus_7             = CmpInputMinus::CmpInputMinus_7; ///< CMP1_IN7 [CMP_DAC(Internal)]
   inline constexpr CmpInputMinus Cmp1InputMinus_Cmp_dac       = CmpInputMinus::CmpInputMinus_7; ///< Pin CMP_DAC



/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */

   /**
    * Action on transition
    * (cmp_scr_interrupt)
    *
    * Enables interrupt request on comparator transition
    */
   enum CmpEvent : uint8_t {
      CmpEvent_Disabled    = CMP_SCR_IER(0)|CMP_SCR_IEF(0),  ///< Disabled
      CmpEvent_OnRising    = CMP_SCR_IER(1)|CMP_SCR_IEF(1),  ///< Rising edge
      CmpEvent_OnFalling   = CMP_SCR_IER(1)|CMP_SCR_IEF(0),  ///< Falling edge
      CmpEvent_OnEither    = CMP_SCR_IER(1)|CMP_SCR_IEF(0),  ///< Either edge
   };

   /**
    * DMA Enable Control
    * (cmp_scr_dmaen)
    *
    * Enables the DMA transfer triggered from the CMP module (If DMA supported by device)
    * When this field is set, a DMA request is asserted when CFR or CFF is set
    */
   enum CmpDma : uint8_t {
      CmpDma_Disabled   = CMP_SCR_DMAEN(0),  ///< Disabled
      CmpDma_Enabled    = CMP_SCR_DMAEN(1),  ///< Enabled
   };

   /**
    * Comparator hard block hysteresis control
    * (cmp_cr0_hystctr)
    *
    * Defines the programmable hysteresis level.
    * The hysteresis values associated with each level are device specific
    */
   enum CmpHysteresis : uint8_t {
      CmpHysteresis_Level_0   = CMP_CR0_HYSTCTR(0),  ///< Level 0
      CmpHysteresis_Level_1   = CMP_CR0_HYSTCTR(1),  ///< Level 1
      CmpHysteresis_Level_2   = CMP_CR0_HYSTCTR(2),  ///< Level 2
      CmpHysteresis_Level_3   = CMP_CR0_HYSTCTR(3),  ///< Level 3
   };

   /**
    * Power Mode Select
    * (cmp_cr1_pmode)
    *
    * Selects trade-off between speed and power consumption
    */
   enum CmpPower : uint8_t {
      CmpPower_LowSpeed    = CMP_CR1_PMODE(0),  ///< Low-Speed
      CmpPower_HighSpeed   = CMP_CR1_PMODE(1),  ///< High-Speed
   };

   /**
    * Comparator Invert
    * (cmp_cr1_inv)
    *
    * Allows selection of the polarity of the analog comparator function
    */
   enum CmpPolarity : uint8_t {
      CmpPolarity_Normal     = CMP_CR1_INV(0),  ///< Not inverted
      CmpPolarity_Inverted   = CMP_CR1_INV(1),  ///< Inverted
   };

   /**
    * Comparator output pin source
    * (cmp_cr1_output)
    *
    * Selects whether the output pin is driven by the filtered or unfiltered comparator output
    */
   enum CmpOutput : uint8_t {
      CmpOutput_Disabled   = CMP_CR1_OPE(0)|CMP_CR1_COS(0),  ///< Disabled
      CmpOutput_Direct     = CMP_CR1_OPE(1)|CMP_CR1_COS(1),  ///< Direct (unfiltered)
      CmpOutput_Filtered   = CMP_CR1_OPE(1)|CMP_CR1_COS(0),  ///< Filtered
   };

   /**
    * DAC Enable
    * (cmp_daccr_dacen)
    *
    * Enables the internal DAC
    */
   enum CmpDacEnable : uint8_t {
      CmpDacEnable_Disabled   = CMP_DACCR_DACEN(0),  ///< Disabled
      CmpDacEnable_Enabled    = CMP_DACCR_DACEN(1),  ///< Enabled
   };

   /**
    * DAC Reference Voltage Select
    * (cmp_daccr_vrsel)
    *
    * Supply Voltage Reference Source Select
    */
   enum CmpDacrefSel : uint8_t {
      CmpDacrefSel_VrefOut   = CMP_DACCR_VRSEL(0),  ///< Vin1 (Vref_OUT)
      CmpDacrefSel_Vdd       = CMP_DACCR_VRSEL(1),  ///< Vin2 (Vdd)
   };

   /**
    * DAC level
    * (cmp_daccr_vosel)
    *
    * Specifies the output level of the internal DAC
    */
   enum CmpDacLevel : int8_t {
   };

   /**
    * Comparator Filtering Mode
    * (cmp_mode)
    *
    * Comparitor mode of operation
    */
   enum CmpFilterMode : uint8_t {
      CmpFilterMode_Disabled               = 0,  ///< 1    Disabled
      CmpFilterMode_Continuous             = 1,  ///< 2a/b Continuous
      CmpFilterMode_External_NonFiltered   = 2,  ///< 3a   Externally sampled, Non-Filtered
      CmpFilterMode_Internal_NonFiltered   = 3,  ///< 3b   Internally sampled, Non-Filtered
      CmpFilterMode_External_Filtered      = 4,  ///< 4a   Externally sampled, Filtered
      CmpFilterMode_Internal_Filtered      = 5,  ///< 4b   Internally sampled, Filtered
      CmpFilterMode_Windowed               = 6,  ///< 5a/b Windowed
      CmpFilterMode_Windowed_Resampled     = 7,  ///< 6    Windowed, Re-sampled
      CmpFilterMode_Windowed_Filtered      = 8,  ///< 7    Windowed, Filtered
   };

   /**
    * Comparator Enable
    * (cmp_cr1_en)
    *
    * Enable comparator
    */
   enum CmpEnable : uint8_t {
      CmpEnable_Disabled   = CMP_CR1_EN(0),  ///< Comparator is disabled
      CmpEnable_Enabled    = CMP_CR1_EN(1),  ///< Comparator is enabled
   };

   /**
    * Windowing Enable
    * (cmp_cr1_we)
    *
    * Enable the use of an external signal to qualify the comparator output (before filtering).
    * The comparator output is held when the external signal is inactive and
    * clocked directly by the bus clock when enabled.
    * Usually a PDB output is available for this purpose.
    */
   enum CmpWindowEnable : uint8_t {
      CmpWindowEnable_Bypassed   = CMP_CR1_WE(0),  ///< Bypassed
      CmpWindowEnable_Enabled    = CMP_CR1_WE(1),  ///< Enabled
   };

   /**
    * Sample Enable
    * (cmp_cr1_se)
    *
    * Select between the divided bus clock and an external clock for the filter block
    */
   enum CmpSampleEnable : uint8_t {
      CmpSampleEnable_Internal   = CMP_CR1_SE(0),  ///< Internal clock
      CmpSampleEnable_External   = CMP_CR1_SE(1),  ///< External clock
   };

   /**
    * Filter Sample Count
    * (cmp_cr0_filter_cnt)
    *
    * Represents the number of consecutive samples that must agree prior 
    * to the comparator output filter accepting a new output state
    */
   enum CmpFilterSamples : uint8_t {
      CmpFilterSamples_Bypassed         = CMP_CR0_FILTER_CNT(0),  ///< Bypassed
      CmpFilterSamples_SimpleSampling   = CMP_CR0_FILTER_CNT(1),  ///< Simple sampling
      CmpFilterSamples_2                = CMP_CR0_FILTER_CNT(2),  ///< 2 samples must agree
      CmpFilterSamples_3                = CMP_CR0_FILTER_CNT(3),  ///< 3 samples must agree
      CmpFilterSamples_4                = CMP_CR0_FILTER_CNT(4),  ///< 4 samples must agree
      CmpFilterSamples_5                = CMP_CR0_FILTER_CNT(5),  ///< 5 samples must agree
      CmpFilterSamples_6                = CMP_CR0_FILTER_CNT(6),  ///< 6 samples must agree
      CmpFilterSamples_7                = CMP_CR0_FILTER_CNT(7),  ///< 7 samples must agree
   };

   /**
    * Operating mode
    * (cmp_cr1_mode)
    *
    * Selects operation in sampling or windowed mode
    */
   enum CmpMode : uint8_t {
      CmpMode_Direct     = CMP_CR1_SE(0)|CMP_CR1_WE(0),  ///< Direct
      CmpMode_Sampling   = CMP_CR1_SE(1)|CMP_CR1_WE(0),  ///< Sampling mode
      CmpMode_Windowed   = CMP_CR1_SE(0)|CMP_CR1_WE(1),  ///< Windowing mode
   };

   /**
    * Edge detection flag
    * (cmp_scr_edge)
    *
    * Indicates edge detected
    */
   enum CmpEventId : uint8_t {
      CmpEventId_None          = CMP_SCR_CFR(0)|CMP_SCR_CFF(0),  ///< None
      CmpEventId_RisingEdge    = CMP_SCR_CFR(1)|CMP_SCR_CFF(0),  ///< Rising Edge
      CmpEventId_FallingEdge   = CMP_SCR_CFR(0)|CMP_SCR_CFF(1),  ///< Falling Edge
      CmpEventId_BothEdges     = CMP_SCR_CFR(1)|CMP_SCR_CFF(1),  ///< Both Edges
   };

   /**
    * Comparator event identification
    */
   /**
    * Used to represent the comparator status for interrupt handler
    */
   struct CmpStatus {
      CmpEventId event:8;   //!< Event triggering handler
      bool       state:8;   //!< State of CMPO at event
   
      constexpr CmpStatus(CmpEventId event, uint8_t  state) : event(event), state(state) {}
   };
   

   // Bit operators for CR0 register fields
   constexpr inline uint8_t operator|(CmpHysteresis op1, CmpFilterSamples op2)    { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpFilterSamples op1, CmpHysteresis op2)    { return uint8_t(op1)|uint8_t(op2); };
   

   // Bit operators for CR1 register fields
   constexpr inline uint8_t operator|(CmpPower op1, CmpPolarity op2)            { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpPower op1, CmpOutput op2)              { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpPower op1, CmpEnable op2)              { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpPower op1, CmpWindowEnable op2)        { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpPower op1, CmpSampleEnable op2)        { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpPolarity op1, CmpPower op2)            { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpPolarity op1, CmpOutput op2)           { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpPolarity op1, CmpEnable op2)           { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpPolarity op1, CmpWindowEnable op2)     { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpPolarity op1, CmpSampleEnable op2)     { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpOutput op1, CmpPower op2)              { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpOutput op1, CmpPolarity op2)           { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpOutput op1, CmpEnable op2)             { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpOutput op1, CmpWindowEnable op2)       { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpOutput op1, CmpSampleEnable op2)       { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpEnable op1, CmpPower op2)              { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpEnable op1, CmpPolarity op2)           { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpEnable op1, CmpOutput op2)             { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpEnable op1, CmpWindowEnable op2)       { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpEnable op1, CmpSampleEnable op2)       { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpWindowEnable op1, CmpPower op2)        { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpWindowEnable op1, CmpPolarity op2)     { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpWindowEnable op1, CmpOutput op2)       { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpWindowEnable op1, CmpEnable op2)       { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpWindowEnable op1, CmpSampleEnable op2) { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpSampleEnable op1, CmpPower op2)        { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpSampleEnable op1, CmpPolarity op2)     { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpSampleEnable op1, CmpOutput op2)       { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpSampleEnable op1, CmpEnable op2)       { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(CmpSampleEnable op1, CmpWindowEnable op2) { return uint8_t(op1)|uint8_t(op2); };
   
class CmpBasicInfo {

public:

}; // class CmpBasicInfo 

class Cmp0Info : public CmpBasicInfo {

public:

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: CMP0_IN0             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: CMP0_IN1             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: CMP0_IN2             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   3: CMP0_IN3             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   5: CMP0_IN5             = VREF_OUT(p13)                  */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   6: CMP0_IN6             = BANDGAP(Internal)              */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   7: CMP0_IN7             = CMP_DAC(Internal)              */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   8: CMP0_OUT             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:cmp0
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with CMP0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with CMP0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMP0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Cmp0
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_CMP_MASK;
   }
   
   /**
    *  Disable clock to Cmp0
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_CMP_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = CMP0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<CMP_Type> cmp = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
}; // class Cmp0Info

/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */

class Cmp1Info : public CmpBasicInfo {

public:

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: CMP1_IN0             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: CMP1_IN1             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   3: CMP1_IN3             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   5: CMP1_IN5             = VREF_OUT(p13)                  */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   6: CMP1_IN6             = BANDGAP(Internal)              */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   7: CMP1_IN7             = CMP_DAC(Internal)              */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   8: CMP1_OUT             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:cmp0
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with CMP1
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with CMP1
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMP1_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Cmp1
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_CMP_MASK;
   }
   
   /**
    *  Disable clock to Cmp1
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_CMP_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = CMP1_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<CMP_Type> cmp = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 1;
   
}; // class Cmp1Info


// /CMP/InputMapping None Found


/**
 * End CMP_Group
 * @}
 */
} // End namespace USBDM

#endif // /CMP/_BasicInfoGuard

#endif /* PROJECT_HEADERS_CMP_H_ */
