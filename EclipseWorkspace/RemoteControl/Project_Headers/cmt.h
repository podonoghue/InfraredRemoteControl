/**
 * @file     cmt.h (180.ARM_Peripherals/Project_Headers/cmt.h)
 * @brief    Carrier Modulator Transmitter
 */

#ifndef HEADER_CMT_H_
#define HEADER_CMT_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

// No handler defined for CMT 


namespace USBDM {

/**
 * @addtogroup CMT_Group CMT, Carrier Modulator Transmitter
 * @brief Abstraction for Carrier Modulator Transmitter
 * @{
 */
/**
 * Peripheral information for CMT, Carrier Modulator Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Mode of operation
    * (cmt_msc_mode)
    *
    * Selects between Time, Baseband, FSK and direct modes
    */
   enum CmtMode : uint8_t {
      CmtMode_Direct            = CMT_MSC_MCGEN(0)|CMT_MSC_BASE(0)|CMT_MSC_FSK(0),  ///< Direct
      CmtMode_Time              = CMT_MSC_MCGEN(1)|CMT_MSC_BASE(0)|CMT_MSC_FSK(0),  ///< Time
      CmtMode_Baseband          = CMT_MSC_MCGEN(1)|CMT_MSC_BASE(1)|CMT_MSC_FSK(0),  ///< Baseband
      CmtMode_FreqShiftKeying   = CMT_MSC_MCGEN(1)|CMT_MSC_BASE(0)|CMT_MSC_FSK(1),  ///< FreqShiftKeying
   };

   /**
    * End Of Cycle Status Flag
    * (cmt_msc_eocf)
    *
    * Sets when:
    * - The modulator is not currently active and MCGEN is set
    * - At the end of each modulation cycle while MCGEN is set
    * Cleared in polling mode by:
    * - Calling getEndOfCycleFlag() followed by accessing mark or space periods, or
    * - Calling clearEndOfCycleFlag()
    * Cleared in DMA mode by:
    * - A DMA cycle
    */
   enum CmtStatus : uint8_t {
      CmtStatus_CycleIncomplete   = CMT_MSC_EOCF(0),  ///< Cycle incomplete
      CmtStatus_CycleCompleted    = CMT_MSC_EOCF(1),  ///< Cycle completed
   };

   /**
    * Output Control
    * (cmt_oc_output)
    *
    * Enables and controls the polarity of the IRO signal.
    * When enabled, the the IRO signal is an output that drives out either
    * the CMT transmitter output or the state of IROL depending on whether
    * MSC[MCGEN] is set or not
    */
   enum CmtOutput : uint8_t {
      CmtOutput_Disabled     = CMT_OC_IROPEN(0)|CMT_OC_CMTPOL(0),  ///< Disabled
      CmtOutput_ActiveLow    = CMT_OC_IROPEN(1)|CMT_OC_CMTPOL(0),  ///< Active-low
      CmtOutput_ActiveHigh   = CMT_OC_IROPEN(1)|CMT_OC_CMTPOL(1),  ///< Active-high
   };

   /**
    * IRO Latch Control
    * (cmt_oc_irol)
    *
    * On reads provides the state of the IRO latch.
    * The value written controls the state of the IRO signal when mode[MSC_MODE]
    * is direct and output[OC_OUTPUT] is not disabled
    */
   enum CmtOutputLevel : uint8_t {
      CmtOutputLevel_Low    = CMT_OC_IROL(0),  ///< Low
      CmtOutputLevel_High   = CMT_OC_IROL(1),  ///< High
   };

   /**
    * Primary Prescaler Divider
    * (cmt_pps_ppsdiv)
    *
    * Divides the CMT clock to generate the Intermediate Frequency clock
    * to the secondary prescaler.
    * This should be chosen to produce a nominal 8MHz frequency from the CMT intermediate frequency.
    */
   enum CmtClockPrescaler : uint8_t {
      CmtClockPrescaler_BusClockDivBy1    = CMT_PPS_PPSDIV(0),   ///< Bus clock / 1
      CmtClockPrescaler_BusClockDivBy2    = CMT_PPS_PPSDIV(1),   ///< Bus clock / 2
      CmtClockPrescaler_BusClockDivBy3    = CMT_PPS_PPSDIV(2),   ///< Bus clock / 3
      CmtClockPrescaler_BusClockDivBy4    = CMT_PPS_PPSDIV(3),   ///< Bus clock / 4
      CmtClockPrescaler_BusClockDivBy5    = CMT_PPS_PPSDIV(4),   ///< Bus clock / 5
      CmtClockPrescaler_BusClockDivBy6    = CMT_PPS_PPSDIV(5),   ///< Bus clock / 6
      CmtClockPrescaler_BusClockDivBy7    = CMT_PPS_PPSDIV(6),   ///< Bus clock / 7
      CmtClockPrescaler_BusClockDivBy8    = CMT_PPS_PPSDIV(7),   ///< Bus clock / 8
      CmtClockPrescaler_BusClockDivBy9    = CMT_PPS_PPSDIV(8),   ///< Bus clock / 9
      CmtClockPrescaler_BusClockDivBy10   = CMT_PPS_PPSDIV(9),   ///< Bus clock / 10
      CmtClockPrescaler_BusClockDivBy11   = CMT_PPS_PPSDIV(10),  ///< Bus clock / 11
      CmtClockPrescaler_BusClockDivBy12   = CMT_PPS_PPSDIV(11),  ///< Bus clock / 12
      CmtClockPrescaler_BusClockDivBy13   = CMT_PPS_PPSDIV(12),  ///< Bus clock / 13
      CmtClockPrescaler_BusClockDivBy14   = CMT_PPS_PPSDIV(13),  ///< Bus clock / 14
      CmtClockPrescaler_BusClockDivBy15   = CMT_PPS_PPSDIV(14),  ///< Bus clock / 15
      CmtClockPrescaler_BusClockDivBy16   = CMT_PPS_PPSDIV(15),  ///< Bus clock / 16
      CmtClockPrescaler_Auto              = 0xFF,               ///< Calculate divider to generate 8MHz based on input clock
   };

   /**
    * Intermediate frequency Prescaler
    * (cmt_msc_cmtdiv)
    *
    * Causes the CMT to be clocked at the Intermediate frequency divided by 1, 2, 4, or 8
    */
   enum CmtIntermediatePrescaler : uint8_t {
      CmtIntermediatePrescaler_DivBy1   = CMT_MSC_CMTDIV(0),  ///< Intermediate frequency /1
      CmtIntermediatePrescaler_DivBy2   = CMT_MSC_CMTDIV(1),  ///< Intermediate frequency /2
      CmtIntermediatePrescaler_DivBy4   = CMT_MSC_CMTDIV(2),  ///< Intermediate frequency /4
      CmtIntermediatePrescaler_DivBy8   = CMT_MSC_CMTDIV(3),  ///< Intermediate frequency /8
   };

   /**
    * Extended Space Enable
    * (cmt_msc_exspc)
    *
    * In either Time, Baseband, or FSK mode, allows the space period                         
    * to be made longer than the maximum possible value of the space period register.        
    * Setting MSC[EXSPC] will force the modulator to treat the next modulation period,       
    * beginning with the next load of the counter and space period registers, as a space     
    * period equal in length to the mark and space counts combined.                          
    * Subsequent modulation periods will consist entirely of these extended space periods    
    * with no mark periods.                                                                  
    * Clearing MSC[EXSPC] will return the modulator to standard operation at the beginning   
    * of the next modulation period.
    */
   enum CmtExtendedSpace : uint8_t {
      CmtExtendedSpace_Disabled   = CMT_MSC_EXSPC(0),  ///< Disabled
      CmtExtendedSpace_Enabled    = CMT_MSC_EXSPC(1),  ///< Enabled
   };

   /**
    * End of Cycle Event handling
    * (cmt_dma_irq)
    *
    * Enables Interrupt or DMA request on end of cycle (when EOCIE set)
    */
   enum CmtEndOfCycleAction : uint8_t {
      CmtEndOfCycleAction_None          = CMT_MSC_EOCIE(0)|CMT_DMA_DMA(0),  ///< No Action
      CmtEndOfCycleAction_Interrupt     = CMT_MSC_EOCIE(1)|CMT_DMA_DMA(0),  ///< Interrupt Request
      CmtEndOfCycleAction_DmaTransfer   = CMT_MSC_EOCIE(1)|CMT_DMA_DMA(1),  ///< DMA Transfer Request
   };

   /**
    * Primary Carrier High Time Data Value
    * (cmt_cgh1_ph)
    *
    * Contains the number of input clocks required to generate the carrier high time period.
    * When operating in Time mode, this register is always selected.
    * When operating in FSK mode, this register and the secondary register pair are
    * alternately selected under the control of the modulator.
    * The primary carrier high time value is undefined out of reset.
    * This register must be written to nonzero values before the carrier 
    * generator is enabled to avoid spurious results.
    */
   enum CmtPrimaryCarrierHighTime : uint8_t {
   };

   /**
    * Primary Carrier Low Time Data Value
    * (cmt_cgl1_pl)
    *
    * Contains the number of input clocks required to generate the carrier low time period.
    * When operating in Time mode, this register is always selected.
    * When operating in FSK mode, this register and the secondary register pair are
    * alternately selected under the control of the modulator.
    * The primary carrier low time value is undefined out of reset.
    * This register must be written to nonzero values before the carrier generator
    * is enabled to avoid spurious results.
    */
   enum CmtPrimaryCarrierLowTime : uint8_t {
   };

   /**
    * Secondary Carrier High Time Data Value
    * (cmt_cgh2_sh)
    *
    * Contains the number of input clocks required to generate the carrier high time period.
    * When operating in Time mode, this register is never selected.
    * When operating in FSK mode, this register and the primary register pair are
    * alternately selected under control of the modulator.
    * The secondary carrier high time value is undefined out of reset.
    * This register must be written to nonzero values before the carrier generator
    * is enabled when operating in FSK mode.
    */
   enum CmtSecondaryCarrierHighTime : uint8_t {
   };

   /**
    * Secondary Carrier Low Time Data Value
    * (cmt_cgl2_sl)
    *
    * Contains the number of input clocks required to generate the carrier low time period.
    * When operating in Time mode, this register is never selected.
    * When operating in FSK mode, this register and the primary register pair are
    * alternately selected under the control of the modulator.
    * The secondary carrier low time value is undefined out of reset.
    * This register must be written to nonzero values before the carrier generator
    * is enabled when operating in FSK mode.
    */
   enum CmtSecondaryCarrierLowTime : uint8_t {
   };

   /**
    * Mark period value
    * (cmt_mark)
    *
    * Controls the mark period of the modulator for all modes
    */
   enum CmtMarkPeriod : uint16_t {
   };

   /**
    * Space period value
    * (cmt_space)
    *
    * Controls the space periods of the modulator for all modes
    */
   enum CmtSpacePeriod : uint16_t {
   };

class CmtBasicInfo {

public:
   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = true;
   
   /**
    * Type definition for Cmt interrupt call back.
    */
   typedef void (*CallbackFunction)();
   
   // Pointer to CMT hardware instance
   volatile CMT_Type * const cmt;
   
   /**
    * Constructor
    *
    * @param cmt CMT hardware instance
    */
   constexpr CmtBasicInfo(volatile CMT_Type * cmt) : cmt(cmt) {
   }
   
   /**
    * Get input clock frequency
    * (Shared by all peripherals)
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static inline uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }
   
   /**
    * Calculate Primary Prescaler Divider
    *
    * @param cmtClockPrescaler Divides the CMT clock to generate the Intermediate Frequency clock
    *        to the secondary prescaler.
    *        This should be chosen to produce a nominal 8MHz frequency from the CMT intermediate frequency.
    */
   static CmtClockPrescaler calculateClockPrescaler(CmtClockPrescaler cmtClockPrescaler = CmtClockPrescaler_Auto) {
   
      if (cmtClockPrescaler == CmtClockPrescaler_Auto) {
         // Calculate a prescaler for a 8MHz clock based on clock available
         cmtClockPrescaler = CmtClockPrescaler(((getInputClockFrequency()+4000000)/8000000)-1);
      }
      // Return divider specified
      return cmtClockPrescaler;
   }
   
   /**
    * Set IRO Latch Control
    * (cmt_oc_irol)
    *
    * @param cmtOutputLevel On reads provides the state of the IRO latch.
    *        The value written controls the state of the IRO signal when mode[MSC_MODE]
    *        is direct and output[OC_OUTPUT] is not disabled
    */
   void setOutputState(CmtOutputLevel cmtOutputLevel) const {
      cmt->OC = (cmt->OC&~CMT_OC_IROL_MASK) | cmtOutputLevel;
   }
   
   /**
    * Get IRO Latch Control
    * (cmt_oc_irol)
    *
    * @return On reads provides the state of the IRO latch.
    *        The value written controls the state of the IRO signal when mode[MSC_MODE]
    *        is direct and output[OC_OUTPUT] is not disabled
    */
   CmtOutputLevel getOutputState() const {
      return CmtOutputLevel(cmt->OC&CMT_OC_IROL_MASK);
   }
   
   /**
    * Set Mode of operation
    * (cmt_msc_mode)
    *
    * @param cmtMode Selects between Time, Baseband, FSK and direct modes
    */
   void setMode(CmtMode cmtMode) const {
      cmt->MSC = (cmt->MSC&~(CMT_MSC_MCGEN_MASK|CMT_MSC_BASE_MASK|CMT_MSC_FSK_MASK)) | cmtMode;
   }
   
   /**
    * Get Mode of operation
    * (cmt_msc_mode)
    *
    * @return Selects between Time, Baseband, FSK and direct modes
    */
   CmtMode getMode() const {
      return CmtMode(cmt->MSC&(CMT_MSC_MCGEN_MASK|CMT_MSC_BASE_MASK|CMT_MSC_FSK_MASK));
   }
   
   /**
    * Get End Of Cycle Status Flag
    * (cmt_msc_eocf)
    *
    * @return Sets when:
    *        - The modulator is not currently active and MCGEN is set
    *        - At the end of each modulation cycle while MCGEN is set
    *        Cleared in polling mode by:
    *        - Calling getEndOfCycleFlag() followed by accessing mark or space periods, or
    *        - Calling clearEndOfCycleFlag()
    *        Cleared in DMA mode by:
    *        - A DMA cycle
    */
   CmtStatus getEndOfCycleFlag() const {
      return CmtStatus(cmt->MSC&CMT_MSC_EOCF_MASK);
   }
   
   /**
    * Set Intermediate frequency Prescaler
    * (cmt_msc_cmtdiv)
    *
    * @param cmtIntermediatePrescaler Causes the CMT to be clocked at the Intermediate frequency divided by 1, 2, 4, or 8
    */
   void setPrescaler(CmtIntermediatePrescaler cmtIntermediatePrescaler) const {
      cmt->MSC = (cmt->MSC&~CMT_MSC_CMTDIV_MASK) | cmtIntermediatePrescaler;
   }
   
   /**
    * Get Intermediate frequency Prescaler
    * (cmt_msc_cmtdiv)
    *
    * @return Causes the CMT to be clocked at the Intermediate frequency divided by 1, 2, 4, or 8
    */
   CmtIntermediatePrescaler getPrescaler() const {
      return CmtIntermediatePrescaler(cmt->MSC&CMT_MSC_CMTDIV_MASK);
   }
   
   /**
    * Set Extended Space Enable
    * (cmt_msc_exspc)
    *
    * @param cmtExtendedSpace In either Time, Baseband, or FSK mode, allows the space period                         
    *        to be made longer than the maximum possible value of the space period register.        
    *        Setting MSC[EXSPC] will force the modulator to treat the next modulation period,       
    *        beginning with the next load of the counter and space period registers, as a space     
    *        period equal in length to the mark and space counts combined.                          
    *        Subsequent modulation periods will consist entirely of these extended space periods    
    *        with no mark periods.                                                                  
    *        Clearing MSC[EXSPC] will return the modulator to standard operation at the beginning   
    *        of the next modulation period.
    */
   void setExtendedSpace(CmtExtendedSpace cmtExtendedSpace) const {
      cmt->MSC = (cmt->MSC&~CMT_MSC_EXSPC_MASK) | cmtExtendedSpace;
   }
   
   /**
    * Get Extended Space Enable
    * (cmt_msc_exspc)
    *
    * @return In either Time, Baseband, or FSK mode, allows the space period                         
    *        to be made longer than the maximum possible value of the space period register.        
    *        Setting MSC[EXSPC] will force the modulator to treat the next modulation period,       
    *        beginning with the next load of the counter and space period registers, as a space     
    *        period equal in length to the mark and space counts combined.                          
    *        Subsequent modulation periods will consist entirely of these extended space periods    
    *        with no mark periods.                                                                  
    *        Clearing MSC[EXSPC] will return the modulator to standard operation at the beginning   
    *        of the next modulation period.
    */
   CmtExtendedSpace getExtendedSpace() const {
      return CmtExtendedSpace(cmt->MSC&CMT_MSC_EXSPC_MASK);
   }
   
   /**
    * Set Output Control
    * (cmt_oc_output)
    *
    * @param cmtOutput Enables and controls the polarity of the IRO signal.
    *        When enabled, the the IRO signal is an output that drives out either
    *        the CMT transmitter output or the state of IROL depending on whether
    *        MSC[MCGEN] is set or not
    */
   void setOutputControl(CmtOutput cmtOutput) const {
      cmt->OC = (cmt->OC&~(CMT_OC_IROPEN_MASK|CMT_OC_CMTPOL_MASK)) | cmtOutput;
   }
   
   /**
    * Set Modulator and Carrier Enable
    * (cmt_msc_mcgen)
    *
    * Setting MCGEN will initialise the carrier generator and modulator
    * Clearing MCGEN will disable operation of the CMT
    */
   void start() const {
      // Set field
      cmt->MSC = cmt->MSC|CMT_MSC_MCGEN_MASK;
   }
   
   /**
    * Clear Modulator and Carrier Enable
    * (cmt_msc_mcgen)
    *
    * Setting MCGEN will initialise the carrier generator and modulator
    * Clearing MCGEN will disable operation of the CMT
    */
   void stop() const {
      // Clear field
      cmt->MSC = cmt->MSC&~CMT_MSC_MCGEN_MASK;
   }
   
   /**
    * Clear End Of Cycle Status Flag
    * (cmt_msc_eocf,cmt_cmd2_mb)
    *
    * Sets when:
    * - The modulator is not currently active and MCGEN is set
    * - At the end of each modulation cycle while MCGEN is set
    * Cleared in polling mode by:
    * - Calling getEndOfCycleFlag() followed by accessing mark or space periods, or
    * - Calling clearEndOfCycleFlag()
    * Cleared in DMA mode by:
    * - A DMA cycle
    */
   void clearEndOfCycleFlag() const {
      // Read fields in order to clear flag
      (void)cmt->MSC;
      (void)cmt->CMD2;
   }
   
   /**
    * Get Modulator and Carrier Enable
    * (cmt_msc_mcgen)
    *
    * @return Setting MCGEN will initialise the carrier generator and modulator
    * Clearing MCGEN will disable operation of the CMT
    */
   bool isEnabled() const {
      return bool(cmt->MSC&CMT_MSC_MCGEN_MASK);
   }
   
   /**
    * Set End of Cycle Event handling
    *
    * @param cmtEndOfCycleAction Enables Interrupt or DMA request on end of cycle (when EOCIE set)
    */
   void setEndOfCycleAction(CmtEndOfCycleAction cmtEndOfCycleAction) const {
   
      cmt->MSC = (cmt->MSC&~CMT_MSC_EOCIE_MASK)|(CMT_MSC_EOCIE_MASK&cmtEndOfCycleAction);
      cmt->DMA = (cmt->DMA&~CMT_DMA_DMA_MASK)  |(CMT_DMA_DMA_MASK&cmtEndOfCycleAction);
   }
   
   /**
    * Get End of Cycle Event handling
    *
    * @return Enables Interrupt or DMA request on end of cycle (when EOCIE set)
    */
   CmtEndOfCycleAction getEndOfCycleAction() const {
      return CmtEndOfCycleAction((cmt->MSC&~CMT_MSC_EOCIE_MASK)|(cmt->DMA&~CMT_DMA_DMA_MASK));
   }
   
   /**
    * Set Primary Prescaler Divider
    *
    * @param cmtClockPrescaler Divides the CMT clock to generate the Intermediate Frequency clock
    *        to the secondary prescaler.
    *        This should be chosen to produce a nominal 8MHz frequency from the CMT intermediate frequency.
    */
   void setClockDivider(CmtClockPrescaler cmtClockPrescaler) const {
   
      cmtClockPrescaler = calculateClockPrescaler(cmtClockPrescaler);
      cmt->PPS = (cmt->PPS&~CMT_PPS_PPSDIV_MASK) | cmtClockPrescaler;
   }
   
   /**
    * Get Primary Prescaler Divider
    *
    * @return Divides the CMT clock to generate the Intermediate Frequency clock
    *        to the secondary prescaler.
    *        This should be chosen to produce a nominal 8MHz frequency from the CMT intermediate frequency.
    */
   CmtClockPrescaler getClockDivider() const {
      return CmtClockPrescaler(cmt->PPS&CMT_PPS_PPSDIV_MASK);
   }
   
   /**
    * Set Mark period value
    *
    * @param cmtMarkPeriod Controls the mark period of the modulator for all modes
    */
   void setMarkPeriod(Ticks         cmtMarkPeriod) const {
      cmt->CMD1    = uint8_t(cmtMarkPeriod>>8);
      cmt->CMD2    = uint8_t(cmtMarkPeriod);
   }
   
   /**
    * Get Mark period value
    *
    * @return Controls the mark period of the modulator for all modes
    */
   Ticks getMarkPeriod() const {
      return Ticks((cmt->CMD1<<8)+cmt->CMD2);
   }
   
   /**
    * Set Space period value
    *
    * @param cmtSpacePeriod Controls the space periods of the modulator for all modes
    */
   void setSpacePeriod(Ticks          cmtSpacePeriod) const {
      cmt->CMD3    = uint8_t(cmtSpacePeriod>>8);
      cmt->CMD4    = uint8_t(cmtSpacePeriod);
   }
   
   /**
    * Get Space period value
    *
    * @return Controls the space periods of the modulator for all modes
    */
   Ticks getSpacePeriod() const {
      return Ticks((cmt->CMD3<<8)+cmt->CMD4);
   }
   
   /**
    * Set Mark period value and Space period value
    *
    * @param cmtMarkPeriod  Controls the mark period of the modulator for all modes
    * @param cmtSpacePeriod Controls the space periods of the modulator for all modes
    */
   void setMarkSpacePeriods(
         Ticks          cmtMarkPeriod,
         Ticks          cmtSpacePeriod) const {
      cmt->CMD1    = uint8_t(cmtMarkPeriod>>8);
      cmt->CMD2    = uint8_t(cmtMarkPeriod);
      cmt->CMD3    = uint8_t(cmtSpacePeriod>>8);
      cmt->CMD4    = uint8_t(cmtSpacePeriod);
   }
   
   /**
    * Set Primary Carrier High Time Data Value and Primary Carrier Low Time Data Value
    *
    * @param cmtPrimaryCarrierHighTime Contains the number of input clocks required to generate the carrier high time period.
    *        When operating in Time mode, this register is always selected.
    *        When operating in FSK mode, this register and the secondary register pair are
    *        alternately selected under the control of the modulator.
    *        The primary carrier high time value is undefined out of reset.
    *        This register must be written to nonzero values before the carrier 
    *        generator is enabled to avoid spurious results.
    * @param cmtPrimaryCarrierLowTime  Contains the number of input clocks required to generate the carrier low time period.
    *        When operating in Time mode, this register is always selected.
    *        When operating in FSK mode, this register and the secondary register pair are
    *        alternately selected under the control of the modulator.
    *        The primary carrier low time value is undefined out of reset.
    *        This register must be written to nonzero values before the carrier generator
    *        is enabled to avoid spurious results.
    */
   void setPrimaryTiming(
         Ticks                     cmtPrimaryCarrierHighTime,
         Ticks                     cmtPrimaryCarrierLowTime) const {
      cmt->CGH1 = cmtPrimaryCarrierHighTime;
      cmt->CGL1 = cmtPrimaryCarrierLowTime;
   }
   
   /**
    * Set Secondary Carrier High Time Data Value and Secondary Carrier Low Time Data Value
    *
    * @param cmtSecondaryCarrierHighTime Contains the number of input clocks required to generate the carrier high time period.
    *        When operating in Time mode, this register is never selected.
    *        When operating in FSK mode, this register and the primary register pair are
    *        alternately selected under control of the modulator.
    *        The secondary carrier high time value is undefined out of reset.
    *        This register must be written to nonzero values before the carrier generator
    *        is enabled when operating in FSK mode.
    * @param cmtSecondaryCarrierLowTime  Contains the number of input clocks required to generate the carrier low time period.
    *        When operating in Time mode, this register is never selected.
    *        When operating in FSK mode, this register and the primary register pair are
    *        alternately selected under the control of the modulator.
    *        The secondary carrier low time value is undefined out of reset.
    *        This register must be written to nonzero values before the carrier generator
    *        is enabled when operating in FSK mode.
    */
   void setSecondaryTiming(
         Ticks                       cmtSecondaryCarrierHighTime,
         Ticks                       cmtSecondaryCarrierLowTime) const {
      cmt->CGH2 = cmtSecondaryCarrierHighTime;
      cmt->CGL2 = cmtSecondaryCarrierLowTime;
   }
   
   /**
    * Class used to do initialisation of the Cmt
    *
    * This class has a templated constructor that accepts various values.
    * Parameters available may vary with device - see Cmt::DefaultInitValue for relevant example.
    * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Cmt::Init cmtInit {
    *
    *   // Setup values
    *
    *   CmtMode_Time ,                         // (cmt_msc_mode)             Mode of operation - Time
    *   CmtClockPrescaler_BusClockDivBy6 ,     // (cmt_pps_ppsdiv)           Primary Prescaler Divider - Bus clock / 6
    *   CmtIntermediatePrescaler_DivBy2 ,      // (cmt_msc_cmtdiv)           Intermediate frequency Prescaler - Intermediate frequency /2
    *   CmtOutput_ActiveHigh ,                 // (cmt_oc_output)            Output Control - Active-high
    *   CmtEndOfCycleAction_None ,             // (cmt_dma_irq)              End of Cycle Event handling - No Action
    *   CmtPrimaryCarrierHighTime(100) ,       // (cmt_cgh1_ph)              Primary Carrier High Time Data Value
    *   CmtPrimaryCarrierLowTime(200) ,        // (cmt_cgl1_pl)              Primary Carrier Low Time Data Value
    *   CmtSecondaryCarrierHighTime(100) ,     // (cmt_cgh2_sh)              Secondary Carrier High Time Data Value
    *   CmtSecondaryCarrierLowTime(200) ,      // (cmt_cgl2_sl)              Secondary Carrier Low Time Data Value
    *   CmtMarkPeriod(50) ,                    // (cmt_mark)                 Mark period
    *   CmtSpacePeriod(75),                    // (cmt_space)                Space period
    *
    *   // Optional base value to start with (must be last parameter)
    *   Cmt::DefaultInitValue   // Used as base value modified by above
    * };
    *
    * // Initialise Cmt from values specified above
    * Cmt::configure(cmtInit)
    * @endcode
    */
   class Init {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr Init(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      // Primary Carrier High Time Data Value (cmt_cgh1_ph)
      uint8_t cgh1 = 0;

      // Primary Carrier Low Time Data Value (cmt_cgl1_pl)
      uint8_t cgl1 = 0;

      // Secondary Carrier High Time Data Value (cmt_cgh2_sh)
      uint8_t cgh2 = 0;

      // Secondary Carrier Low Time Data Value (cmt_cgl2_sl)
      uint8_t cgl2 = 0;

      // IRO Latch Control (cmt_oc_irol)
      uint8_t oc = 0;

      // Intermediate frequency Prescaler (cmt_msc_cmtdiv)
      // Extended Space Enable (cmt_msc_exspc)
      // End of Cycle Event handling (cmt_dma_irq)
      // Mode of operation (cmt_msc_mode)
      uint8_t msc = 0;

      // DMA Transfer Enable (cmt_dma_dma)
      uint8_t dma = 0;

      // Primary Prescaler Divider (cmt_pps_ppsdiv)
      CmtClockPrescaler pps = CmtClockPrescaler(0);

      // Mark period value (cmt_mark)
      uint16_t mark = 0;

      // Space period value (cmt_space)
      uint16_t space = 0;

      /**
       * Constructor for Output Control
       * (cmt_oc_output)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtOutput Enables and controls the polarity of the IRO signal.
       *        When enabled, the the IRO signal is an output that drives out either
       *        the CMT transmitter output or the state of IROL depending on whether
       *        MSC[MCGEN] is set or not
       */
      template <typename... Types>
      constexpr Init(CmtOutput cmtOutput, Types... rest) : Init(rest...) {
   
         oc = (oc&~(CMT_OC_IROPEN_MASK|CMT_OC_CMTPOL_MASK)) | cmtOutput;
      }
   
      /**
       * Constructor for IRO Latch Control
       * (cmt_oc_irol)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtOutputLevel On reads provides the state of the IRO latch.
       *        The value written controls the state of the IRO signal when mode[MSC_MODE]
       *        is direct and output[OC_OUTPUT] is not disabled
       */
      template <typename... Types>
      constexpr Init(CmtOutputLevel cmtOutputLevel, Types... rest) : Init(rest...) {
   
         oc = (oc&~CMT_OC_IROL_MASK) | cmtOutputLevel;
      }
   
      /**
       * Constructor for Intermediate frequency Prescaler
       * (cmt_msc_cmtdiv)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtIntermediatePrescaler Causes the CMT to be clocked at the Intermediate frequency divided by 1, 2, 4, or 8
       */
      template <typename... Types>
      constexpr Init(CmtIntermediatePrescaler cmtIntermediatePrescaler, Types... rest) : Init(rest...) {
   
         msc = (msc&~CMT_MSC_CMTDIV_MASK) | cmtIntermediatePrescaler;
      }
   
      /**
       * Constructor for Mode of operation
       * (cmt_msc_mode)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtMode Selects between Time, Baseband, FSK and direct modes
       */
      template <typename... Types>
      constexpr Init(CmtMode cmtMode, Types... rest) : Init(rest...) {
   
         msc = (msc&~(CMT_MSC_MCGEN_MASK|CMT_MSC_BASE_MASK|CMT_MSC_FSK_MASK)) | cmtMode;
      }
   
      /**
       * Constructor for Mark period value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtMarkPeriod Controls the mark period of the modulator for all modes
       */
      template <typename... Types>
      constexpr Init(CmtMarkPeriod cmtMarkPeriod, Types... rest) : Init(rest...) {
   
         mark = cmtMarkPeriod;
      }
   
      /**
       * Constructor for Space period value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtSpacePeriod Controls the space periods of the modulator for all modes
       */
      template <typename... Types>
      constexpr Init(CmtSpacePeriod cmtSpacePeriod, Types... rest) : Init(rest...) {
   
         space = cmtSpacePeriod;
      }
   
      /**
       * Constructor for Primary Carrier High Time Data Value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtPrimaryCarrierHighTime Contains the number of input clocks required to generate the carrier high time period.
       *        When operating in Time mode, this register is always selected.
       *        When operating in FSK mode, this register and the secondary register pair are
       *        alternately selected under the control of the modulator.
       *        The primary carrier high time value is undefined out of reset.
       *        This register must be written to nonzero values before the carrier 
       *        generator is enabled to avoid spurious results.
       */
      template <typename... Types>
      constexpr Init(CmtPrimaryCarrierHighTime cmtPrimaryCarrierHighTime, Types... rest) : Init(rest...) {
   
         cgh1 = CMT_CGH1_PH(cmtPrimaryCarrierHighTime);
      }
   
      /**
       * Constructor for Primary Carrier Low Time Data Value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtPrimaryCarrierLowTime Contains the number of input clocks required to generate the carrier low time period.
       *        When operating in Time mode, this register is always selected.
       *        When operating in FSK mode, this register and the secondary register pair are
       *        alternately selected under the control of the modulator.
       *        The primary carrier low time value is undefined out of reset.
       *        This register must be written to nonzero values before the carrier generator
       *        is enabled to avoid spurious results.
       */
      template <typename... Types>
      constexpr Init(CmtPrimaryCarrierLowTime cmtPrimaryCarrierLowTime, Types... rest) : Init(rest...) {
   
         cgl1 = CMT_CGL1_PL(cmtPrimaryCarrierLowTime);
      }
   
      /**
       * Constructor for Secondary Carrier High Time Data Value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtSecondaryCarrierHighTime Contains the number of input clocks required to generate the carrier high time period.
       *        When operating in Time mode, this register is never selected.
       *        When operating in FSK mode, this register and the primary register pair are
       *        alternately selected under control of the modulator.
       *        The secondary carrier high time value is undefined out of reset.
       *        This register must be written to nonzero values before the carrier generator
       *        is enabled when operating in FSK mode.
       */
      template <typename... Types>
      constexpr Init(CmtSecondaryCarrierHighTime cmtSecondaryCarrierHighTime, Types... rest) : Init(rest...) {
   
         cgh2 = CMT_CGH2_SH(cmtSecondaryCarrierHighTime);
      }
   
      /**
       * Constructor for Secondary Carrier Low Time Data Value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtSecondaryCarrierLowTime Contains the number of input clocks required to generate the carrier low time period.
       *        When operating in Time mode, this register is never selected.
       *        When operating in FSK mode, this register and the primary register pair are
       *        alternately selected under the control of the modulator.
       *        The secondary carrier low time value is undefined out of reset.
       *        This register must be written to nonzero values before the carrier generator
       *        is enabled when operating in FSK mode.
       */
      template <typename... Types>
      constexpr Init(CmtSecondaryCarrierLowTime cmtSecondaryCarrierLowTime, Types... rest) : Init(rest...) {
   
         cgl2 = CMT_CGL2_SL(cmtSecondaryCarrierLowTime);
      }
   
      /**
       * Constructor for Primary Prescaler Divider
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtClockPrescaler Divides the CMT clock to generate the Intermediate Frequency clock
       *        to the secondary prescaler.
       *        This should be chosen to produce a nominal 8MHz frequency from the CMT intermediate frequency.
       */
      template <typename... Types>
      constexpr Init(CmtClockPrescaler cmtClockPrescaler, Types... rest) : Init(rest...) {
   
         pps = cmtClockPrescaler;
      }
   
      /**
       * Constructor for End of Cycle Event handling
       *
       * @tparam   Types
       * @param    rest
       *
       * @param cmtEndOfCycleAction Enables Interrupt or DMA request on end of cycle (when EOCIE set)
       */
      template <typename... Types>
      constexpr Init(CmtEndOfCycleAction cmtEndOfCycleAction, Types... rest) : Init(rest...) {
   
         // Parameter contains non-overlapping bit fields from two registers
         dma = (dma & ~CMT_DMA_DMA_MASK)   | (CMT_DMA_DMA_MASK & cmtEndOfCycleAction);
         msc = (msc & ~CMT_MSC_EOCIE_MASK) | (CMT_MSC_EOCIE_MASK & cmtEndOfCycleAction);
      }
   
   }; // class CmtBasicInfo::Init
   
   /**
    * Configure CMT from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param cmt             Hardware instance pointer
    * @param init            Class containing initialisation values
    */
   static void configure(
                  volatile CMT_Type *cmt,
                  const Init    &init) {
   
   
      // Mode of operation (cmt_msc_mode)
      cmt->MSC = 0;
   
      // Primary Carrier High Time Data Value (cmt_cgh1_ph)
      cmt->CGH1 = init.cgh1;
   
      // Primary Carrier Low Time Data Value (cmt_cgl1_pl)
      cmt->CGL1 = init.cgl1;
   
      // Secondary Carrier High Time Data Value (cmt_cgh2_sh)
      cmt->CGH2 = init.cgh2;
   
      // Secondary Carrier Low Time Data Value (cmt_cgl2_sl)
      cmt->CGL2 = init.cgl2;
   
      // IRO Latch Control (cmt_oc_irol)
      cmt->OC = init.oc;
   
      // DMA Transfer Enable (cmt_dma_dma)
      cmt->DMA = init.dma;
   
      // Mark period value (cmt_mark)
      cmt->CMD1    = uint8_t(init.mark>>8);
   
      // Mark period value (cmt_mark)
      cmt->CMD2    = uint8_t(init.mark);
   
      // Space period value (cmt_space)
      cmt->CMD3    = uint8_t(init.space>>8);
   
      // Space period value (cmt_space)
      cmt->CMD4    = uint8_t(init.space);
   
      // Primary Prescaler Divider (cmt_pps_ppsdiv)
      cmt->PPS    = calculateClockPrescaler(init.pps);
   
      // Intermediate frequency Prescaler (cmt_msc_cmtdiv)
      // Extended Space Enable (cmt_msc_exspc)
      // End of Cycle Interrupt Enable (cmt_msc_eocie)
      // Mode of operation (cmt_msc_mode)
      cmt->MSC = init.msc;
   }
   
   /**
    * Configure CMT from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param init Class containing initialisation values
    */
   void configure(const Init &init) const {
   
      configure(cmt, init);
   }
   
}; // class CmtBasicInfo 

class CmtInfo : public CmtBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: CMT_IRO              = PTD7(p48)                      */  { PinIndex::PTD7,         PcrValue(0x00200UL) },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTD_CLOCK_MASK);
      PORTD->GPCLR = (0x0200UL|PORT_GPCLR_GPWE(0x0080UL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTD_CLOCK_MASK);
      PORTD->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0080UL);
   }

   /*
    * Template:cmt_0
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with CMT
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with CMT
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = true;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = CMT_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   template<typename T>
   using CallbackWrapper = USBDM::CallbackWrapper<T, CmtInfo>;
   
   /**
    * Function to wrap a member function as a static callback function
    * Example:
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callbackFuction() {
    *       ...;
    *    }
    * };
    * ...
    *    AClass *tester = new AClass{};
    *
    *    auto cb = Cmt::wrapCallback(tester, &AClass::callbackFuction);
    *    Cmt::setCallback(cb);
    *   @endcode
    *
    * @tparam T               Type of class containing callback (inferred)
    *
    * @param classInstance    Pointer to instance of class
    * @param memberFunction   Pointer to the member function
    *
    * @return  Wrapper
    */
   template<typename T>
   static auto wrapCallback(T *classInstance, void (T::*memberFunction)()) {
      static CallbackWrapper<T> sClass(classInstance, memberFunction);
      return sClass.callback;
   }
   
   /**
    * CMT interrupt handler -  Calls CMT callback
    */
   static void irqHandler() {
   
      // Execute call-back
      sCallback();
   }
   
   /** Callback function for Cmt */
   static inline CallbackFunction sCallback = unhandledCallback; // CMT_IRQn;
   
   /**
    * Set interrupt callback function.
    *
    * @param  cmtCallback Callback function to execute on interrupt
    *                             Use nullptr to remove callback.
    */
   static void setCallback(CallbackFunction cmtCallback) {
      if (cmtCallback == nullptr) {
         cmtCallback = unhandledCallback;
      }
      // Allow either no handler set yet, setting same handler or removing handler
      usbdm_assert(
            (sCallback == unhandledCallback) ||
            (sCallback == cmtCallback) ||
            (cmtCallback == unhandledCallback),
            "Handler already set");
      sCallback = cmtCallback;
   }
   
   /**
    *  Enable clock to Cmt
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_CMT_MASK;
   }
   
   /**
    *  Disable clock to Cmt
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_CMT_MASK;
   }
   
   /**
    * Basic enable of Cmt
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      enableClock();
      configureAllPins();
   }
   
   /**
    * Disables Cmt
    */
   static void disable() {
   
      
      disableNvicInterrupts();
      disableAllPins();
      disableClock();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = CMT_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<CMT_Type> cmt = baseAddress;
   
   /**
    * Information describing the priority and callback function for each interrupt
    */
   typedef InitVectors<Init, CallbackFunction, int, 1> Init;
   
   /**
    * Set IRO Latch Control
    * (cmt_oc_irol)
    *
    * @param cmtOutputLevel On reads provides the state of the IRO latch.
    *        The value written controls the state of the IRO signal when mode[MSC_MODE]
    *        is direct and output[OC_OUTPUT] is not disabled
    */
   static void setOutputState(CmtOutputLevel cmtOutputLevel) {
      cmt->OC = (cmt->OC&~CMT_OC_IROL_MASK) | cmtOutputLevel;
   }
   
   /**
    * Get IRO Latch Control
    * (cmt_oc_irol)
    *
    * @return On reads provides the state of the IRO latch.
    *        The value written controls the state of the IRO signal when mode[MSC_MODE]
    *        is direct and output[OC_OUTPUT] is not disabled
    */
   static CmtOutputLevel getOutputState() {
      return CmtOutputLevel(cmt->OC&CMT_OC_IROL_MASK);
   }
   
   /**
    * Set Mode of operation
    * (cmt_msc_mode)
    *
    * @param cmtMode Selects between Time, Baseband, FSK and direct modes
    */
   static void setMode(CmtMode cmtMode) {
      cmt->MSC = (cmt->MSC&~(CMT_MSC_MCGEN_MASK|CMT_MSC_BASE_MASK|CMT_MSC_FSK_MASK)) | cmtMode;
   }
   
   /**
    * Get Mode of operation
    * (cmt_msc_mode)
    *
    * @return Selects between Time, Baseband, FSK and direct modes
    */
   static CmtMode getMode() {
      return CmtMode(cmt->MSC&(CMT_MSC_MCGEN_MASK|CMT_MSC_BASE_MASK|CMT_MSC_FSK_MASK));
   }
   
   /**
    * Get End Of Cycle Status Flag
    * (cmt_msc_eocf)
    *
    * @return Sets when:
    *        - The modulator is not currently active and MCGEN is set
    *        - At the end of each modulation cycle while MCGEN is set
    *        Cleared in polling mode by:
    *        - Calling getEndOfCycleFlag() followed by accessing mark or space periods, or
    *        - Calling clearEndOfCycleFlag()
    *        Cleared in DMA mode by:
    *        - A DMA cycle
    */
   static CmtStatus getEndOfCycleFlag() {
      return CmtStatus(cmt->MSC&CMT_MSC_EOCF_MASK);
   }
   
   /**
    * Set Intermediate frequency Prescaler
    * (cmt_msc_cmtdiv)
    *
    * @param cmtIntermediatePrescaler Causes the CMT to be clocked at the Intermediate frequency divided by 1, 2, 4, or 8
    */
   static void setPrescaler(CmtIntermediatePrescaler cmtIntermediatePrescaler) {
      cmt->MSC = (cmt->MSC&~CMT_MSC_CMTDIV_MASK) | cmtIntermediatePrescaler;
   }
   
   /**
    * Get Intermediate frequency Prescaler
    * (cmt_msc_cmtdiv)
    *
    * @return Causes the CMT to be clocked at the Intermediate frequency divided by 1, 2, 4, or 8
    */
   static CmtIntermediatePrescaler getPrescaler() {
      return CmtIntermediatePrescaler(cmt->MSC&CMT_MSC_CMTDIV_MASK);
   }
   
   /**
    * Set Extended Space Enable
    * (cmt_msc_exspc)
    *
    * @param cmtExtendedSpace In either Time, Baseband, or FSK mode, allows the space period                         
    *        to be made longer than the maximum possible value of the space period register.        
    *        Setting MSC[EXSPC] will force the modulator to treat the next modulation period,       
    *        beginning with the next load of the counter and space period registers, as a space     
    *        period equal in length to the mark and space counts combined.                          
    *        Subsequent modulation periods will consist entirely of these extended space periods    
    *        with no mark periods.                                                                  
    *        Clearing MSC[EXSPC] will return the modulator to standard operation at the beginning   
    *        of the next modulation period.
    */
   static void setExtendedSpace(CmtExtendedSpace cmtExtendedSpace) {
      cmt->MSC = (cmt->MSC&~CMT_MSC_EXSPC_MASK) | cmtExtendedSpace;
   }
   
   /**
    * Get Extended Space Enable
    * (cmt_msc_exspc)
    *
    * @return In either Time, Baseband, or FSK mode, allows the space period                         
    *        to be made longer than the maximum possible value of the space period register.        
    *        Setting MSC[EXSPC] will force the modulator to treat the next modulation period,       
    *        beginning with the next load of the counter and space period registers, as a space     
    *        period equal in length to the mark and space counts combined.                          
    *        Subsequent modulation periods will consist entirely of these extended space periods    
    *        with no mark periods.                                                                  
    *        Clearing MSC[EXSPC] will return the modulator to standard operation at the beginning   
    *        of the next modulation period.
    */
   static CmtExtendedSpace getExtendedSpace() {
      return CmtExtendedSpace(cmt->MSC&CMT_MSC_EXSPC_MASK);
   }
   
   /**
    * Set Output Control
    * (cmt_oc_output)
    *
    * @param cmtOutput Enables and controls the polarity of the IRO signal.
    *        When enabled, the the IRO signal is an output that drives out either
    *        the CMT transmitter output or the state of IROL depending on whether
    *        MSC[MCGEN] is set or not
    */
   static void setOutputControl(CmtOutput cmtOutput) {
      cmt->OC = (cmt->OC&~(CMT_OC_IROPEN_MASK|CMT_OC_CMTPOL_MASK)) | cmtOutput;
   }
   
   /**
    * Set Modulator and Carrier Enable
    * (cmt_msc_mcgen)
    *
    * Setting MCGEN will initialise the carrier generator and modulator
    * Clearing MCGEN will disable operation of the CMT
    */
   static void start() {
      // Set field
      cmt->MSC = cmt->MSC|CMT_MSC_MCGEN_MASK;
   }
   
   /**
    * Clear Modulator and Carrier Enable
    * (cmt_msc_mcgen)
    *
    * Setting MCGEN will initialise the carrier generator and modulator
    * Clearing MCGEN will disable operation of the CMT
    */
   static void stop() {
      // Clear field
      cmt->MSC = cmt->MSC&~CMT_MSC_MCGEN_MASK;
   }
   
   /**
    * Clear End Of Cycle Status Flag
    * (cmt_msc_eocf,cmt_cmd2_mb)
    *
    * Sets when:
    * - The modulator is not currently active and MCGEN is set
    * - At the end of each modulation cycle while MCGEN is set
    * Cleared in polling mode by:
    * - Calling getEndOfCycleFlag() followed by accessing mark or space periods, or
    * - Calling clearEndOfCycleFlag()
    * Cleared in DMA mode by:
    * - A DMA cycle
    */
   static void clearEndOfCycleFlag() {
      // Read fields in order to clear flag
      (void)cmt->MSC;
      (void)cmt->CMD2;
   }
   
   /**
    * Get Modulator and Carrier Enable
    * (cmt_msc_mcgen)
    *
    * @return Setting MCGEN will initialise the carrier generator and modulator
    * Clearing MCGEN will disable operation of the CMT
    */
   static bool isEnabled() {
      return bool(cmt->MSC&CMT_MSC_MCGEN_MASK);
   }
   
   /**
    * Set End of Cycle Event handling
    *
    * @param cmtEndOfCycleAction Enables Interrupt or DMA request on end of cycle (when EOCIE set)
    */
   static void setEndOfCycleAction(CmtEndOfCycleAction cmtEndOfCycleAction) {
   
      cmt->MSC = (cmt->MSC&~CMT_MSC_EOCIE_MASK)|(CMT_MSC_EOCIE_MASK&cmtEndOfCycleAction);
      cmt->DMA = (cmt->DMA&~CMT_DMA_DMA_MASK)  |(CMT_DMA_DMA_MASK&cmtEndOfCycleAction);
   }
   
   /**
    * Get End of Cycle Event handling
    *
    * @return Enables Interrupt or DMA request on end of cycle (when EOCIE set)
    */
   static CmtEndOfCycleAction getEndOfCycleAction() {
      return CmtEndOfCycleAction((cmt->MSC&~CMT_MSC_EOCIE_MASK)|(cmt->DMA&~CMT_DMA_DMA_MASK));
   }
   
   /**
    * Set Primary Prescaler Divider
    *
    * @param cmtClockPrescaler Divides the CMT clock to generate the Intermediate Frequency clock
    *        to the secondary prescaler.
    *        This should be chosen to produce a nominal 8MHz frequency from the CMT intermediate frequency.
    */
   static void setClockDivider(CmtClockPrescaler cmtClockPrescaler) {
   
      cmtClockPrescaler = calculateClockPrescaler(cmtClockPrescaler);
      cmt->PPS = (cmt->PPS&~CMT_PPS_PPSDIV_MASK) | cmtClockPrescaler;
   }
   
   /**
    * Get Primary Prescaler Divider
    *
    * @return Divides the CMT clock to generate the Intermediate Frequency clock
    *        to the secondary prescaler.
    *        This should be chosen to produce a nominal 8MHz frequency from the CMT intermediate frequency.
    */
   static CmtClockPrescaler getClockDivider() {
      return CmtClockPrescaler(cmt->PPS&CMT_PPS_PPSDIV_MASK);
   }
   
   /**
    * Set Mark period value
    *
    * @param cmtMarkPeriod Controls the mark period of the modulator for all modes
    */
   static void setMarkPeriod(Ticks         cmtMarkPeriod) {
      cmt->CMD1    = uint8_t(cmtMarkPeriod>>8);
      cmt->CMD2    = uint8_t(cmtMarkPeriod);
   }
   
   /**
    * Get Mark period value
    *
    * @return Controls the mark period of the modulator for all modes
    */
   static Ticks getMarkPeriod() {
      return Ticks((cmt->CMD1<<8)+cmt->CMD2);
   }
   
   /**
    * Set Space period value
    *
    * @param cmtSpacePeriod Controls the space periods of the modulator for all modes
    */
   static void setSpacePeriod(Ticks          cmtSpacePeriod) {
      cmt->CMD3    = uint8_t(cmtSpacePeriod>>8);
      cmt->CMD4    = uint8_t(cmtSpacePeriod);
   }
   
   /**
    * Get Space period value
    *
    * @return Controls the space periods of the modulator for all modes
    */
   static Ticks getSpacePeriod() {
      return Ticks((cmt->CMD3<<8)+cmt->CMD4);
   }
   
   /**
    * Set Mark period value and Space period value
    *
    * @param cmtMarkPeriod  Controls the mark period of the modulator for all modes
    * @param cmtSpacePeriod Controls the space periods of the modulator for all modes
    */
   static void setMarkSpacePeriods(
         Ticks          cmtMarkPeriod,
         Ticks          cmtSpacePeriod) {
      cmt->CMD1    = uint8_t(cmtMarkPeriod>>8);
      cmt->CMD2    = uint8_t(cmtMarkPeriod);
      cmt->CMD3    = uint8_t(cmtSpacePeriod>>8);
      cmt->CMD4    = uint8_t(cmtSpacePeriod);
   }
   
   /**
    * Set Primary Carrier High Time Data Value and Primary Carrier Low Time Data Value
    *
    * @param cmtPrimaryCarrierHighTime Contains the number of input clocks required to generate the carrier high time period.
    *        When operating in Time mode, this register is always selected.
    *        When operating in FSK mode, this register and the secondary register pair are
    *        alternately selected under the control of the modulator.
    *        The primary carrier high time value is undefined out of reset.
    *        This register must be written to nonzero values before the carrier 
    *        generator is enabled to avoid spurious results.
    * @param cmtPrimaryCarrierLowTime  Contains the number of input clocks required to generate the carrier low time period.
    *        When operating in Time mode, this register is always selected.
    *        When operating in FSK mode, this register and the secondary register pair are
    *        alternately selected under the control of the modulator.
    *        The primary carrier low time value is undefined out of reset.
    *        This register must be written to nonzero values before the carrier generator
    *        is enabled to avoid spurious results.
    */
   static void setPrimaryTiming(
         Ticks                     cmtPrimaryCarrierHighTime,
         Ticks                     cmtPrimaryCarrierLowTime) {
      cmt->CGH1 = cmtPrimaryCarrierHighTime;
      cmt->CGL1 = cmtPrimaryCarrierLowTime;
   }
   
   /**
    * Set Secondary Carrier High Time Data Value and Secondary Carrier Low Time Data Value
    *
    * @param cmtSecondaryCarrierHighTime Contains the number of input clocks required to generate the carrier high time period.
    *        When operating in Time mode, this register is never selected.
    *        When operating in FSK mode, this register and the primary register pair are
    *        alternately selected under control of the modulator.
    *        The secondary carrier high time value is undefined out of reset.
    *        This register must be written to nonzero values before the carrier generator
    *        is enabled when operating in FSK mode.
    * @param cmtSecondaryCarrierLowTime  Contains the number of input clocks required to generate the carrier low time period.
    *        When operating in Time mode, this register is never selected.
    *        When operating in FSK mode, this register and the primary register pair are
    *        alternately selected under the control of the modulator.
    *        The secondary carrier low time value is undefined out of reset.
    *        This register must be written to nonzero values before the carrier generator
    *        is enabled when operating in FSK mode.
    */
   static void setSecondaryTiming(
         Ticks                       cmtSecondaryCarrierHighTime,
         Ticks                       cmtSecondaryCarrierLowTime) {
      cmt->CGH2 = cmtSecondaryCarrierHighTime;
      cmt->CGL2 = cmtSecondaryCarrierLowTime;
   }
   
   // Pins associated with peripheral
   typedef GpioTable_T<CmtInfo, 0, ActiveHigh> IroPin;
   
   // PCRs associated with peripheral pins
   typedef PcrTable_T<CmtInfo, 0> OutputPin;
   
   /**
    *   Default Constructor
    */
   CmtInfo() : CmtBasicInfo(cmt) {
      defaultConfigure();
   }
   
   /**
    *   Constructor
    */
   CmtInfo(const Init &init) : CmtBasicInfo(cmt) {
      configure(init);
   }
   
   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   static void defaultConfigure() {
   
      configure(DefaultInitValue);
   }
   
   /**
    * Configure CMT from values specified in init
    *
    * @param init Class containing initialisation values
    */
   static void configure(const Init &init) {
   
      // Enable peripheral
      enable();
   
      // Configure call-back
      if (init.callbacks[0] != nullptr) {
         setCallback(init.callbacks[0]);
         enableNvicInterrupts(init.priorities[0]);
      }
   
      CmtBasicInfo::configure(cmt, init);
   }
   
   /**
    * Default initialisation value for Cmt
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      NvicPriority_Normal ,             // (irqLevel)                 IRQ priority level - Normal
      unhandledCallback,                // (handlerName)              User declared event handler
   
      CmtMode_Direct ,                       // (cmt_msc_mode)             Mode of operation - Direct
      CmtClockPrescaler_BusClockDivBy1 ,     // (cmt_pps_ppsdiv)           Primary Prescaler Divider - Bus clock / 1
      CmtIntermediatePrescaler_DivBy1 ,      // (cmt_msc_cmtdiv)           Intermediate frequency Prescaler - Intermediate frequency /1
      CmtOutput_Disabled ,                   // (cmt_oc_output)            Output Control - Disabled
      CmtEndOfCycleAction_None ,             // (cmt_dma_irq)              End of Cycle Event handling - No Action
      CmtPrimaryCarrierHighTime(0) ,         // (cmt_cgh1_ph)              Primary Carrier High Time Data Value
      CmtPrimaryCarrierLowTime(0) ,          // (cmt_cgl1_pl)              Primary Carrier Low Time Data Value
      CmtSecondaryCarrierHighTime(0) ,       // (cmt_cgh2_sh)              Secondary Carrier High Time Data Value
      CmtSecondaryCarrierLowTime(0) ,        // (cmt_cgl2_sl)              Secondary Carrier Low Time Data Value
      CmtMarkPeriod(0) ,                     // (cmt_mark)                 Mark period value
      CmtSpacePeriod(0),                     // (cmt_space)                Space period value
   };
   
}; // class CmtInfo


   /**
    * Class representing a Carrier Modulator Transmitter.
    *
    * Typical modes of operation:
    * Time mode
    *    Waveform alternates between modulation frequency (mark) and idle (space).
    *    Modulation waveform is controlled by setPrimaryTiming().
    *    Mark/Space time is controlled by setMarkSpacePeriods().
    * Baseband mode
    *    Waveform alternates between high (mark) and idle (space) without use of modulation.
    *    Mark/Space time is controlled by setMarkSpacePeriods().
    * FSK mode
    *    Waveform changes between two modulation frequencies(mark) separated by idle time (space) i.e.
    *    (Primary modulation - idle - Secondary modulation - idle) repeated.
    *    Modulation waveforms are controlled by setPrimaryTiming() and setSecondaryTiming().
    *    Mark/Space time is controlled by setMarkSpacePeriods().
    *    Space time may be set to zero to obtain simple FSK with no idle time.
    */
   typedef CmtInfo Cmt;
   

/**
 * End CMT_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_CMT_H_ */
