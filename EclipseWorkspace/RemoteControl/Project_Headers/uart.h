/**
 * @file     uart.h (180.ARM_Peripherals/Project_Headers/uart-MK.h)
 * @brief    Universal Asynchronous Receiver/Transmitter interface
 */

#ifndef HEADER_UART_H_
#define HEADER_UART_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"
#include "formatted_io.h"
#include "uart_queue.h"

// No handler defined for UART0 Lon
// No handler defined for UART0 RxTx
// No handler defined for UART0 Error
// No handler defined for UART1 RxTx
// No handler defined for UART1 Error
// No handler defined for UART2 RxTx
// No handler defined for UART2 Error


namespace USBDM {

/**
 * @addtogroup UART_Group UART, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Transmitter Enable
    * (uart_c2_te)
    *
    * Enables the UART transmitter.
    */
   enum UartTransmitterEnable : uint8_t {
      UartTransmitterEnable_Disabled   = UART_C2_TE(0),  ///< Transmitter disabled
      UartTransmitterEnable_Enabled    = UART_C2_TE(1),  ///< Transmitter enabled
   };

   /**
    * Receiver Enable
    * (uart_c2_re)
    *
    * Enables the UART receiver.
    */
   enum UartReceiverEnable : uint8_t {
      UartReceiverEnable_Disabled   = UART_C2_RE(0),  ///< Receiver disabled
      UartReceiverEnable_Enabled    = UART_C2_RE(1),  ///< Receiver enabled
   };

   /**
    * Transmit empty DMA/Interrupt action
    * (uart_txempty_action)
    *
    * Enable transmit holding register empty DMA/Interrupt action
    */
   enum UartTxEmptyAction : uint16_t {
      UartTxEmptyAction_None        = (UART_C5_TDMAS(0)<<8)|UART_C2_TIE(0),  ///< None
      UartTxEmptyAction_Interrupt   = (UART_C5_TDMAS(0)<<8)|UART_C2_TIE(1),  ///< Interrupt
      UartTxEmptyAction_Dma         = (UART_C5_TDMAS(1)<<8)|UART_C2_TIE(1),  ///< DMA
   };

   /**
    * Receive full DMA/interrupt action
    * (uart_rxfull_action)
    *
    * Enable receive buffer full DMA/interrupt action
    */
   enum UartRxFullAction : uint16_t {
      UartRxFullAction_None        = (UART_C5_RDMAS(0)<<8)|UART_C2_RIE(0),  ///< None
      UartRxFullAction_Interrupt   = (UART_C5_RDMAS(0)<<8)|UART_C2_RIE(1),  ///< Interrupt
      UartRxFullAction_Dma         = (UART_C5_RDMAS(1)<<8)|UART_C2_RIE(1),  ///< DMA
   };

   /**
    * Baud Rate Modulo Divisor
    * (uart_bdh_sbr)
    *
    * The 13 bits in SBR[12:0] are referred to collectively as BR. They set the modulo divide rate for the
    * UART baud rate generator. When BR is cleared, the UART baud rate generator is disabled to reduce
    * supply current. When BR is 1 - 8191, the UART baud rate equals BUSCLK/(16xBR)
    */
   enum UartBaudRateModuloDivisor : uint8_t {
   };

   /**
    * LIN break detect action
    * (uart_bdh_lbkdie)
    *
    * Enables the LIN break detect flag, LBKDIF, to generate interrupt requests based on the state of LBKDDMAS.
    */
   enum UartLinBreakAction : uint8_t {
      UartLinBreakAction_None        = UART_BDH_LBKDIE(0),  ///< None
      UartLinBreakAction_Interrupt   = UART_BDH_LBKDIE(1),  ///< Interrupt
   };

   /**
    * RxD input active edge action
    * (uart_bdh_rxedgie)
    *
    * Enables the receive input active edge, RXEDGIF, to generate interrupt requests.
    */
   enum UartRxdActiveEdgeAction : uint8_t {
      UartRxdActiveEdgeAction_None        = UART_BDH_RXEDGIE(0),  ///< None
      UartRxdActiveEdgeAction_Interrupt   = UART_BDH_RXEDGIE(1),  ///< Interrupt
   };

   /**
    * Baud Rate Bits
    * (uart_bdl_sbr)
    *
    * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate generation for details.
    */
   enum UartBaudRateBits : uint8_t {
   };

   /**
    * Loop Mode Select
    * (uart_c1_loops)
    *
    * Controls loop mode where transmitter output is internally connected to receiver input. [See also RSRC]
    */
   enum UartLoopModeSelect : uint8_t {
      UartLoopModeSelect_NormalOperation   = UART_C1_LOOPS(0),  ///< Normal operation
      UartLoopModeSelect_LoopMode          = UART_C1_LOOPS(1),  ///< Loop mode
   };

   /**
    * Stops in Wait Mode
    * (uart_c1_uartswai)
    *
    * Controls action in Wait Mode
    */
   enum UartStopsInWaitMode : uint8_t {
      UartStopsInWaitMode_EnableInWaitMode   = UART_C1_UARTSWAI(0),  ///< Enable in Wait mode
      UartStopsInWaitMode_FreezeInWaitMode   = UART_C1_UARTSWAI(1),  ///< Freeze in Wait mode
   };

   /**
    * Receiver Source Select
    * (uart_c1_rsrc)
    *
    * Select between loop-back and single-wire mode
    */
   enum UartReceiverSourceSelect : uint8_t {
      UartReceiverSourceSelect_InternalLoopBackMode   = UART_C1_RSRC(0),  ///< Internal loop back mode
      UartReceiverSourceSelect_SingleWireMode         = UART_C1_RSRC(1),  ///< Single-wire mode
   };

   /**
    * 9-Bit or 8-Bit Mode Select
    * (uart_c1_m)
    *
    * Selects between 8-bit and 9-bit modes
    * This field must be set when C7816[ISO_7816E] is set/enabled.
    */
   enum Uart9BitOr8BitModeSelect : uint8_t {
      Uart9BitOr8BitModeSelect_8Bit   = UART_C1_M(0),  ///< 8-bit
      Uart9BitOr8BitModeSelect_9Bit   = UART_C1_M(1),  ///< 9-bit
   };

   /**
    * Receiver Wakeup Method Select
    * (uart_c1_wake)
    *
    * Determines which condition wakes the UART:
    * - Address mark in the most significant bit position of a received data character, or
    * - An idle condition on the receive pin input signal.
    */
   enum UartReceiverWakeupMethodSelect : uint8_t {
      UartReceiverWakeupMethodSelect_IdleLineWakeup      = UART_C1_WAKE(0),  ///< Idle-line wakeup
      UartReceiverWakeupMethodSelect_AddressMarkWakeup   = UART_C1_WAKE(1),  ///< Address-mark wakeup
   };

   /**
    * Idle Line Type Select
    * (uart_c1_ilt)
    *
    * Determines if idle character bit count starts after start bit or stop bit
    */
   enum UartIdleLineTypeSelect : uint8_t {
      UartIdleLineTypeSelect_AfterStartBit   = UART_C1_ILT(0),  ///< After start bit
      UartIdleLineTypeSelect_AfterStopBit    = UART_C1_ILT(1),  ///< After stop bit
   };

   /**
    * Parity Enable
    * (uart_c1_pe)
    *
    * Enables the parity function. When parity is enabled, parity function inserts a parity bit
    * in the bit position immediately preceding the stop bit.
    * This field must be set when C7816[ISO_7816E] is set/enabled.
    */
   enum UartParityEnable : uint8_t {
      UartParityEnable_Disabled   = UART_C1_PE(0),  ///< Disabled
      UartParityEnable_Enabled    = UART_C1_PE(1),  ///< Enabled
   };

   /**
    * Parity Type
    * (uart_c1_pt)
    *
    * Determines whether the UART generates and checks for even parity or odd parity.
    * With even parity, an even number of 1s clears the parity bit and an odd number of
    * 1s sets the parity bit.
    * With odd parity, an odd number of 1s clears the parity bit and an even number of 1s
    * sets the parity bit. 
    * This field must be cleared when C7816[ISO_7816E] is set/enabled.
    */
   enum UartParityType : uint8_t {
      UartParityType_EvenParity   = UART_C1_PT(0),  ///< Even parity
      UartParityType_OddParity    = UART_C1_PT(1),  ///< Odd parity
   };

   /**
    * 10-bit Mode select
    * (uart_c4_m10)
    *
    * Causes a tenth, non-memory mapped bit to be part of the serial transmission.
    * This tenth bit is generated and interpreted as a parity bit.
    * The M10 field does not affect the LIN send or detect break behavior.
    * If M10 is set, then both C1[M] and C1[PE] must also be set.
    * This field must be cleared when C7816[ISO7816E] is set/enabled.
    */
   enum Uart10BitModeSelect : uint8_t {
      Uart10BitModeSelect_8Or9BitChars   = UART_C4_M10(0),  ///< 8 or 9-bit chars
      Uart10BitModeSelect_10BitChars     = UART_C4_M10(1),  ///< 10-bit chars
   };

   /**
    * Baud Rate Fine Adjust
    * (uart_c4_brfa)
    *
    * This bit field is used to add more timing resolution to the average baud frequency, in increments of 1/32
    */
   enum UartBaudRateFineAdjust : uint8_t {
   };

   /**
    * Transmit complete action
    * (uart_c2_tcie)
    *
    * Enable interrupt on transmission complete
    */
   enum UartTxCompleteAction : uint8_t {
      UartTxCompleteAction_None        = UART_C2_TCIE(0),  ///< None
      UartTxCompleteAction_Interrupt   = UART_C2_TCIE(1),  ///< Interrupt
   };

   /**
    * Idle line detect action
    * (uart_c2_ilie)
    *
    * Enable interrupt on tidele line detect
    */
   enum UartIdleLineDetectAction : uint8_t {
      UartIdleLineDetectAction_None        = UART_C2_ILIE(0),  ///< None
      UartIdleLineDetectAction_Interrupt   = UART_C2_ILIE(1),  ///< Interrupt
   };

   /**
    * Receiver Wakeup Control
    * (uart_c2_rwu)
    *
    * Setting RWU enables the wakeup function and inhibits further receiver interrupt requests.
    * Normally, hardware wakes the receiver by automatically clearing RWU
    */
   enum UartReceiverWakeupControl : uint8_t {
      UartReceiverWakeupControl_NormalOperation         = UART_C2_RWU(0),  ///< Normal operation
      UartReceiverWakeupControl_WakeupFunctionEnabled   = UART_C2_RWU(1),  ///< Wakeup function enabled
   };

   /**
    * Send Break
    * (uart_c2_sbk)
    *
    * Toggling SBK sends one break character. Toggling implies clearing the SBK field before
    * the break character has finished transmitting.
    * As long as SBK is set, the transmitter continues to send complete break characters.                Number of 
    * bits used:
    * - 10, 11, or 12 logic 0s if S2[BRK13] is cleared
    * - 13 or 14 logic 0s if S2[BRK13] is set.
    * This field must be cleared when C7816[ISO_7816E] is set.
    */
   enum UartSendBreak : uint8_t {
      UartSendBreak_NormalOperation       = UART_C2_SBK(0),  ///< Normal operation
      UartSendBreak_QueueBreakCharacter   = UART_C2_SBK(1),  ///< Queue break character
   };

   /**
    * Transmit Data Register Empty Flag
    * (uart_s1_tdre)
    *
    * Set when the number of words in the transmit buffer is &amp;lt;= TWFIFO[TXWATER]
    * To clear TDRE, read S1 when TDRE is set and then write to the data register
    */
   enum UartTransmitDataRegisterEmptyFlag : uint8_t {
      UartTransmitDataRegisterEmptyFlag_TxFifoLevelGtTxwater   = UART_S1_TDRE(0),  ///< Tx FIFO level > TXWATER
      UartTransmitDataRegisterEmptyFlag_TxFifoLevelLtTxwater   = UART_S1_TDRE(1),  ///< Tx FIFO level <= TXWATER
   };

   /**
    * Transmit Complete Flag
    * (uart_s1_tc)
    *
    * Set when the transmit buffer is empty and no data, preamble, or break character is being transmitted.
    * Cleared by reading S1 with TC set and then doing one of the following:
    * - Write to the data register to transmit new data
    * - Queue a preamble by changing TE from 0 to 1
    * - Queue a break character by writing 1 to C2.SBK
    */
   enum UartTransmitCompleteFlag : uint8_t {
      UartTransmitCompleteFlag_Active   = UART_S1_TC(0),  ///< Active
      UartTransmitCompleteFlag_Idle     = UART_S1_TC(1),  ///< Idle
   };

   /**
    * Receive Data Register Full Flag
    * (uart_s1_rdrf)
    *
    * RDRF is set when the number of datawords in the receive buffer is equal to or more than the number indicated by
    *  RWFIFO[RXWATER].
    * To clear RDRF, read S1 when RDRF is set and then read D
    */
   enum UartReceiveDataRegisterFullFlag : uint8_t {
      UartReceiveDataRegisterFullFlag_RxFifoLevelLtRxwater   = UART_S1_RDRF(0),  ///< Rx FIFO level < RXWATER
      UartReceiveDataRegisterFullFlag_RxFifoLevelGtRxwater   = UART_S1_RDRF(1),  ///< Rx FIFO level >= RXWATER
   };

   /**
    * Idle Line Flag
    * (uart_s1_idle)
    *
    * After the IDLE flag is cleared, a frame must be received or a LIN break character must set the S2[LBKDIF] flag 
    * before an idle condition can set the IDLE flag.
    * To clear IDLE, read S1 with IDLE set and then read D
    */
   enum UartIdleLineFlag : uint8_t {
      UartIdleLineFlag_NotDetected   = UART_S1_IDLE(0),  ///< Not detected
      UartIdleLineFlag_Detected      = UART_S1_IDLE(1),  ///< Detected
   };

   /**
    * Receiver Overrun Flag
    * (uart_s1_or)
    *
    * OR is set when software fails to prevent the receive data register from overflowing with data.
    * To clear OR, read S1 when OR is set and then read D
    */
   enum UartReceiverOverrunFlag : uint8_t {
      UartReceiverOverrunFlag_NoError   = UART_S1_OR(0),  ///< No error
      UartReceiverOverrunFlag_Error     = UART_S1_OR(1),  ///< Error
   };

   /**
    * Noise Flag
    * (uart_s1_nf)
    *
    * NF is set when the UART detects noise on the receiver input.
    * To clear NF, read S1 and then read D
    */
   enum UartNoiseFlag : uint8_t {
      UartNoiseFlag_NoError   = UART_S1_NF(0),  ///< No error
      UartNoiseFlag_Error     = UART_S1_NF(1),  ///< Error
   };

   /**
    * Framing Error Flag
    * (uart_s1_fe)
    *
    * FE is set when a logic 0 is accepted as the stop bit.
    * To clear FE, read S1 with FE set and then read D
    */
   enum UartFramingErrorFlag : uint8_t {
      UartFramingErrorFlag_NoError   = UART_S1_FE(0),  ///< No error
      UartFramingErrorFlag_Error     = UART_S1_FE(1),  ///< Error
   };

   /**
    * Parity Error Flag
    * (uart_s1_pf)
    *
    * PF is set when PE is set and the parity of the received data does not match its parity bit.
    * To clear PF, read S1 with PF set and then read D
    */
   enum UartParityErrorFlag : uint8_t {
      UartParityErrorFlag_NoError   = UART_S1_PF(0),  ///< No error
      UartParityErrorFlag_Error     = UART_S1_PF(1),  ///< Error
   };

   /**
    * Status Flags
    * (uart_s1_stat)
    *
    * These masks may be used to test or modify the status flags
    */
   enum class UartStatusFlag : uint32_t {
      ParityErrorFlag                 = (UART_S1_PF_MASK),    ///< Parity Error Flag
      FramingErrorFlag                = (UART_S1_FE_MASK),    ///< Framing Error Flag
      NoiseFlag                       = (UART_S1_NF_MASK),    ///< Noise Flag
      ReceiverOverrunFlag             = (UART_S1_OR_MASK),    ///< Receiver Overrun Flag
      IdleLineFlag                    = (UART_S1_IDLE_MASK),  ///< Idle Line Flag
      ReceiveDataRegisterFullFlag     = (UART_S1_RDRF_MASK),  ///< Receive Data Register Full Flag
      TransmitCompleteFlag            = (UART_S1_TC_MASK),    ///< Transmit Complete Flag
      TransmitDataRegisterEmptyFlag   = (UART_S1_TDRE_MASK),  ///< Transmit Data Register Empty Flag
      NoFlags                         = (0x0U),               ///< No flags
      AllFlags                        = (0xffU),              ///< All flags
   };


   /**
    * Combines two UartStatusFlag values (by ORing)
    * Used to create a combined UartStatusFlag mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return  Combined value
    */
   constexpr UartStatusFlag operator|(UartStatusFlag left, UartStatusFlag right) {
      return UartStatusFlag(uint32_t(left)|uint32_t(right));
   }
   
   /**
    * Combines two UartStatusFlag values (by ANDing) to produce a bool result
    * Used to check a value against a UartStatusFlag mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return boolean value indicating if the result is non-zero
    */
   constexpr bool operator&(UartStatusFlag left, UartStatusFlag right) {
      return bool(uint32_t(left)&uint32_t(right));
   }
   
   /**
    * LIN Break Detect Interrupt Flag
    * (uart_s2_lbkdif)
    *
    * LBKDIF is set when LBKDE is set and a LIN break character is detected on the receiver input.
    * LBKDIF is cleared by writing a 1 to it
    */
   enum UartLinBreakDetectInterruptFlag : uint8_t {
      UartLinBreakDetectInterruptFlag_NoInterrupt        = UART_S2_LBKDIF(0),  ///< No Interrupt
      UartLinBreakDetectInterruptFlag_InterruptPending   = UART_S2_LBKDIF(1),  ///< Interrupt pending
   };

   /**
    * RxD Pin Active Edge Interrupt Flag
    * (uart_s2_rxedgif)
    *
    * RXEDGIF is set when an active edge occurs on the RxD pin.
    * The active edge is falling if RXINV = 0, and rising if RXINV=1.
    * RXEDGIF is cleared by writing a 1 to it
    */
   enum UartRxdPinActiveEdgeInterruptFlag : uint8_t {
      UartRxdPinActiveEdgeInterruptFlag_NoInterrupt        = UART_S2_RXEDGIF(0),  ///< No interrupt
      UartRxdPinActiveEdgeInterruptFlag_InterruptPending   = UART_S2_RXEDGIF(1),  ///< Interrupt pending
   };

   /**
    * Most Significant Bit First
    * (uart_s2_msbf)
    *
    * Setting this field reverses the order of the bits that are transmitted and received on the wire
    */
   enum UartMostSignificantBitFirst : uint8_t {
      UartMostSignificantBitFirst_LsbFirst   = UART_S2_MSBF(0),  ///< LSB first
      UartMostSignificantBitFirst_MsbFirst   = UART_S2_MSBF(1),  ///< MSB first
   };

   /**
    * Receive Data Inversion
    * (uart_s2_rxinv)
    *
    * Setting this field reverses the polarity of the received data input
    */
   enum UartReceiveDataInversion : uint8_t {
      UartReceiveDataInversion_RxdNotInverted   = UART_S2_RXINV(0),  ///< RxD not inverted
      UartReceiveDataInversion_RxdInverted      = UART_S2_RXINV(1),  ///< RxD inverted
   };

   /**
    * Receive Wakeup Idle Detect
    * (uart_s2_rwuid)
    *
    * When RWU is set and WAKE is cleared, this field controls whether the idle character that wakes the             
    *  receiver sets S1[IDLE]
    */
   enum UartReceiveWakeupIdleDetect : uint8_t {
      UartReceiveWakeupIdleDetect_IdleCharsIgnored       = UART_S2_RWUID(0),  ///< Idle chars ignored
      UartReceiveWakeupIdleDetect_IdleDetectSetsS1Idle   = UART_S2_RWUID(1),  ///< Idle detect sets S1.IDLE
   };

   /**
    * Break Transmit Character Length
    * (uart_s2_brk13)
    *
    * Determines whether the transmit break character is 10, 11, or 12 bits long, or 13 or 14 bits long
    */
   enum UartBreakTransmitCharacterLength : uint8_t {
      UartBreakTransmitCharacterLength_Short   = UART_S2_BRK13(0),  ///< Short
      UartBreakTransmitCharacterLength_Long    = UART_S2_BRK13(1),  ///< Long
   };

   /**
    * LIN Break Detection Enable
    * (uart_s2_lbkde)
    *
    * Enables LIN break character detection.
    * While LBKDE is set, S1[RDRF], S1[NF], S1[FE], and S1[PF] are prevented from setting
    */
   enum UartLinBreakDetectionEnable : uint8_t {
      UartLinBreakDetectionEnable_Disabled   = UART_S2_LBKDE(0),  ///< Disabled
      UartLinBreakDetectionEnable_Enabled    = UART_S2_LBKDE(1),  ///< Enabled
   };

   /**
    * Receiver Active Flag
    * (uart_s2_raf)
    *
    * RAF is set when the UART receiver detects a logic 0 during the RT1 time period of the start bit search.
    * RAF is cleared when the receiver detects an idle character
    */
   enum UartReceiverActiveFlag : uint8_t {
      UartReceiverActiveFlag_ReceiverIdle     = UART_S2_RAF(0),  ///< Receiver idle
      UartReceiverActiveFlag_ReceiverActive   = UART_S2_RAF(1),  ///< Receiver active
   };

   /**
    * Received Bit 8
    * (uart_c3_r8)
    *
    * R8 is the ninth data bit received when the UART is configured for 9-bit data format,
    * that is, if C1[M] = 1 or C4[M10] = 1.
    */
   enum UartReceivedBit8 : uint8_t {
      UartReceivedBit8_0   = UART_C3_R8(0),  ///< Data 0
      UartReceivedBit8_1   = UART_C3_R8(1),  ///< Data 1
   };

   /**
    * Transmit Bit 8
    * (uart_c3_t8)
    *
    * T8 is the ninth data bit transmitted when the UART is configured for 9-bit data format,
    * that is, if C1[M] = 1 or C4[M10] = 1.
    * NOTE: If the value of T8 is the same as in the previous transmission, T8 does not
    * have to be rewritten. The same value is transmitted until T8 is rewritten.
    */
   enum UartTransmitBit8 : uint8_t {
      UartTransmitBit8_0   = UART_C3_T8(0),  ///< Data 0
      UartTransmitBit8_1   = UART_C3_T8(1),  ///< Data 1
   };

   /**
    * Transmitter Pin Direction in Single-Wire mode
    * (uart_c3_txdir)
    *
    * Determines whether the TXD pin is used as an input or output in the single-wire mode of operation.
    * This field is relevant only to the single wire mode. When C7816[ISO7816E] is set/enabled and
    * C7816[TTYPE] = 1, this field is automatically cleared after the requested block is transmitted.
    * This condition is detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
    * Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is being transmitted,
    * the hardware automatically overrides this field as needed. In this situation, TXDIR does not reflect
    * the temporary state associated with the NACK.
    */
   enum UartTransmitterPinDirectionInSingleWire : uint8_t {
      UartTransmitterPinDirectionInSingleWire_TxdPinIsInput    = UART_C3_TXDIR(0),  ///< TxD pin is input
      UartTransmitterPinDirectionInSingleWire_TxdPinIsOutput   = UART_C3_TXDIR(1),  ///< TxD pin is output
   };

   /**
    * Transmit Data Inversion
    * (uart_c3_txinv)
    *
    * Setting this field reverses the polarity of the transmitted data output.
    * In NRZ format, a one is represented by a mark and a zero is represented by a
    * space for normal polarity, and the opposite for inverted polarity.
    * In IrDA format, a zero is represented by short high pulse in the middle of a 
    * bit time remaining idle low for a one for normal polarity, and a zero is represented
    * by short low pulse in the middle of a bit time remaining idle high for a one for
    * inverted polarity.This field is automatically set when C7816[INIT] and C7816[ISO7816E]
    * are enabled and an initial character is detected in T = 0 protocol mode.
    * NOTE: Setting TXINV inverts all transmitted values, including idle, break, start, and stop bits.
    * In loop mode, if TXINV is set, the receiver gets the transmit inversion bit when RXINV is disabled.
    * When C7816[ISO7816E] is set/enabled then only the transmitted data bits and parity bit are inverted.
    */
   enum UartTransmitDataInversion : uint8_t {
      UartTransmitDataInversion_TxdNotInverted   = UART_C3_TXINV(0),  ///< TxD not inverted
      UartTransmitDataInversion_TxdInverted      = UART_C3_TXINV(1),  ///< TxD inverted
   };

   /**
    * Overrun Error Interrupt Enable
    * (uart_c3_orie)
    *
    * Enables the overrun error flag, S1[OR], to generate interrupt requests.
    */
   enum UartOverrunErrorInterruptEnable : uint8_t {
      UartOverrunErrorInterruptEnable_Disabled   = UART_C3_ORIE(0),  ///< Disabled
      UartOverrunErrorInterruptEnable_Enabled    = UART_C3_ORIE(1),  ///< Enabled
   };

   /**
    * Noise Error Interrupt Enable
    * (uart_c3_neie)
    *
    * Enables the noise flag, S1[NF], to generate interrupt requests.
    */
   enum UartNoiseErrorInterruptEnable : uint8_t {
      UartNoiseErrorInterruptEnable_Disabled   = UART_C3_NEIE(0),  ///< Disabled
      UartNoiseErrorInterruptEnable_Enabled    = UART_C3_NEIE(1),  ///< Enabled
   };

   /**
    * Framing Error Interrupt Enable
    * (uart_c3_feie)
    *
    * Enables the framing error flag, S1[FE], to generate interrupt requests.
    */
   enum UartFramingErrorInterruptEnable : uint8_t {
      UartFramingErrorInterruptEnable_Disabled   = UART_C3_FEIE(0),  ///< Disabled
      UartFramingErrorInterruptEnable_Enabled    = UART_C3_FEIE(1),  ///< Enabled
   };

   /**
    * Parity Error Interrupt Enable
    * (uart_c3_peie)
    *
    * Enables the parity error flag, S1[PF], to generate interrupt requests.
    */
   enum UartParityErrorInterruptEnable : uint8_t {
      UartParityErrorInterruptEnable_Disabled   = UART_C3_PEIE(0),  ///< Disabled
      UartParityErrorInterruptEnable_Enabled    = UART_C3_PEIE(1),  ///< Enabled
   };

   /**
    * Match Address Mode Enable 1
    * (uart_c4_maen1)
    *
    * When enabled, all data received with the most significant bit cleared, is discarded.
    * All data received with the most significant bit set, is compared with contents of MA1 register.
    * If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer.
    * This field must be cleared when C7816[ISO7816E] is set/enabled.
    */
   enum UartMatchAddressModeEnable1 : uint8_t {
      UartMatchAddressModeEnable1_Disabled   = UART_C4_MAEN1(0),  ///< Disabled
      UartMatchAddressModeEnable1_Enabled    = UART_C4_MAEN1(1),  ///< Enabled
   };

   /**
    * Match Address Mode Enable 2
    * (uart_c4_maen2)
    *
    * When enabled, all data received with the most significant bit cleared, is discarded.
    * All data received with the most significant bit set, is compared with contents of MA1 register.
    * If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer.
    * This field must be cleared when C7816[ISO7816E] is set/enabled.
    */
   enum UartMatchAddressModeEnable2 : uint8_t {
      UartMatchAddressModeEnable2_Disabled   = UART_C4_MAEN2(0),  ///< Disabled
      UartMatchAddressModeEnable2_Enabled    = UART_C4_MAEN2(1),  ///< Enabled
   };

   /**
    * Transmitter Interrupt/DMA Select
    * (uart_c5_tdmas)
    *
    * Selects between DMA and interrupt requests when C2[TIE] and S1[TDRE] flags are set
    */
   enum UartTxEmptyDma : uint8_t {
      UartTxEmptyDma_InterruptRequest   = UART_C5_TDMAS(0),  ///< Interrupt request
      UartTxEmptyDma_DmaRequest         = UART_C5_TDMAS(1),  ///< DMA request
   };

   /**
    * Receiver Full Interrupt/DMA Select
    * (uart_c5_rdmas)
    *
    * Selects between DMA and interrupt requests when C2[RIE] and S1[RDRF] flags are set
    */
   enum UartRxFullDma : uint8_t {
      UartRxFullDma_InterruptRequest   = UART_C5_RDMAS(0),  ///< Interrupt request
      UartRxFullDma_DmaRequest         = UART_C5_RDMAS(1),  ///< DMA request
   };

   /**
    * Noise Error
    * (uart_ed_noisy)
    *
    * The current received dataword contained in D and C3[R8] was received with noise
    */
   enum UartNoiseError : uint8_t {
      UartNoiseError_NoError   = UART_ED_NOISY(0),  ///< No error
      UartNoiseError_Error     = UART_ED_NOISY(1),  ///< Error
   };

   /**
    * Parity Error
    * (uart_ed_paritye)
    *
    * Indicates if the current received dataword contained in D and C3[R8] was received with a parity error
    */
   enum UartParityError : uint8_t {
      UartParityError_NoError   = UART_ED_PARITYE(0),  ///< No error
      UartParityError_Error     = UART_ED_PARITYE(1),  ///< Error
   };

   /**
    * Receiver request-to-send enable
    * (uart_modem_rxrtse)
    *
    * If enabled RTS is deasserted if the number of characters in the receiver data register (FIFO) is
    * equal to or greater than RWFIFO[RXWATER].
    * RTS is asserted when the number of characters in the receiver data register (FIFO) is less than RWFIFO[RXWATER]
    */
   enum UartReceiverRequestToSendEnable : uint8_t {
      UartReceiverRequestToSendEnable_RtsUnaffectd    = UART_MODEM_RXRTSE(0),  ///< RTS unaffectd
      UartReceiverRequestToSendEnable_RtsControlled   = UART_MODEM_RXRTSE(1),  ///< RTS controlled
   };

   /**
    * Transmitter request-to-send polarity
    * (uart_modem_txrtspol)
    *
    * Controls the polarity of the transmitter RTS.
    * TXRTSPOL does not affect the polarity of the receiver RTS.
    * RTS will remain negated in the active low state unless TXRTSE is set.
    */
   enum UartTransmitterRequestToSendPolarity : uint8_t {
      UartTransmitterRequestToSendPolarity_ActiveLow    = UART_MODEM_TXRTSPOL(0),  ///< Active low
      UartTransmitterRequestToSendPolarity_ActiveHigh   = UART_MODEM_TXRTSPOL(1),  ///< Active high
   };

   /**
    * Transmitter request-to-send enable
    * (uart_modem_txrtse)
    *
    * If enabled, when a character is placed into an empty transmitter data buffer(FIFO),
    * RTS asserts one bit time before the start bit is transmitted. 
    * RTS deasserts one bit time after all characters in the transmitter data buffer(FIFO)
    * and shift register are completely sent, including the last stop bit
    */
   enum UartTransmitterRequestToSendEnable : uint8_t {
      UartTransmitterRequestToSendEnable_RtsUnaffected   = UART_MODEM_TXRTSE(0),  ///< RTS unaffected
      UartTransmitterRequestToSendEnable_RtsControlled   = UART_MODEM_TXRTSE(1),  ///< RTS controlled
   };

   /**
    * Transmitter clear-to-send enable
    * (uart_modem_txctse)
    *
    * If enabled, the transmitter checks the state of CTS each time it is ready to send a character. 
    * If CTS is asserted, the character is sent.
    * If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed
    * until CTS is asserted.
    * Changes in CTS as a character is being sent do not affect its transmission
    */
   enum UartTransmitterClearToSendEnable : uint8_t {
      UartTransmitterClearToSendEnable_CtsIgnored                = UART_MODEM_TXCTSE(0),  ///< CTS ignored
      UartTransmitterClearToSendEnable_CtsControlsTransmission   = UART_MODEM_TXCTSE(1),  ///< CTS controls transmission
   };

   /**
    * Infrared enable
    * (uart_ir_iren)
    *
    * Enables/disables the infrared modulation/demodulation.
    */
   enum UartInfraredEnable : uint8_t {
      UartInfraredEnable_IrDisabled   = UART_IR_IREN(0),  ///< IR disabled
      UartInfraredEnable_IrEnabled    = UART_IR_IREN(1),  ///< IR enabled
   };

   /**
    * Transmitter narrow pulse
    * (uart_ir_tnp)
    *
    * Enables whether the UART transmits a 1/16, 3/16, 1/32, or 1/4 narrow pulse.
    */
   enum UartTransmitterNarrowPulse : uint8_t {
      UartTransmitterNarrowPulse_316   = UART_IR_TNP(0),  ///< 3/16
      UartTransmitterNarrowPulse_116   = UART_IR_TNP(1),  ///< 1/16
      UartTransmitterNarrowPulse_132   = UART_IR_TNP(2),  ///< 1/32
      UartTransmitterNarrowPulse_14    = UART_IR_TNP(3),  ///< 1/4
   };

   /**
    * Transmit FIFO Enable
    * (uart_pfifo_txfe)
    *
    * When this field is set, the built in FIFO structure for the transmit buffer is enabled.
    * The size of the FIFO structure is indicated by TXFIFOSIZE.
    * If this field is not set, the transmit buffer operates as a FIFO of depth one dataword
    * regardless of the value in TXFIFOSIZE. 
    * Both C2[TE] and C2[RE] must be cleared prior to changing this field. Additionally,
    * TXFLUSH and RXFLUSH commands must be issued immediately after changing this field.
    */
   enum UartTransmitFifoEnable : uint8_t {
      UartTransmitFifoEnable_Disabled   = UART_PFIFO_TXFE(0),  ///< Disabled
      UartTransmitFifoEnable_Enabled    = UART_PFIFO_TXFE(1),  ///< Enabled
   };

   /**
    * Transmit FIFO Buffer Depth
    * (uart_pfifo_txfifosize)
    *
    * The maximum number of transmit datawords that can be stored in the transmit buffer.
    * This field is read only
    */
   enum UartTransmitFifoBufferDepth : uint8_t {
      UartTransmitFifoBufferDepth_1Dataword      = UART_PFIFO_TXFIFOSIZE(0),  ///< 1 dataword
      UartTransmitFifoBufferDepth_4Datawords     = UART_PFIFO_TXFIFOSIZE(1),  ///< 4 datawords
      UartTransmitFifoBufferDepth_8Datawords     = UART_PFIFO_TXFIFOSIZE(2),  ///< 8 datawords
      UartTransmitFifoBufferDepth_16Datawords    = UART_PFIFO_TXFIFOSIZE(3),  ///< 16 datawords
      UartTransmitFifoBufferDepth_32Datawords    = UART_PFIFO_TXFIFOSIZE(4),  ///< 32 datawords
      UartTransmitFifoBufferDepth_64Datawords    = UART_PFIFO_TXFIFOSIZE(5),  ///< 64 datawords
      UartTransmitFifoBufferDepth_128Datawords   = UART_PFIFO_TXFIFOSIZE(6),  ///< 128 datawords
      UartTransmitFifoBufferDepth_Reserved       = UART_PFIFO_TXFIFOSIZE(7),  ///< Reserved
   };

   /**
    * Receive FIFO Enable
    * (uart_pfifo_rxfe)
    *
    * When this field is set, the built in FIFO structure for the receive buffer is enabled.
    * The size of the FIFO structure is indicated by the RXFIFOSIZE field.
    * If this field is not set, the receive buffer operates as a FIFO of depth one dataword
    * regardless of the value in RXFIFOSIZE.
    * Both C2[TE] and C2[RE] must be cleared prior to changing this field.
    * Additionally, TXFLUSH and RXFLUSH commands must be issued immediately after changing this field.
    */
   enum UartReceiveFifoEnable : uint8_t {
      UartReceiveFifoEnable_Disabled   = UART_PFIFO_RXFE(0),  ///< Disabled
      UartReceiveFifoEnable_Enabled    = UART_PFIFO_RXFE(1),  ///< Enabled
   };

   /**
    * Receive FIFO Depth
    * (uart_pfifo_rxfifosize)
    *
    * The maximum number of receive datawords that can be stored in the receive buffer
    * before an overrun occurs.
    * This field is read only.
    */
   enum UartReceiveFifoDepth : uint8_t {
      UartReceiveFifoDepth_1Dataword      = UART_PFIFO_RXFIFOSIZE(0),  ///< 1 dataword
      UartReceiveFifoDepth_4Datawords     = UART_PFIFO_RXFIFOSIZE(1),  ///< 4 datawords
      UartReceiveFifoDepth_8Datawords     = UART_PFIFO_RXFIFOSIZE(2),  ///< 8 datawords
      UartReceiveFifoDepth_16Datawords    = UART_PFIFO_RXFIFOSIZE(3),  ///< 16 datawords
      UartReceiveFifoDepth_32Datawords    = UART_PFIFO_RXFIFOSIZE(4),  ///< 32 datawords
      UartReceiveFifoDepth_64Datawords    = UART_PFIFO_RXFIFOSIZE(5),  ///< 64 datawords
      UartReceiveFifoDepth_128Datawords   = UART_PFIFO_RXFIFOSIZE(6),  ///< 128 datawords
      UartReceiveFifoDepth_Reserved       = UART_PFIFO_RXFIFOSIZE(7),  ///< Reserved
   };

   /**
    * Transmit FIFO/Buffer Flush
    * (uart_cfifo_txflush)
    *
    * Writing to this field causes all data that is stored in the transmit FIFO/buffer to be flushed.
    * This does not affect data that is in the transmit shift register
    */
   enum UartTransmitFifo_BufferFlush : uint8_t {
      UartTransmitFifo_BufferFlush_Write1ToFlush   = UART_CFIFO_TXFLUSH(0),  ///< Write 1 to flush
   };

   /**
    * Receive FIFO/Buffer Flush
    * (uart_cfifo_rxflush)
    *
    * Writing to this field causes all data that is stored in the receive FIFO/buffer to be flushed.
    * This does not affect data that is in the receive shift register
    */
   enum UartReceiveFifo_BufferFlush : uint8_t {
      UartReceiveFifo_BufferFlush_Write1ToFlush   = UART_CFIFO_RXFLUSH(0),  ///< Write 1 to flush
   };

   /**
    * Receive FIFO Overflow Interrupt Enable
    * (uart_cfifo_rxofe)
    *
    * If this bit is set, the RXOF flag generates an interrupt
    */
   enum UartReceiveFifoOverflowInterruptEnable : uint8_t {
      UartReceiveFifoOverflowInterruptEnable_Disabled   = UART_CFIFO_RXOFE(0),  ///< Disabled
      UartReceiveFifoOverflowInterruptEnable_Enabled    = UART_CFIFO_RXOFE(1),  ///< Enabled
   };

   /**
    * Transmit FIFO Overflow Interrupt Enable
    * (uart_cfifo_txofe)
    *
    * If this bit is set, the TXOF flag generates an interrupt
    */
   enum UartTransmitFifoOverflowInterruptEnable : uint8_t {
      UartTransmitFifoOverflowInterruptEnable_Disabled   = UART_CFIFO_TXOFE(0),  ///< Disabled
      UartTransmitFifoOverflowInterruptEnable_Enabled    = UART_CFIFO_TXOFE(1),  ///< Enabled
   };

   /**
    * Receive FIFO Underflow Interrupt Enable
    * (uart_cfifo_rxufe)
    *
    * If this bit is set, the RXUF flag generates an interrupt
    */
   enum UartReceiveFifoUnderflowInterruptEnable : uint8_t {
      UartReceiveFifoUnderflowInterruptEnable_Disabled   = UART_CFIFO_RXUFE(0),  ///< Disabled
      UartReceiveFifoUnderflowInterruptEnable_Enabled    = UART_CFIFO_RXUFE(1),  ///< Enabled
   };

   /**
    * Transmit Buffer/FIFO Empty
    * (uart_sfifo_txempt)
    *
    * Asserts when there is no data in the Transmit FIFO/buffer.
    * This field does not take into account data that is in the transmit shift register.
    */
   enum UartTransmitBuffer_FifoEmpty : uint8_t {
      UartTransmitBuffer_FifoEmpty_BufferNotEmpty   = UART_SFIFO_TXEMPT(0),  ///< Buffer not empty
      UartTransmitBuffer_FifoEmpty_BufferEmpty      = UART_SFIFO_TXEMPT(1),  ///< Buffer empty
   };

   /**
    * Receive Buffer/FIFO Empty
    * (uart_sfifo_rxempt)
    *
    * Asserts when there is no data in the receive FIFO/Buffer.
    * This field does not take into account data that is in the receive shift register.
    */
   enum UartReceiveBuffer_FifoEmpty : uint8_t {
      UartReceiveBuffer_FifoEmpty_BufferNotEmpty   = UART_SFIFO_RXEMPT(0),  ///< Buffer not empty
      UartReceiveBuffer_FifoEmpty_BufferEmpty      = UART_SFIFO_RXEMPT(1),  ///< Buffer empty
   };

   /**
    * Receiver Buffer Overflow Flag
    * (uart_sfifo_rxof)
    *
    * Indicates that more data has been written to the receive buffer than it can hold
    * This field will assert regardless of the value of CFIFO[RXOFE]. However, an interrupt will
    * only be issued to the host if CFIFO[RXOFE] is set.
    * This flag is cleared by writing a 1.
    */
   enum UartReceiveFifoOverflow : uint8_t {
      UartReceiveFifoOverflow_NoError   = UART_SFIFO_RXOF(0),  ///< No error
      UartReceiveFifoOverflow_Error     = UART_SFIFO_RXOF(1),  ///< Error
   };

   /**
    * Transmitter Buffer Overflow Flag
    * (uart_sfifo_txof)
    *
    * Indicates that more data has been written to the transmit buffer than it can hold.
    * This field will assert regardless of the value of CFIFO[TXOFE]. However, an interrupt will
    * be issued to the host only if CFIFO[TXOFE] is set.
    * This flag is cleared by writing a 1.
    */
   enum UartTransmitFifoOverflow : uint8_t {
      UartTransmitFifoOverflow_NoError   = UART_SFIFO_TXOF(0),  ///< No error
      UartTransmitFifoOverflow_Error     = UART_SFIFO_TXOF(1),  ///< Error
   };

   /**
    * Receiver Buffer Underflow Flag
    * (uart_sfifo_rxuf)
    *
    * Indicates that more data has been read from the receive buffer than was present.
    * This field will assert regardless of the value of CFIFO[RXUFE]. However, an interrupt
    * will be issued to the host only if CFIFO[RXUFE] is set.
    * This flag is cleared by writing a 1.
    */
   enum UartReceiveFifoUnderflow : uint8_t {
      UartReceiveFifoUnderflow_NoError   = UART_SFIFO_RXUF(0),  ///< No error
      UartReceiveFifoUnderflow_Error     = UART_SFIFO_RXUF(1),  ///< Error
   };

   /**
    * Transmit Watermark
    * (uart_twfifo_txwater)
    *
    * When the number of datawords in the transmit FIFO/buffer is equal to or less than the value
    * in this register field, an interrupt via S1[TDRE] or a DMA request via C5[TDMAS] is generated
    * as determined by C5[TDMAS] and C2[TIE].
    * For proper operation, the value in TXWATER must be set to be less than the size of the transmit
    * buffer/FIFO size as indicated by PFIFO[TXFIFOSIZE] and PFIFO[TXFE].
    */
   enum UartTransmitWatermark : uint8_t {
   };

   /**
    * Receive Watermark
    * (uart_rwfifo_rxwater)
    *
    * When the number of datawords in the receive FIFO/buffer is equal to or greater than the value in this
    * register field, an interrupt via S1[RDRF] or a DMA request via C5[RDMAS] is generated as determined
    * by C5[RDMAS] and C2[RIE].
    * For proper operation, the value in RXWATER must be set to be less than the receive FIFO/buffer
    * size as indicated by PFIFO[RXFIFOSIZE] and PFIFO[RXFE] and must be greater than 0.
    */
   enum UartReceiveWatermark : uint8_t {
   };

   /**
    * Generate NACK on Overflow
    * (uart_c7816_onack)
    *
    * A NACK may be automatically sent if a receive buffer overrun occurs
    */
   enum UartGenerateNackOnOverflow : uint8_t {
      UartGenerateNackOnOverflow_NoAction   = UART_C7816_ONACK(0),  ///< No action
      UartGenerateNackOnOverflow_SendNack   = UART_C7816_ONACK(1),  ///< Send NACK
   };

   /**
    * Generate NACK on Error
    * (uart_c7816_anack)
    *
    * A NACK may be automatically generated if a parity error is detected or if an invalid initial character is 
    * detected
    */
   enum UartGenerateNackOnError : uint8_t {
      UartGenerateNackOnError_NoAction   = UART_C7816_ANACK(0),  ///< No action
      UartGenerateNackOnError_SendNack   = UART_C7816_ANACK(1),  ///< Send NACK
   };

   /**
    * Detect Initial Character
    * (uart_c7816_init)
    *
    * When this field is set, all received characters are searched for a valid initial character.
    * If an invalid initial character is identified, and ANACK is set, a NACK is sent
    */
   enum UartDetectInitialCharacter : uint8_t {
      UartDetectInitialCharacter_NormalOperatingMode   = UART_C7816_INIT(0),  ///< Normal operating mode
      UartDetectInitialCharacter_SearchMode            = UART_C7816_INIT(1),  ///< Search mode
   };

   /**
    * Transfer Type
    * (uart_c7816_ttype)
    *
    * Indicates the transfer protocol being used
    */
   enum UartTransferType : uint8_t {
      UartTransferType_Iso7816T0Specification   = UART_C7816_TTYPE(0),  ///< ISO-7816 T = 0 specification
      UartTransferType_Iso7816T1Specification   = UART_C7816_TTYPE(1),  ///< ISO-7816 T = 1 specification
   };

   /**
    * ISO-7816 Functionality Enabled
    * (uart_c7816_iso_7816e)
    *
    * 
    */
   enum UartIso7816FunctionalityEnabled : uint8_t {
      UartIso7816FunctionalityEnabled_Disabled   = UART_C7816_ISO_7816E(0),  ///< Disabled
      UartIso7816FunctionalityEnabled_Enabled    = UART_C7816_ISO_7816E(1),  ///< Enabled
   };

   /**
    * Wait Timer Interrupt Enable
    * (uart_ie7816_wte)
    *
    * 
    */
   enum UartWaitTimerInterruptEnable : uint8_t {
      UartWaitTimerInterruptEnable_InterruptDisabled   = UART_IE7816_WTE(0),  ///< Interrupt disabled
      UartWaitTimerInterruptEnable_InterruptEnabled    = UART_IE7816_WTE(1),  ///< Interrupt enabled
   };

   /**
    * Character Wait Timer (CWT) Interrupt Enable
    * (uart_ie7816_cwte)
    *
    * 
    */
   enum UartCharacterWaitTimerCwtInterruptEna : uint8_t {
      UartCharacterWaitTimerCwtInterruptEna_InterruptDisabled   = UART_IE7816_CWTE(0),  ///< Interrupt disabled
      UartCharacterWaitTimerCwtInterruptEna_InterruptEnabled    = UART_IE7816_CWTE(1),  ///< Interrupt enabled
   };

   /**
    * Block Wait Timer (BWT) Interrupt Enable
    * (uart_ie7816_bwte)
    *
    * 
    */
   enum UartBlockWaitTimerBwtInterruptEnable : uint8_t {
      UartBlockWaitTimerBwtInterruptEnable_InterruptDisabled   = UART_IE7816_BWTE(0),  ///< Interrupt disabled
      UartBlockWaitTimerBwtInterruptEnable_InterruptEnabled    = UART_IE7816_BWTE(1),  ///< Interrupt enabled
   };

   /**
    * Initial Character Detected (INITD) Interrupt Enable
    * (uart_ie7816_initde)
    *
    * 
    */
   enum UartInitialCharacterDetectedInitdInter : uint8_t {
      UartInitialCharacterDetectedInitdInter_InterruptDisabled   = UART_IE7816_INITDE(0),  ///< Interrupt disabled
      UartInitialCharacterDetectedInitdInter_InterruptEnabled    = UART_IE7816_INITDE(1),  ///< Interrupt enabled
   };

   /**
    * Guard Timer Violated (GTV) Interrupt Enable
    * (uart_ie7816_gtve)
    *
    * 
    */
   enum UartGuardTimerViolatedGtvInterruptEna : uint8_t {
      UartGuardTimerViolatedGtvInterruptEna_InterruptDisabled   = UART_IE7816_GTVE(0),  ///< Interrupt disabled
      UartGuardTimerViolatedGtvInterruptEna_InterruptEnabled    = UART_IE7816_GTVE(1),  ///< Interrupt enabled
   };

   /**
    * Transmit Threshold Exceeded (TXT) Interrupt Enable
    * (uart_ie7816_txte)
    *
    * 
    */
   enum UartTransmitThresholdExceededTxtInterr : uint8_t {
      UartTransmitThresholdExceededTxtInterr_InterruptDisabled   = UART_IE7816_TXTE(0),  ///< Interrupt disabled
      UartTransmitThresholdExceededTxtInterr_InterruptEnabled    = UART_IE7816_TXTE(1),  ///< Interrupt enabled
   };

   /**
    * Receive Threshold Exceeded Interrupt Enable
    * (uart_ie7816_rxte)
    *
    * 
    */
   enum UartReceiveThresholdExceededInterruptEna : uint8_t {
      UartReceiveThresholdExceededInterruptEna_InterruptDisabled   = UART_IE7816_RXTE(0),  ///< Interrupt disabled
      UartReceiveThresholdExceededInterruptEna_InterruptEnabled    = UART_IE7816_RXTE(1),  ///< Interrupt enabled
   };

   /**
    * Wait Timer Interrupt
    * (uart_is7816_wt)
    *
    * Set when the Wait Time (WT) has been violated
    */
   enum UartWaitTimerInterrupt : uint8_t {
      UartWaitTimerInterrupt_Negated                 = UART_IS7816_WT(0),  ///< Negated
      UartWaitTimerInterrupt_AssertedWrite1ToClear   = UART_IS7816_WT(1),  ///< Asserted/Write 1 to clear
   };

   /**
    * Character Wait Timer Interrupt
    * (uart_is7816_cwt)
    *
    * Set when the Character Wait Time (CWT) has been violated
    */
   enum UartCharacterWaitTimerInterrupt : uint8_t {
      UartCharacterWaitTimerInterrupt_Negated                 = UART_IS7816_CWT(0),  ///< Negated
      UartCharacterWaitTimerInterrupt_AssertedWrite1ToClear   = UART_IS7816_CWT(1),  ///< Asserted/Write 1 to clear
   };

   /**
    * Block Wait Timer Interrupt
    * (uart_is7816_bwt)
    *
    * Set when the Block Wait Time (BWT) has been violated
    */
   enum UartBlockWaitTimerInterrupt : uint8_t {
      UartBlockWaitTimerInterrupt_Negated                 = UART_IS7816_BWT(0),  ///< Negated
      UartBlockWaitTimerInterrupt_AssertedWrite1ToClear   = UART_IS7816_BWT(1),  ///< Asserted/Write 1 to clear
   };

   /**
    * Initial Character Detected Interrupt
    * (uart_is7816_initd)
    *
    * Set when a valid initial character has been received
    */
   enum UartInitialCharacterDetectedInterrupt : uint8_t {
      UartInitialCharacterDetectedInterrupt_Negated                 = UART_IS7816_INITD(0),  ///< Negated
      UartInitialCharacterDetectedInterrupt_AssertedWrite1ToClear   = UART_IS7816_INITD(1),  ///< Asserted/Write 1 to clear
   };

   /**
    * Guard Timer Violated Interrupt
    * (uart_is7816_gtv)
    *
    * Set if a guard time (GT, CGT or BGT) has been violated
    */
   enum UartGuardTimerViolatedInterrupt : uint8_t {
      UartGuardTimerViolatedInterrupt_Negated                 = UART_IS7816_GTV(0),  ///< Negated
      UartGuardTimerViolatedInterrupt_AssertedWrite1ToClear   = UART_IS7816_GTV(1),  ///< Asserted/Write 1 to clear
   };

   /**
    * Transmit Threshold Exceeded Interrupt
    * (uart_is7816_txt)
    *
    * Set if the number of retries and corresponding NACKS &amp;gt; the value in the ET7816[TXTHRESHOLD] field
    */
   enum UartTransmitThresholdExceededInterrupt : uint8_t {
      UartTransmitThresholdExceededInterrupt_Negated                 = UART_IS7816_TXT(0),  ///< Negated
      UartTransmitThresholdExceededInterrupt_AssertedWrite1ToClear   = UART_IS7816_TXT(1),  ///< Asserted/Write 1 to clear
   };

   /**
    * Receive Threshold Exceeded Interrupt
    * (uart_is7816_rxt)
    *
    * Set if the number of consecutive NACKS generated as a result of parity errors and buffer overruns is &amp;gt;= the 
    * value in ET7816[RXTHRESHOLD]
    */
   enum UartReceiveThresholdExceededInterrupt : uint8_t {
      UartReceiveThresholdExceededInterrupt_Negated                 = UART_IS7816_RXT(0),  ///< Negated
      UartReceiveThresholdExceededInterrupt_AssertedWrite1ToClear   = UART_IS7816_RXT(1),  ///< Asserted/Write 1 to clear
   };

   /**
    * Wait Timer Interrupt (C7816[TTYPE] = 0)
    * (uart_wp7816t0_wi)
    *
    * 
    */
   enum UartWaitTimerInterruptC7816ttype0 : uint8_t {
   };

   /**
    * Character Wait Time Integer (C7816[TTYPE] = 1)
    * (uart_wp7816t1_cwi)
    *
    * 
    */
   enum UartCharacterWaitTimeIntegerC7816ttype : uint8_t {
   };

   /**
    * Block Wait Time Integer(C7816[TTYPE] = 1)
    * (uart_wp7816t1_bwi)
    *
    * 
    */
   enum UartBlockWaitTimeIntegerC7816ttype1 : uint8_t {
   };

   /**
    * Guard Band N
    * (uart_wn7816_gtn)
    *
    * 
    */
   enum UartGuardBandN : uint8_t {
   };

   /**
    * FD Multiplier
    * (uart_wf7816_gtfd)
    *
    * 
    */
   enum UartFdMultiplier : uint8_t {
   };

   /**
    * Transmit NACK Threshold
    * (uart_et7816_txthreshold)
    *
    * The value written to this field indicates the maximum number of failed attempts (NACKs) a transmitted character
    *  can have before the host processor is notified
    */
   enum UartTransmitNackThreshold : uint8_t {
   };

   /**
    * Receive NACK Threshold
    * (uart_et7816_rxthreshold)
    *
    * The value written to this field indicates the maximum number of consecutive NACKs generated as a result of a 
    * parity error or receiver buffer overruns before the host processor is notified
    */
   enum UartReceiveNackThreshold : uint8_t {
   };

   /**
    * Transmit Length
    * (uart_tl7816_tlen)
    *
    * 
    */
   enum UartTransmitLength : uint8_t {
   };

   /**
    * EN709
    * (uart_c6_en709)
    *
    * 
    */
   enum UartEn709 : uint8_t {
      UartEn709_Cea7091BIsDisabled   = UART_C6_EN709(0),  ///< CEA709.1-B is disabled
      UartEn709_Cea7091BIsEnabled    = UART_C6_EN709(1),  ///< CEA709.1-B is enabled
   };

   /**
    * CEA709.1-B Transmit Enable
    * (uart_c6_tx709)
    *
    * 
    */
   enum UartCea709 : uint8_t {
      UartCea709_Cea7091BTransmitterIsDisabled   = UART_C6_TX709(0),  ///< CEA709.1-B transmitter is disabled
      UartCea709_Cea7091BTransmitterIsEnabled    = UART_C6_TX709(1),  ///< CEA709.1-B transmitter is enabled
   };

   /**
    * Collision Enable
    * (uart_c6_ce)
    *
    * 
    */
   enum UartCollisionEnable : uint8_t {
      UartCollisionEnable_CollisionDetectFeatureIsDisabled   = UART_C6_CE(0),  ///< Collision detect feature is disabled
      UartCollisionEnable_CollisionDetectFeatureIsEnabled    = UART_C6_CE(1),  ///< Collision detect feature is enabled
   };

   /**
    * Collision Signal Polarity
    * (uart_c6_cp)
    *
    * 
    */
   enum UartCollisionSignalPolarity : uint8_t {
      UartCollisionSignalPolarity_CollisionSignalIsActiveLow    = UART_C6_CP(0),  ///< Collision signal is active low
      UartCollisionSignalPolarity_CollisionSignalIsActiveHigh   = UART_C6_CP(1),  ///< Collision signal is active high
   };

   /**
    * Packet Cycle Time Counter High
    * (uart_pcth_pcth)
    *
    * 
    */
   enum UartPacketCycleTimeCounterHigh : uint8_t {
   };

   /**
    * Packet Cycle Time Counter Low
    * (uart_pctl_pctl)
    *
    * 
    */
   enum UartPacketCycleTimeCounterLow : uint8_t {
   };

   /**
    * Beta1 Timer
    * (uart_b1t_b1t)
    *
    * 
    */
   enum UartBeta1Timer : uint8_t {
   };

   /**
    * Secondary Delay Timer High
    * (uart_sdth_sdth)
    *
    * 
    */
   enum UartSecondaryDelayTimerHigh : uint8_t {
   };

   /**
    * Secondary Delay Timer Low
    * (uart_sdtl_sdtl)
    *
    * 
    */
   enum UartSecondaryDelayTimerLow : uint8_t {
   };

   /**
    * Transmit Packet Length Register
    * (uart_tpl_tpl)
    *
    * 
    */
   enum UartTransmitPacketLengthRegister : uint8_t {
   };

   /**
    * Wbase Expired Interrupt Enable
    * (uart_ie_wbeie)
    *
    * 
    */
   enum UartWbaseExpiredInterruptEnable : uint8_t {
      UartWbaseExpiredInterruptEnable_InterruptIsDisabled   = UART_IE_WBEIE(0),  ///< Interrupt is disabled
      UartWbaseExpiredInterruptEnable_InterruptIsEnabled    = UART_IE_WBEIE(1),  ///< Interrupt is enabled
   };

   /**
    * Initial Sync Detection Interrupt Enable
    * (uart_ie_isdie)
    *
    * 
    */
   enum UartInitialSyncDetectionInterruptEnable : uint8_t {
      UartInitialSyncDetectionInterruptEnable_InterruptIsDisabled   = UART_IE_ISDIE(0),  ///< Interrupt is disabled
      UartInitialSyncDetectionInterruptEnable_InterruptIsEnabled    = UART_IE_ISDIE(1),  ///< Interrupt is enabled
   };

   /**
    * Packet Received Interrupt Enable
    * (uart_ie_prxie)
    *
    * 
    */
   enum UartPacketReceivedInterruptEnable : uint8_t {
      UartPacketReceivedInterruptEnable_InterruptIsDisabled   = UART_IE_PRXIE(0),  ///< Interrupt is disabled
      UartPacketReceivedInterruptEnable_InterruptIsEnabled    = UART_IE_PRXIE(1),  ///< Interrupt is enabled
   };

   /**
    * Packet Transmitted Interrupt Enable
    * (uart_ie_ptxie)
    *
    * 
    */
   enum UartPacketTransmittedInterruptEnable : uint8_t {
      UartPacketTransmittedInterruptEnable_InterruptIsDisabled   = UART_IE_PTXIE(0),  ///< Interrupt is disabled
      UartPacketTransmittedInterruptEnable_InterruptIsEnabled    = UART_IE_PTXIE(1),  ///< Interrupt is enabled
   };

   /**
    * Packet Cycle Timer Interrupt Enable
    * (uart_ie_pcteie)
    *
    * 
    */
   enum UartPacketCycleTimerInterruptEnable : uint8_t {
      UartPacketCycleTimerInterruptEnable_InterruptIsDisabled   = UART_IE_PCTEIE(0),  ///< Interrupt is disabled
      UartPacketCycleTimerInterruptEnable_InterruptIsEnabled    = UART_IE_PCTEIE(1),  ///< Interrupt is enabled
   };

   /**
    * Preamble Start Interrupt Enable
    * (uart_ie_psie)
    *
    * 
    */
   enum UartPreambleStartInterruptEnable : uint8_t {
      UartPreambleStartInterruptEnable_InterruptIsDisabled   = UART_IE_PSIE(0),  ///< Interrupt is disabled
      UartPreambleStartInterruptEnable_InterruptIsEnabled    = UART_IE_PSIE(1),  ///< Interrupt is enabled
   };

   /**
    * Transmission Fail Interrupt Enable
    * (uart_ie_txfie)
    *
    * 
    */
   enum UartTransmissionFailInterruptEnable : uint8_t {
      UartTransmissionFailInterruptEnable_InterruptIsDisabled   = UART_IE_TXFIE(0),  ///< Interrupt is disabled
      UartTransmissionFailInterruptEnable_InterruptIsEnabled    = UART_IE_TXFIE(1),  ///< Interrupt is enabled
   };

   /**
    * Preamble Error Flag
    * (uart_s3_pef)
    *
    * 
    */
   enum UartPreambleErrorFlag : uint8_t {
      UartPreambleErrorFlag_PreambleIsCorrect    = UART_S3_PEF(0),  ///< Preamble is correct
      UartPreambleErrorFlag_PreambleHasAnError   = UART_S3_PEF(1),  ///< Preamble has an error
   };

   /**
    * Wbase Expired Flag
    * (uart_s3_wbef)
    *
    * 
    */
   enum UartWbaseExpiredFlag : uint8_t {
      UartWbaseExpiredFlag_WbaseTimePeriodHasNotExpired                   = UART_S3_WBEF(0),  ///< WBASE time period has not expired
      UartWbaseExpiredFlag_WbaseTimePeriodHasExpiredAfterBeta1TimeSlots   = UART_S3_WBEF(1),  ///< WBASE time period has expired after beta1 time slots
   };

   /**
    * Initial Sync Detect
    * (uart_s3_isd)
    *
    * 
    */
   enum UartInitialSyncDetect : uint8_t {
      UartInitialSyncDetect_InitialSyncIsNotDetected   = UART_S3_ISD(0),  ///< Initial sync is not detected
      UartInitialSyncDetect_InitialSyncIsDetected      = UART_S3_ISD(1),  ///< Initial sync is detected
   };

   /**
    * Packet Received Flag
    * (uart_s3_prxf)
    *
    * 
    */
   enum UartPacketReceivedFlag : uint8_t {
      UartPacketReceivedFlag_PacketIsNotReceived   = UART_S3_PRXF(0),  ///< Packet is not received
      UartPacketReceivedFlag_PacketIsReceived      = UART_S3_PRXF(1),  ///< Packet is received
   };

   /**
    * Packet Transmitted Flag
    * (uart_s3_ptxf)
    *
    * 
    */
   enum UartPacketTransmittedFlag : uint8_t {
      UartPacketTransmittedFlag_PacketTransmissionIsNotComplete   = UART_S3_PTXF(0),  ///< Packet transmission is not complete
      UartPacketTransmittedFlag_PacketTransmissionIsComplete      = UART_S3_PTXF(1),  ///< Packet transmission is complete
   };

   /**
    * Packet Cycle Timer Expired Flag
    * (uart_s3_pctef)
    *
    * 
    */
   enum UartPacketCycleTimerExpiredFlag : uint8_t {
      UartPacketCycleTimerExpiredFlag_PacketCycleTimeHasNotExpired   = UART_S3_PCTEF(0),  ///< Packet cycle time has not expired
      UartPacketCycleTimerExpiredFlag_PacketCycleTimeHasExpired      = UART_S3_PCTEF(1),  ///< Packet cycle time has expired
   };

   /**
    * Preamble Start Flag
    * (uart_s3_psf)
    *
    * 
    */
   enum UartPreambleStartFlag : uint8_t {
      UartPreambleStartFlag_PreambleStartIsNotDetected   = UART_S3_PSF(0),  ///< Preamble start is not detected
      UartPreambleStartFlag_PreambleStartIsDetected      = UART_S3_PSF(1),  ///< Preamble start is detected
   };

   /**
    * Transmission Fail Flag
    * (uart_s3_txff)
    *
    * 
    */
   enum UartTransmissionFailFlag : uint8_t {
      UartTransmissionFailFlag_TransmissionContinuesNormally   = UART_S3_TXFF(0),  ///< Transmission continues normally
      UartTransmissionFailFlag_TransmissionHasFailed           = UART_S3_TXFF(1),  ///< Transmission has failed
   };

   /**
    * Initial Synchronization Fail Flag
    * (uart_s4_initf)
    *
    * 
    */
   enum UartInitialSynchronizationFailFlag : uint8_t {
      UartInitialSynchronizationFailFlag_InitialSynchronizationHasNotFailed   = UART_S4_INITF(0),  ///< Initial synchronization has not failed
      UartInitialSynchronizationFailFlag_InitialSynchronizationHasFailed      = UART_S4_INITF(1),  ///< Initial synchronization has failed
   };

   /**
    * CDET
    * (uart_s4_cdet)
    *
    * 
    */
   enum UartCdet : uint8_t {
      UartCdet_NoCollision                                = UART_S4_CDET(0),  ///< No collision
      UartCdet_CollisionOccurredDuringPreamble            = UART_S4_CDET(1),  ///< Collision occurred during preamble
      UartCdet_CollisionOccurredDuringData                = UART_S4_CDET(2),  ///< Collision occurred during data
      UartCdet_CollisionOccurredDuringLineCodeViolation   = UART_S4_CDET(3),  ///< Collision occurred during line code violation
   };

   /**
    * Improper Line Code Violation
    * (uart_s4_ilcv)
    *
    * 
    */
   enum UartImproperLineCodeViolation : uint8_t {
      UartImproperLineCodeViolation_LineCodeViolationReceivedIsProper                                    = UART_S4_ILCV(0),  ///< Line code violation received is proper
      UartImproperLineCodeViolation_LineCodeViolationReceivedIsImproper_ThatIs_LessThanThreeBitPeriods   = UART_S4_ILCV(1),  ///< Line code violation received is improper, that is, less than three bit periods
   };

   /**
    * Error
    * (uart_s4_fe)
    *
    * 
    */
   enum UartError : uint8_t {
      UartError_ReceivedPacketIsByteBound      = UART_S4_FE(0),  ///< Received packet is byte bound
      UartError_ReceivedPacketIsNotByteBound   = UART_S4_FE(1),  ///< Received packet is not byte bound
   };

class UartBasicInfo : public FormattedIO {

public:
   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   // Pointer to UART hardware instance
   volatile UART_Type * const uart;
   
   /**
    * Constructor
    *
    * @param uart UART hardware instance
    */
   UartBasicInfo(volatile UART_Type * uart) : uart(uart) {
   }
   
   /**
    * Get input clock frequency
    * (Individual to each peripheral)
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   virtual uint32_t getInputClockFrequency() const = 0;
   
   
   /**
    * Flush output i.e. wait while UART busy with Tx
    */
   virtual USBDM::FormattedIO& flushOutput() override {
   
      // Wait for Tx idle
      while ((uart->S1 & UART_S1_TC_MASK) == 0) {
         __asm__("nop");
      }
   
      return *this;
   }
   
   /**
    * Check if character is available
    *
    * @return true  Character available i.e. _readChar() will not block
    * @return false No character available
    */
   virtual bool _isCharAvailable() override {
      return (uart->S1 & UART_S1_RDRF_MASK);
   }
   
   /**
    * Receives a single character (blocking)
    *
    * @return Character received
    */
   virtual int _readChar() override {
   
      // Get status from UART
      uint32_t status;
      constexpr uint32_t ErrorFlags = UART_S1_FE_MASK|UART_S1_OR_MASK|UART_S1_PF_MASK|UART_S1_NF_MASK;
      do {
         // Get status from UART
         status = uart->S1;
         // Clear & ignore pending errors
         if ((status & (ErrorFlags)) != 0) {
            uart->S1 = uart->S1|ErrorFlags;
         }
         // Check for Rx buffer full
      } while ((status & UART_S1_RDRF_MASK) == 0);
      return uint8_t(uart->D);
   }
   
   /**
    * Writes a character (blocking)
    *
    * @param[in]  ch - character to send
    */
   virtual void _writeChar(char ch) override {
      while ((uart->S1 & UART_S1_TDRE_MASK) == 0) {
         // Wait for Tx buffer empty
         __asm__("nop");
      }
      uart->D = ch;
      if (ch=='\n') {
         _writeChar('\r');
      }
   }
   
   /**
    * Set Transmit complete action
    *
    * @param uartTxCompleteAction Enable interrupt on transmission complete
    */
   void setTransmitCompleteAction(UartTxCompleteAction uartTxCompleteAction) const {
      uart->C2 = (uart->C2 & ~UART_C2_TCIE_MASK) | uartTxCompleteAction;
   }

   /**
    * Set Idle line detect action
    *
    * @param uartIdleLineDetectAction Enable interrupt on tidele line detect
    */
   void setIdleLineDetectAction(UartIdleLineDetectAction uartIdleLineDetectAction) const {
      uart->C2 = (uart->C2 & ~UART_C2_ILIE_MASK) | uartIdleLineDetectAction;
   }

   /**
    * Clear UART status 

    * This includes:
    * - Idle detect flag
    * - Overrun flag
    * - Noise flag
    * - Framing error flag
    * - Parity error flag
    */
   void clearError() const {
   
      // Flags are cleared by reading status and then data
      (void)uart->S1;
      (void)uart->D;
   }
   
   /**
    * Set baud rate
    * (uart_baudrate, uart_c4_brfa_present)
    * (for UART with fractional divider)
    *
    * @param uart           Hardware instance pointer
    * @param clockFrequency Clock frequency
    * @param uartBaudRate Baud rate for UART
    *        Values available will depend on peripheral clock frequency
    */
   static void setBaudRate(
         volatile UART_Type *uart,
         uint32_t      clockFrequency,
         UartBaudRate uartBaudRate) {
   
      /*
       * Baudrate = clockFrequency / (OSR x (SBR + BRFD))
       * Fixed OSR = 16
       *
       * (OSR x (SBR + BRFA/32)) = clockFrequency/Baudrate
       * (SBR + BRFA/32) = clockFrequency/(Baudrate*OSR)
       * divisor = 32*SBR + BRFA = 2*clockFrequency/Baudrate
       * SBR  = divisor>>5
       * BRFA = divisor&0b11111
       */
      // Disable UART before changing registers
      uint8_t c2Value = uart->C2;
      uart->C2 = 0;
   
      // Rounded divider with 32-bit fraction
      uint32_t divisor = (2*clockFrequency+(uartBaudRate/2))/uartBaudRate;
      // Whole divider
      uint32_t sbr = divisor>>5;
      // Fractional (/32) divider to get closer to the baud rate
      uint32_t brfa = divisor&0b11111;
   
      // Set Baud rate register
      uart->BDH = (uart->BDH&~UART_BDH_SBR_MASK) | UART_BDH_SBR((sbr>>8));
      uart->BDL = UART_BDL_SBR(sbr);
      uart->C4  = (uart->C4&~UART_C4_BRFA_MASK) | UART_C4_BRFA(brfa);
   
      // Restore UART settings
      uart->C2 = c2Value;
   }
   
   /**
    * Set baud rate
    *
    * @param uartBaudRate Baud rate for UART
    *        Values available will depend on peripheral clock frequency
    */
   void setBaudRate(UartBaudRate uartBaudRate) {
   
      setBaudRate(uart, getInputClockFrequency(), uartBaudRate);
   }
   
   /**
    * Set Transmit empty DMA/Interrupt action
    * (uart_txempty_action)
    *
    * @param uartTxEmptyAction Enable transmit holding register empty DMA/Interrupt action
    */
   void setTransmitEmptyAction(UartTxEmptyAction uartTxEmptyAction) const {
   uart->C2 = (uart->C2 & ~UART_C2_TIE_MASK)   | uartTxEmptyAction;
   uart->C5 = (uart->C5 & ~UART_C5_TDMAS_MASK) | (uartTxEmptyAction>>8);
   }
   
   /**
    * Set for Receive full DMA/interrupt action
    * (uart_rxfull_action)
    *
    * @param uartRxFullAction Enable receive buffer full DMA/interrupt action
    */
   void setReceiveFullAction(UartRxFullAction uartRxFullAction) const {
   uart->C2 = (uart->C2 & ~UART_C2_RIE_MASK)   | uartRxFullAction;
   uart->C5 = (uart->C5 & ~UART_C5_RDMAS_MASK) | (uartRxFullAction>>8);
   }
   
   /**
    * Clear Status Flags
    * This includes all flags
    * (uart_s1_stat)
    */
   void clearStatusFlags() const {
   
      // Flags are w1c
      uart->S1 = uart->S1|uint32_t(UartStatusFlag::AllFlags);
   }
   
   /**
    * Clear selected Status Flags
    * (uart_s1_stat)
    *
    * @param uartStatusFlag These masks may be used to test or modify the status flags
    */
   void clearStatusFlags(UartStatusFlag uartStatusFlag) const {
      // Flags are w1c
      uart->S1 = uart->S1|uint32_t(uartStatusFlag);
   }
   
   /**
    * Get Status Flags
    * (uart_s1_stat)
    *
    * @return These masks may be used to test or modify the status flags
    */
   UartStatusFlag getStatusFlags() const {
      return UartStatusFlag(uart->S1&uint32_t(UartStatusFlag::AllFlags));
   }
   
   /**
    * Set Read receive data or write transmit data
    * (uart_d_rt)
    *
    * @param value Reads return the contents of the read-only receive data buffer and 
    *        writes go to the write-only transmit data buffer. 
    *        Reads and writes of this register are also involved in the automatic flag
    *        clearing mechanisms for the UART status flags
    */
   void setTransmitData(uint8_t value) const {
      uart->D = (uart->D&~UART_D_RT_MASK) | UART_D_RT(value);
   }
   
   /**
    * Get Read receive data or write transmit data
    * (uart_d_rt)
    *
    * @return Reads return the contents of the read-only receive data buffer and 
    *        writes go to the write-only transmit data buffer. 
    *        Reads and writes of this register are also involved in the automatic flag
    *        clearing mechanisms for the UART status flags
    */
   uint8_t getReceiveData() const {
      return uint8_t((uart->D&UART_D_RT_MASK)>>UART_D_RT_SHIFT);
   }
   
   /**
    * Class used to do initialisation of the Uart
    *
    * This class has a templated constructor that accepts various values.
    * Parameters available may vary with device - see Uart0::DefaultInitValue for relevant example.
    * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Uart0::Init uart0Init {
    *
    *   // Setup values
XXXXXXXXXXXXXXXXXXXXXX
    *
    *   // Optional base value to start with (must be last parameter)
    *   Uart0::DefaultInitValue   // Used as base value modified by above
    * };
    *
    * // Initialise Uart0 from values specified above
    * Uart0::configure(uart0Init)
    * @endcode
    */
   class Init {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr Init(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      // UART baud rate (uart_baudrate)
      UartBaudRate baudrate = UartBaudRate(0);

      // LIN break detect action (uart_bdh_lbkdie)
      // RxD input active edge action (uart_bdh_rxedgie)
      uint8_t bdh = 0;

      // Loop Mode Select (uart_c1_loops)
      // Stops in Wait Mode (uart_c1_uartswai)
      // Receiver Source Select (uart_c1_rsrc)
      // 9-Bit or 8-Bit Mode Select (uart_c1_m)
      // Receiver Wakeup Method Select (uart_c1_wake)
      // Idle Line Type Select (uart_c1_ilt)
      // Parity Enable (uart_c1_pe)
      // Parity Type (uart_c1_pt)
      uint8_t c1 = 0;

      // Transmit complete action (uart_c2_tcie)
      // Idle line detect action (uart_c2_ilie)
      // Transmitter Enable (uart_c2_te)
      // Receiver Enable (uart_c2_re)
      // Receiver Wakeup Control (uart_c2_rwu)
      // Send Break (uart_c2_sbk)
      uint8_t c2 = 0;

      // LIN Break Detect Interrupt Flag (uart_s2_lbkdif)
      // RxD Pin Active Edge Interrupt Flag (uart_s2_rxedgif)
      // Most Significant Bit First (uart_s2_msbf)
      // Receive Data Inversion (uart_s2_rxinv)
      // Receive Wakeup Idle Detect (uart_s2_rwuid)
      // Break Transmit Character Length (uart_s2_brk13)
      // LIN Break Detection Enable (uart_s2_lbkde)
      uint8_t s2 = 0;

      // Transmit Bit 8 (uart_c3_t8)
      // Transmitter Pin Direction in Single-Wire mode (uart_c3_txdir)
      // Transmit Data Inversion (uart_c3_txinv)
      // Overrun Error Interrupt Enable (uart_c3_orie)
      // Noise Error Interrupt Enable (uart_c3_neie)
      // Framing Error Interrupt Enable (uart_c3_feie)
      // Parity Error Interrupt Enable (uart_c3_peie)
      uint8_t c3 = 0;

      // Match Address Mode Enable 1 (uart_c4_maen1)
      // Match Address Mode Enable 2 (uart_c4_maen2)
      // 10-bit Mode select (uart_c4_m10)
      // Baud Rate Fine Adjust (uart_c4_brfa)
      uint8_t c4 = 0;

      // Transmitter Interrupt/DMA Select (uart_c5_tdmas)
      // Receiver Full Interrupt/DMA Select (uart_c5_rdmas)
      uint8_t c5 = 0;

      // Receiver request-to-send enable (uart_modem_rxrtse)
      // Transmitter request-to-send polarity (uart_modem_txrtspol)
      // Transmitter request-to-send enable (uart_modem_txrtse)
      // Transmitter clear-to-send enable (uart_modem_txctse)
      uint8_t modem = 0;

      // Infrared enable (uart_ir_iren)
      // Transmitter narrow pulse (uart_ir_tnp)
      uint8_t ir = 0;

      // Transmit FIFO Enable (uart_pfifo_txfe)
      // Receive FIFO Enable (uart_pfifo_rxfe)
      uint8_t pfifo = 0;

      // Transmit FIFO/Buffer Flush (uart_cfifo_txflush)
      // Receive FIFO/Buffer Flush (uart_cfifo_rxflush)
      // Receive FIFO Overflow Interrupt Enable (uart_cfifo_rxofe)
      // Transmit FIFO Overflow Interrupt Enable (uart_cfifo_txofe)
      // Receive FIFO Underflow Interrupt Enable (uart_cfifo_rxufe)
      uint8_t cfifo = 0;

      // Receiver Buffer Overflow Flag (uart_sfifo_rxof)
      // Transmitter Buffer Overflow Flag (uart_sfifo_txof)
      // Receiver Buffer Underflow Flag (uart_sfifo_rxuf)
      uint8_t sfifo = 0;

      // Transmit Watermark (uart_twfifo_txwater)
      uint8_t twfifo = 0;

      // Receive Watermark (uart_rwfifo_rxwater)
      uint8_t rwfifo = 1;

      // Generate NACK on Overflow (uart_c7816_onack)
      // Generate NACK on Error (uart_c7816_anack)
      // Detect Initial Character (uart_c7816_init)
      // Transfer Type (uart_c7816_ttype)
      // ISO-7816 Functionality Enabled (uart_c7816_iso_7816e)
      uint8_t c7816 = 0;

      // Wait Timer Interrupt Enable (uart_ie7816_wte)
      // Character Wait Timer (CWT) Interrupt Enable (uart_ie7816_cwte)
      // Block Wait Timer (BWT) Interrupt Enable (uart_ie7816_bwte)
      // Initial Character Detected (INITD) Interrupt Enable (uart_ie7816_initde)
      // Guard Timer Violated (GTV) Interrupt Enable (uart_ie7816_gtve)
      // Transmit Threshold Exceeded (TXT) Interrupt Enable (uart_ie7816_txte)
      // Receive Threshold Exceeded Interrupt Enable (uart_ie7816_rxte)
      uint8_t ie7816 = 0;

      // Wait Timer Interrupt (uart_is7816_wt)
      // Character Wait Timer Interrupt (uart_is7816_cwt)
      // Block Wait Timer Interrupt (uart_is7816_bwt)
      // Initial Character Detected Interrupt (uart_is7816_initd)
      // Guard Timer Violated Interrupt (uart_is7816_gtv)
      // Transmit Threshold Exceeded Interrupt (uart_is7816_txt)
      // Receive Threshold Exceeded Interrupt (uart_is7816_rxt)
      uint8_t is7816 = 0;

      // Wait Timer Interrupt (C7816[TTYPE] = 0) (uart_wp7816t0_wi)
      uint8_t wp7816t0 = 0;

      // Character Wait Time Integer (C7816[TTYPE] = 1) (uart_wp7816t1_cwi)
      // Block Wait Time Integer(C7816[TTYPE] = 1) (uart_wp7816t1_bwi)
      uint8_t wp7816t1 = 0;

      // Guard Band N (uart_wn7816_gtn)
      uint8_t wn7816 = 0;

      // FD Multiplier (uart_wf7816_gtfd)
      uint8_t wf7816 = 0;

      // Transmit NACK Threshold (uart_et7816_txthreshold)
      // Receive NACK Threshold (uart_et7816_rxthreshold)
      uint8_t et7816 = 0;

      // Transmit Length (uart_tl7816_tlen)
      uint8_t tl7816 = 0;

      // EN709 (uart_c6_en709)
      // CEA709.1-B Transmit Enable (uart_c6_tx709)
      // Collision Enable (uart_c6_ce)
      // Collision Signal Polarity (uart_c6_cp)
      uint8_t c6 = 0;

      // Packet Cycle Time Counter High (uart_pcth_pcth)
      uint8_t pcth = 0;

      // Packet Cycle Time Counter Low (uart_pctl_pctl)
      uint8_t pctl = 0;

      // Beta1 Timer (uart_b1t_b1t)
      uint8_t b1t = 0;

      // Secondary Delay Timer High (uart_sdth_sdth)
      uint8_t sdth = 0;

      // Secondary Delay Timer Low (uart_sdtl_sdtl)
      uint8_t sdtl = 0;

      // Transmit Packet Length Register (uart_tpl_tpl)
      uint8_t tpl = 0;

      // Wbase Expired Interrupt Enable (uart_ie_wbeie)
      // Initial Sync Detection Interrupt Enable (uart_ie_isdie)
      // Packet Received Interrupt Enable (uart_ie_prxie)
      // Packet Transmitted Interrupt Enable (uart_ie_ptxie)
      // Packet Cycle Timer Interrupt Enable (uart_ie_pcteie)
      // Preamble Start Interrupt Enable (uart_ie_psie)
      // Transmission Fail Interrupt Enable (uart_ie_txfie)
      uint8_t ie = 0;

      // Preamble Error Flag (uart_s3_pef)
      // Wbase Expired Flag (uart_s3_wbef)
      // Packet Received Flag (uart_s3_prxf)
      // Packet Transmitted Flag (uart_s3_ptxf)
      // Packet Cycle Timer Expired Flag (uart_s3_pctef)
      // Preamble Start Flag (uart_s3_psf)
      // Transmission Fail Flag (uart_s3_txff)
      uint8_t s3 = 0;

      // CDET (uart_s4_cdet)
      // Improper Line Code Violation (uart_s4_ilcv)
      // Error (uart_s4_fe)
      uint8_t s4 = 0;

      /**
       * Constructor for Transmit empty DMA/Interrupt action
       * (uart_txempty_action)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTxEmptyAction Enable transmit holding register empty DMA/Interrupt action
       */
      template <typename... Types>
      constexpr Init(UartTxEmptyAction uartTxEmptyAction, Types... rest) : Init(rest...) {
      c2 = (c2 & ~UART_C2_TIE_MASK)   | uartTxEmptyAction;
      c5 = (c5 & ~UART_C5_TDMAS_MASK) | (uartTxEmptyAction>>8);
      }
   
      /**
       * Constructor for Receive full DMA/interrupt action
       * (uart_rxfull_action)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartRxFullAction Enable receive buffer full DMA/interrupt action
       */
      template <typename... Types>
      constexpr Init(UartRxFullAction uartRxFullAction, Types... rest) : Init(rest...) {
      c2 = (c2 & ~UART_C2_RIE_MASK)   | uartRxFullAction;
      c5 = (c5 & ~UART_C5_RDMAS_MASK) | (uartRxFullAction>>8);
      }
   
      /**
       * Constructor for UART baud rate
       * (uart_baudrate)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartBaudRate Baud rate for UART
       *        Values available will depend on peripheral clock frequency
       */
      template <typename... Types>
      constexpr Init(UartBaudRate uartBaudRate, Types... rest) : Init(rest...) {
   
         baudrate = uartBaudRate;
      }
   
      /**
       * Constructor for LIN break detect action
       * (uart_bdh_lbkdie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartLinBreakAction Enables the LIN break detect flag, LBKDIF, to generate interrupt requests based on the state of LBKDDMAS.
       */
      template <typename... Types>
      constexpr Init(UartLinBreakAction uartLinBreakAction, Types... rest) : Init(rest...) {
   
         bdh = (bdh&~UART_BDH_LBKDIE_MASK) | uartLinBreakAction;
      }
   
      /**
       * Constructor for RxD input active edge action
       * (uart_bdh_rxedgie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartRxdActiveEdgeAction Enables the receive input active edge, RXEDGIF, to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartRxdActiveEdgeAction uartRxdActiveEdgeAction, Types... rest) : Init(rest...) {
   
         bdh = (bdh&~UART_BDH_RXEDGIE_MASK) | uartRxdActiveEdgeAction;
      }
   
      /**
       * Constructor for Loop Mode Select
       * (uart_c1_loops)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartLoopModeSelect Controls loop mode where transmitter output is internally connected to receiver input. [See also RSRC]
       */
      template <typename... Types>
      constexpr Init(UartLoopModeSelect uartLoopModeSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_LOOPS_MASK) | uartLoopModeSelect;
      }
   
      /**
       * Constructor for Stops in Wait Mode
       * (uart_c1_uartswai)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartStopsInWaitMode Controls action in Wait Mode
       */
      template <typename... Types>
      constexpr Init(UartStopsInWaitMode uartStopsInWaitMode, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_UARTSWAI_MASK) | uartStopsInWaitMode;
      }
   
      /**
       * Constructor for Receiver Source Select
       * (uart_c1_rsrc)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiverSourceSelect Select between loop-back and single-wire mode
       */
      template <typename... Types>
      constexpr Init(UartReceiverSourceSelect uartReceiverSourceSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_RSRC_MASK) | uartReceiverSourceSelect;
      }
   
      /**
       * Constructor for 9-Bit or 8-Bit Mode Select
       * (uart_c1_m)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uart9BitOr8BitModeSelect Selects between 8-bit and 9-bit modes
       *        This field must be set when C7816[ISO_7816E] is set/enabled.
       */
      template <typename... Types>
      constexpr Init(Uart9BitOr8BitModeSelect uart9BitOr8BitModeSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_M_MASK) | uart9BitOr8BitModeSelect;
      }
   
      /**
       * Constructor for Receiver Wakeup Method Select
       * (uart_c1_wake)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiverWakeupMethodSelect Determines which condition wakes the UART:
       *        - Address mark in the most significant bit position of a received data character, or
       *        - An idle condition on the receive pin input signal.
       */
      template <typename... Types>
      constexpr Init(UartReceiverWakeupMethodSelect uartReceiverWakeupMethodSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_WAKE_MASK) | uartReceiverWakeupMethodSelect;
      }
   
      /**
       * Constructor for Idle Line Type Select
       * (uart_c1_ilt)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartIdleLineTypeSelect Determines if idle character bit count starts after start bit or stop bit
       */
      template <typename... Types>
      constexpr Init(UartIdleLineTypeSelect uartIdleLineTypeSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_ILT_MASK) | uartIdleLineTypeSelect;
      }
   
      /**
       * Constructor for Parity Enable
       * (uart_c1_pe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartParityEnable Enables the parity function. When parity is enabled, parity function inserts a parity bit
       *        in the bit position immediately preceding the stop bit.
       *        This field must be set when C7816[ISO_7816E] is set/enabled.
       */
      template <typename... Types>
      constexpr Init(UartParityEnable uartParityEnable, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_PE_MASK) | uartParityEnable;
      }
   
      /**
       * Constructor for Parity Type
       * (uart_c1_pt)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartParityType Determines whether the UART generates and checks for even parity or odd parity.
       *        With even parity, an even number of 1s clears the parity bit and an odd number of
       *        1s sets the parity bit.
       *        With odd parity, an odd number of 1s clears the parity bit and an even number of 1s
       *        sets the parity bit. 
       *        This field must be cleared when C7816[ISO_7816E] is set/enabled.
       */
      template <typename... Types>
      constexpr Init(UartParityType uartParityType, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_PT_MASK) | uartParityType;
      }
   
      /**
       * Constructor for Transmit complete action
       * (uart_c2_tcie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTxCompleteAction Enable interrupt on transmission complete
       */
      template <typename... Types>
      constexpr Init(UartTxCompleteAction uartTxCompleteAction, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_TCIE_MASK) | uartTxCompleteAction;
      }
   
      /**
       * Constructor for Idle line detect action
       * (uart_c2_ilie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartIdleLineDetectAction Enable interrupt on tidele line detect
       */
      template <typename... Types>
      constexpr Init(UartIdleLineDetectAction uartIdleLineDetectAction, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_ILIE_MASK) | uartIdleLineDetectAction;
      }
   
      /**
       * Constructor for Transmitter Enable
       * (uart_c2_te)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitterEnable Enables the UART transmitter.
       */
      template <typename... Types>
      constexpr Init(UartTransmitterEnable uartTransmitterEnable, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_TE_MASK) | uartTransmitterEnable;
      }
   
      /**
       * Constructor for Receiver Enable
       * (uart_c2_re)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiverEnable Enables the UART receiver.
       */
      template <typename... Types>
      constexpr Init(UartReceiverEnable uartReceiverEnable, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_RE_MASK) | uartReceiverEnable;
      }
   
      /**
       * Constructor for Receiver Wakeup Control
       * (uart_c2_rwu)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiverWakeupControl Setting RWU enables the wakeup function and inhibits further receiver interrupt requests.
       *        Normally, hardware wakes the receiver by automatically clearing RWU
       */
      template <typename... Types>
      constexpr Init(UartReceiverWakeupControl uartReceiverWakeupControl, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_RWU_MASK) | uartReceiverWakeupControl;
      }
   
      /**
       * Constructor for Send Break
       * (uart_c2_sbk)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartSendBreak Toggling SBK sends one break character. Toggling implies clearing the SBK field before
       *        the break character has finished transmitting.
       *        As long as SBK is set, the transmitter continues to send complete break characters.                Number of 
       *        bits used:
       *        - 10, 11, or 12 logic 0s if S2[BRK13] is cleared
       *        - 13 or 14 logic 0s if S2[BRK13] is set.
       *        This field must be cleared when C7816[ISO_7816E] is set.
       */
      template <typename... Types>
      constexpr Init(UartSendBreak uartSendBreak, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_SBK_MASK) | uartSendBreak;
      }
   
      /**
       * Constructor for LIN Break Detect Interrupt Flag
       * (uart_s2_lbkdif)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartLinBreakDetectInterruptFlag LBKDIF is set when LBKDE is set and a LIN break character is detected on the receiver input.
       *        LBKDIF is cleared by writing a 1 to it
       */
      template <typename... Types>
      constexpr Init(UartLinBreakDetectInterruptFlag uartLinBreakDetectInterruptFlag, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_LBKDIF_MASK) | uartLinBreakDetectInterruptFlag;
      }
   
      /**
       * Constructor for RxD Pin Active Edge Interrupt Flag
       * (uart_s2_rxedgif)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartRxdPinActiveEdgeInterruptFlag RXEDGIF is set when an active edge occurs on the RxD pin.
       *        The active edge is falling if RXINV = 0, and rising if RXINV=1.
       *        RXEDGIF is cleared by writing a 1 to it
       */
      template <typename... Types>
      constexpr Init(UartRxdPinActiveEdgeInterruptFlag uartRxdPinActiveEdgeInterruptFlag, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_RXEDGIF_MASK) | uartRxdPinActiveEdgeInterruptFlag;
      }
   
      /**
       * Constructor for Most Significant Bit First
       * (uart_s2_msbf)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartMostSignificantBitFirst Setting this field reverses the order of the bits that are transmitted and received on the wire
       */
      template <typename... Types>
      constexpr Init(UartMostSignificantBitFirst uartMostSignificantBitFirst, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_MSBF_MASK) | uartMostSignificantBitFirst;
      }
   
      /**
       * Constructor for Receive Data Inversion
       * (uart_s2_rxinv)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveDataInversion Setting this field reverses the polarity of the received data input
       */
      template <typename... Types>
      constexpr Init(UartReceiveDataInversion uartReceiveDataInversion, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_RXINV_MASK) | uartReceiveDataInversion;
      }
   
      /**
       * Constructor for Receive Wakeup Idle Detect
       * (uart_s2_rwuid)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveWakeupIdleDetect When RWU is set and WAKE is cleared, this field controls whether the idle character that wakes the             
       *         receiver sets S1[IDLE]
       */
      template <typename... Types>
      constexpr Init(UartReceiveWakeupIdleDetect uartReceiveWakeupIdleDetect, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_RWUID_MASK) | uartReceiveWakeupIdleDetect;
      }
   
      /**
       * Constructor for Break Transmit Character Length
       * (uart_s2_brk13)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartBreakTransmitCharacterLength Determines whether the transmit break character is 10, 11, or 12 bits long, or 13 or 14 bits long
       */
      template <typename... Types>
      constexpr Init(UartBreakTransmitCharacterLength uartBreakTransmitCharacterLength, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_BRK13_MASK) | uartBreakTransmitCharacterLength;
      }
   
      /**
       * Constructor for LIN Break Detection Enable
       * (uart_s2_lbkde)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartLinBreakDetectionEnable Enables LIN break character detection.
       *        While LBKDE is set, S1[RDRF], S1[NF], S1[FE], and S1[PF] are prevented from setting
       */
      template <typename... Types>
      constexpr Init(UartLinBreakDetectionEnable uartLinBreakDetectionEnable, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_LBKDE_MASK) | uartLinBreakDetectionEnable;
      }
   
      /**
       * Constructor for Transmit Bit 8
       * (uart_c3_t8)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitBit8 T8 is the ninth data bit transmitted when the UART is configured for 9-bit data format,
       *        that is, if C1[M] = 1 or C4[M10] = 1.
       *        NOTE: If the value of T8 is the same as in the previous transmission, T8 does not
       *        have to be rewritten. The same value is transmitted until T8 is rewritten.
       */
      template <typename... Types>
      constexpr Init(UartTransmitBit8 uartTransmitBit8, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_T8_MASK) | uartTransmitBit8;
      }
   
      /**
       * Constructor for Transmitter Pin Direction in Single-Wire mode
       * (uart_c3_txdir)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitterPinDirectionInSingleWire Determines whether the TXD pin is used as an input or output in the single-wire mode of operation.
       *        This field is relevant only to the single wire mode. When C7816[ISO7816E] is set/enabled and
       *        C7816[TTYPE] = 1, this field is automatically cleared after the requested block is transmitted.
       *        This condition is detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
       *        Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is being transmitted,
       *        the hardware automatically overrides this field as needed. In this situation, TXDIR does not reflect
       *        the temporary state associated with the NACK.
       */
      template <typename... Types>
      constexpr Init(UartTransmitterPinDirectionInSingleWire uartTransmitterPinDirectionInSingleWire, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_TXDIR_MASK) | uartTransmitterPinDirectionInSingleWire;
      }
   
      /**
       * Constructor for Transmit Data Inversion
       * (uart_c3_txinv)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitDataInversion Setting this field reverses the polarity of the transmitted data output.
       *        In NRZ format, a one is represented by a mark and a zero is represented by a
       *        space for normal polarity, and the opposite for inverted polarity.
       *        In IrDA format, a zero is represented by short high pulse in the middle of a 
       *        bit time remaining idle low for a one for normal polarity, and a zero is represented
       *        by short low pulse in the middle of a bit time remaining idle high for a one for
       *        inverted polarity.This field is automatically set when C7816[INIT] and C7816[ISO7816E]
       *        are enabled and an initial character is detected in T = 0 protocol mode.
       *        NOTE: Setting TXINV inverts all transmitted values, including idle, break, start, and stop bits.
       *        In loop mode, if TXINV is set, the receiver gets the transmit inversion bit when RXINV is disabled.
       *        When C7816[ISO7816E] is set/enabled then only the transmitted data bits and parity bit are inverted.
       */
      template <typename... Types>
      constexpr Init(UartTransmitDataInversion uartTransmitDataInversion, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_TXINV_MASK) | uartTransmitDataInversion;
      }
   
      /**
       * Constructor for Overrun Error Interrupt Enable
       * (uart_c3_orie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartOverrunErrorInterruptEnable Enables the overrun error flag, S1[OR], to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartOverrunErrorInterruptEnable uartOverrunErrorInterruptEnable, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_ORIE_MASK) | uartOverrunErrorInterruptEnable;
      }
   
      /**
       * Constructor for Noise Error Interrupt Enable
       * (uart_c3_neie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartNoiseErrorInterruptEnable Enables the noise flag, S1[NF], to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartNoiseErrorInterruptEnable uartNoiseErrorInterruptEnable, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_NEIE_MASK) | uartNoiseErrorInterruptEnable;
      }
   
      /**
       * Constructor for Framing Error Interrupt Enable
       * (uart_c3_feie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartFramingErrorInterruptEnable Enables the framing error flag, S1[FE], to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartFramingErrorInterruptEnable uartFramingErrorInterruptEnable, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_FEIE_MASK) | uartFramingErrorInterruptEnable;
      }
   
      /**
       * Constructor for Parity Error Interrupt Enable
       * (uart_c3_peie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartParityErrorInterruptEnable Enables the parity error flag, S1[PF], to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartParityErrorInterruptEnable uartParityErrorInterruptEnable, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_PEIE_MASK) | uartParityErrorInterruptEnable;
      }
   
      /**
       * Constructor for Match Address Mode Enable 1
       * (uart_c4_maen1)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartMatchAddressModeEnable1 When enabled, all data received with the most significant bit cleared, is discarded.
       *        All data received with the most significant bit set, is compared with contents of MA1 register.
       *        If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer.
       *        This field must be cleared when C7816[ISO7816E] is set/enabled.
       */
      template <typename... Types>
      constexpr Init(UartMatchAddressModeEnable1 uartMatchAddressModeEnable1, Types... rest) : Init(rest...) {
   
         c4 = (c4&~UART_C4_MAEN1_MASK) | uartMatchAddressModeEnable1;
      }
   
      /**
       * Constructor for Match Address Mode Enable 2
       * (uart_c4_maen2)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartMatchAddressModeEnable2 When enabled, all data received with the most significant bit cleared, is discarded.
       *        All data received with the most significant bit set, is compared with contents of MA1 register.
       *        If no match occurs, the data is discarded. If match occurs, data is transferred to the data buffer.
       *        This field must be cleared when C7816[ISO7816E] is set/enabled.
       */
      template <typename... Types>
      constexpr Init(UartMatchAddressModeEnable2 uartMatchAddressModeEnable2, Types... rest) : Init(rest...) {
   
         c4 = (c4&~UART_C4_MAEN2_MASK) | uartMatchAddressModeEnable2;
      }
   
      /**
       * Constructor for 10-bit Mode select
       * (uart_c4_m10)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uart10BitModeSelect Causes a tenth, non-memory mapped bit to be part of the serial transmission.
       *        This tenth bit is generated and interpreted as a parity bit.
       *        The M10 field does not affect the LIN send or detect break behavior.
       *        If M10 is set, then both C1[M] and C1[PE] must also be set.
       *        This field must be cleared when C7816[ISO7816E] is set/enabled.
       */
      template <typename... Types>
      constexpr Init(Uart10BitModeSelect uart10BitModeSelect, Types... rest) : Init(rest...) {
   
         c4 = (c4&~UART_C4_M10_MASK) | uart10BitModeSelect;
      }
   
      /**
       * Constructor for Baud Rate Fine Adjust
       * (uart_c4_brfa)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartBaudRateFineAdjust This bit field is used to add more timing resolution to the average baud frequency, in increments of 1/32
       */
      template <typename... Types>
      constexpr Init(UartBaudRateFineAdjust uartBaudRateFineAdjust, Types... rest) : Init(rest...) {
   
         c4 = (c4&~UART_C4_BRFA_MASK) | UART_C4_BRFA(uartBaudRateFineAdjust);
      }
   
      /**
       * Constructor for Transmitter Interrupt/DMA Select
       * (uart_c5_tdmas)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTxEmptyDma Selects between DMA and interrupt requests when C2[TIE] and S1[TDRE] flags are set
       */
      template <typename... Types>
      constexpr Init(UartTxEmptyDma uartTxEmptyDma, Types... rest) : Init(rest...) {
   
         c5 = (c5&~UART_C5_TDMAS_MASK) | uartTxEmptyDma;
      }
   
      /**
       * Constructor for Receiver Full Interrupt/DMA Select
       * (uart_c5_rdmas)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartRxFullDma Selects between DMA and interrupt requests when C2[RIE] and S1[RDRF] flags are set
       */
      template <typename... Types>
      constexpr Init(UartRxFullDma uartRxFullDma, Types... rest) : Init(rest...) {
   
         c5 = (c5&~UART_C5_RDMAS_MASK) | uartRxFullDma;
      }
   
      /**
       * Constructor for Receiver request-to-send enable
       * (uart_modem_rxrtse)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiverRequestToSendEnable If enabled RTS is deasserted if the number of characters in the receiver data register (FIFO) is
       *        equal to or greater than RWFIFO[RXWATER].
       *        RTS is asserted when the number of characters in the receiver data register (FIFO) is less than RWFIFO[RXWATER]
       */
      template <typename... Types>
      constexpr Init(UartReceiverRequestToSendEnable uartReceiverRequestToSendEnable, Types... rest) : Init(rest...) {
   
         modem = (modem&~UART_MODEM_RXRTSE_MASK) | uartReceiverRequestToSendEnable;
      }
   
      /**
       * Constructor for Transmitter request-to-send polarity
       * (uart_modem_txrtspol)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitterRequestToSendPolarity Controls the polarity of the transmitter RTS.
       *        TXRTSPOL does not affect the polarity of the receiver RTS.
       *        RTS will remain negated in the active low state unless TXRTSE is set.
       */
      template <typename... Types>
      constexpr Init(UartTransmitterRequestToSendPolarity uartTransmitterRequestToSendPolarity, Types... rest) : Init(rest...) {
   
         modem = (modem&~UART_MODEM_TXRTSPOL_MASK) | uartTransmitterRequestToSendPolarity;
      }
   
      /**
       * Constructor for Transmitter request-to-send enable
       * (uart_modem_txrtse)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitterRequestToSendEnable If enabled, when a character is placed into an empty transmitter data buffer(FIFO),
       *        RTS asserts one bit time before the start bit is transmitted. 
       *        RTS deasserts one bit time after all characters in the transmitter data buffer(FIFO)
       *        and shift register are completely sent, including the last stop bit
       */
      template <typename... Types>
      constexpr Init(UartTransmitterRequestToSendEnable uartTransmitterRequestToSendEnable, Types... rest) : Init(rest...) {
   
         modem = (modem&~UART_MODEM_TXRTSE_MASK) | uartTransmitterRequestToSendEnable;
      }
   
      /**
       * Constructor for Transmitter clear-to-send enable
       * (uart_modem_txctse)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitterClearToSendEnable If enabled, the transmitter checks the state of CTS each time it is ready to send a character. 
       *        If CTS is asserted, the character is sent.
       *        If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed
       *        until CTS is asserted.
       *        Changes in CTS as a character is being sent do not affect its transmission
       */
      template <typename... Types>
      constexpr Init(UartTransmitterClearToSendEnable uartTransmitterClearToSendEnable, Types... rest) : Init(rest...) {
   
         modem = (modem&~UART_MODEM_TXCTSE_MASK) | uartTransmitterClearToSendEnable;
      }
   
      /**
       * Constructor for Infrared enable
       * (uart_ir_iren)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartInfraredEnable Enables/disables the infrared modulation/demodulation.
       */
      template <typename... Types>
      constexpr Init(UartInfraredEnable uartInfraredEnable, Types... rest) : Init(rest...) {
   
         ir = (ir&~UART_IR_IREN_MASK) | uartInfraredEnable;
      }
   
      /**
       * Constructor for Transmitter narrow pulse
       * (uart_ir_tnp)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitterNarrowPulse Enables whether the UART transmits a 1/16, 3/16, 1/32, or 1/4 narrow pulse.
       */
      template <typename... Types>
      constexpr Init(UartTransmitterNarrowPulse uartTransmitterNarrowPulse, Types... rest) : Init(rest...) {
   
         ir = (ir&~UART_IR_TNP_MASK) | uartTransmitterNarrowPulse;
      }
   
      /**
       * Constructor for Transmit FIFO Enable
       * (uart_pfifo_txfe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitFifoEnable When this field is set, the built in FIFO structure for the transmit buffer is enabled.
       *        The size of the FIFO structure is indicated by TXFIFOSIZE.
       *        If this field is not set, the transmit buffer operates as a FIFO of depth one dataword
       *        regardless of the value in TXFIFOSIZE. 
       *        Both C2[TE] and C2[RE] must be cleared prior to changing this field. Additionally,
       *        TXFLUSH and RXFLUSH commands must be issued immediately after changing this field.
       */
      template <typename... Types>
      constexpr Init(UartTransmitFifoEnable uartTransmitFifoEnable, Types... rest) : Init(rest...) {
   
         pfifo = (pfifo&~UART_PFIFO_TXFE_MASK) | uartTransmitFifoEnable;
      }
   
      /**
       * Constructor for Receive FIFO Enable
       * (uart_pfifo_rxfe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveFifoEnable When this field is set, the built in FIFO structure for the receive buffer is enabled.
       *        The size of the FIFO structure is indicated by the RXFIFOSIZE field.
       *        If this field is not set, the receive buffer operates as a FIFO of depth one dataword
       *        regardless of the value in RXFIFOSIZE.
       *        Both C2[TE] and C2[RE] must be cleared prior to changing this field.
       *        Additionally, TXFLUSH and RXFLUSH commands must be issued immediately after changing this field.
       */
      template <typename... Types>
      constexpr Init(UartReceiveFifoEnable uartReceiveFifoEnable, Types... rest) : Init(rest...) {
   
         pfifo = (pfifo&~UART_PFIFO_RXFE_MASK) | uartReceiveFifoEnable;
      }
   
      /**
       * Constructor for Transmit FIFO/Buffer Flush
       * (uart_cfifo_txflush)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitFifo_BufferFlush Writing to this field causes all data that is stored in the transmit FIFO/buffer to be flushed.
       *        This does not affect data that is in the transmit shift register
       */
      template <typename... Types>
      constexpr Init(UartTransmitFifo_BufferFlush uartTransmitFifo_BufferFlush, Types... rest) : Init(rest...) {
   
         cfifo = (cfifo&~UART_CFIFO_TXFLUSH_MASK) | uartTransmitFifo_BufferFlush;
      }
   
      /**
       * Constructor for Receive FIFO/Buffer Flush
       * (uart_cfifo_rxflush)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveFifo_BufferFlush Writing to this field causes all data that is stored in the receive FIFO/buffer to be flushed.
       *        This does not affect data that is in the receive shift register
       */
      template <typename... Types>
      constexpr Init(UartReceiveFifo_BufferFlush uartReceiveFifo_BufferFlush, Types... rest) : Init(rest...) {
   
         cfifo = (cfifo&~UART_CFIFO_RXFLUSH_MASK) | uartReceiveFifo_BufferFlush;
      }
   
      /**
       * Constructor for Receive FIFO Overflow Interrupt Enable
       * (uart_cfifo_rxofe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveFifoOverflowInterruptEnable If this bit is set, the RXOF flag generates an interrupt
       */
      template <typename... Types>
      constexpr Init(UartReceiveFifoOverflowInterruptEnable uartReceiveFifoOverflowInterruptEnable, Types... rest) : Init(rest...) {
   
         cfifo = (cfifo&~UART_CFIFO_RXOFE_MASK) | uartReceiveFifoOverflowInterruptEnable;
      }
   
      /**
       * Constructor for Transmit FIFO Overflow Interrupt Enable
       * (uart_cfifo_txofe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitFifoOverflowInterruptEnable If this bit is set, the TXOF flag generates an interrupt
       */
      template <typename... Types>
      constexpr Init(UartTransmitFifoOverflowInterruptEnable uartTransmitFifoOverflowInterruptEnable, Types... rest) : Init(rest...) {
   
         cfifo = (cfifo&~UART_CFIFO_TXOFE_MASK) | uartTransmitFifoOverflowInterruptEnable;
      }
   
      /**
       * Constructor for Receive FIFO Underflow Interrupt Enable
       * (uart_cfifo_rxufe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveFifoUnderflowInterruptEnable If this bit is set, the RXUF flag generates an interrupt
       */
      template <typename... Types>
      constexpr Init(UartReceiveFifoUnderflowInterruptEnable uartReceiveFifoUnderflowInterruptEnable, Types... rest) : Init(rest...) {
   
         cfifo = (cfifo&~UART_CFIFO_RXUFE_MASK) | uartReceiveFifoUnderflowInterruptEnable;
      }
   
      /**
       * Constructor for Receiver Buffer Overflow Flag
       * (uart_sfifo_rxof)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveFifoOverflow Indicates that more data has been written to the receive buffer than it can hold
       *        This field will assert regardless of the value of CFIFO[RXOFE]. However, an interrupt will
       *        only be issued to the host if CFIFO[RXOFE] is set.
       *        This flag is cleared by writing a 1.
       */
      template <typename... Types>
      constexpr Init(UartReceiveFifoOverflow uartReceiveFifoOverflow, Types... rest) : Init(rest...) {
   
         sfifo = (sfifo&~UART_SFIFO_RXOF_MASK) | uartReceiveFifoOverflow;
      }
   
      /**
       * Constructor for Transmitter Buffer Overflow Flag
       * (uart_sfifo_txof)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitFifoOverflow Indicates that more data has been written to the transmit buffer than it can hold.
       *        This field will assert regardless of the value of CFIFO[TXOFE]. However, an interrupt will
       *        be issued to the host only if CFIFO[TXOFE] is set.
       *        This flag is cleared by writing a 1.
       */
      template <typename... Types>
      constexpr Init(UartTransmitFifoOverflow uartTransmitFifoOverflow, Types... rest) : Init(rest...) {
   
         sfifo = (sfifo&~UART_SFIFO_TXOF_MASK) | uartTransmitFifoOverflow;
      }
   
      /**
       * Constructor for Receiver Buffer Underflow Flag
       * (uart_sfifo_rxuf)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveFifoUnderflow Indicates that more data has been read from the receive buffer than was present.
       *        This field will assert regardless of the value of CFIFO[RXUFE]. However, an interrupt
       *        will be issued to the host only if CFIFO[RXUFE] is set.
       *        This flag is cleared by writing a 1.
       */
      template <typename... Types>
      constexpr Init(UartReceiveFifoUnderflow uartReceiveFifoUnderflow, Types... rest) : Init(rest...) {
   
         sfifo = (sfifo&~UART_SFIFO_RXUF_MASK) | uartReceiveFifoUnderflow;
      }
   
      /**
       * Constructor for Transmit Watermark
       * (uart_twfifo_txwater)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitWatermark When the number of datawords in the transmit FIFO/buffer is equal to or less than the value
       *        in this register field, an interrupt via S1[TDRE] or a DMA request via C5[TDMAS] is generated
       *        as determined by C5[TDMAS] and C2[TIE].
       *        For proper operation, the value in TXWATER must be set to be less than the size of the transmit
       *        buffer/FIFO size as indicated by PFIFO[TXFIFOSIZE] and PFIFO[TXFE].
       */
      template <typename... Types>
      constexpr Init(UartTransmitWatermark uartTransmitWatermark, Types... rest) : Init(rest...) {
   
         twfifo = (twfifo&~UART_TWFIFO_TXWATER_MASK) | UART_TWFIFO_TXWATER(uartTransmitWatermark);
      }
   
      /**
       * Constructor for Receive Watermark
       * (uart_rwfifo_rxwater)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveWatermark When the number of datawords in the receive FIFO/buffer is equal to or greater than the value in this
       *        register field, an interrupt via S1[RDRF] or a DMA request via C5[RDMAS] is generated as determined
       *        by C5[RDMAS] and C2[RIE].
       *        For proper operation, the value in RXWATER must be set to be less than the receive FIFO/buffer
       *        size as indicated by PFIFO[RXFIFOSIZE] and PFIFO[RXFE] and must be greater than 0.
       */
      template <typename... Types>
      constexpr Init(UartReceiveWatermark uartReceiveWatermark, Types... rest) : Init(rest...) {
   
         rwfifo = (rwfifo&~UART_RWFIFO_RXWATER_MASK) | UART_RWFIFO_RXWATER(uartReceiveWatermark);
      }
   
      /**
       * Constructor for Generate NACK on Overflow
       * (uart_c7816_onack)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartGenerateNackOnOverflow A NACK may be automatically sent if a receive buffer overrun occurs
       */
      template <typename... Types>
      constexpr Init(UartGenerateNackOnOverflow uartGenerateNackOnOverflow, Types... rest) : Init(rest...) {
   
         c7816 = (c7816&~UART_C7816_ONACK_MASK) | uartGenerateNackOnOverflow;
      }
   
      /**
       * Constructor for Generate NACK on Error
       * (uart_c7816_anack)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartGenerateNackOnError A NACK may be automatically generated if a parity error is detected or if an invalid initial character is 
       *        detected
       */
      template <typename... Types>
      constexpr Init(UartGenerateNackOnError uartGenerateNackOnError, Types... rest) : Init(rest...) {
   
         c7816 = (c7816&~UART_C7816_ANACK_MASK) | uartGenerateNackOnError;
      }
   
      /**
       * Constructor for Detect Initial Character
       * (uart_c7816_init)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartDetectInitialCharacter When this field is set, all received characters are searched for a valid initial character.
       *        If an invalid initial character is identified, and ANACK is set, a NACK is sent
       */
      template <typename... Types>
      constexpr Init(UartDetectInitialCharacter uartDetectInitialCharacter, Types... rest) : Init(rest...) {
   
         c7816 = (c7816&~UART_C7816_INIT_MASK) | uartDetectInitialCharacter;
      }
   
      /**
       * Constructor for Transfer Type
       * (uart_c7816_ttype)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransferType Indicates the transfer protocol being used
       */
      template <typename... Types>
      constexpr Init(UartTransferType uartTransferType, Types... rest) : Init(rest...) {
   
         c7816 = (c7816&~UART_C7816_TTYPE_MASK) | uartTransferType;
      }
   
      /**
       * Constructor for ISO-7816 Functionality Enabled
       * (uart_c7816_iso_7816e)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartIso7816FunctionalityEnabled 
       */
      template <typename... Types>
      constexpr Init(UartIso7816FunctionalityEnabled uartIso7816FunctionalityEnabled, Types... rest) : Init(rest...) {
   
         c7816 = (c7816&~UART_C7816_ISO_7816E_MASK) | uartIso7816FunctionalityEnabled;
      }
   
      /**
       * Constructor for Wait Timer Interrupt Enable
       * (uart_ie7816_wte)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartWaitTimerInterruptEnable 
       */
      template <typename... Types>
      constexpr Init(UartWaitTimerInterruptEnable uartWaitTimerInterruptEnable, Types... rest) : Init(rest...) {
   
         ie7816 = (ie7816&~UART_IE7816_WTE_MASK) | uartWaitTimerInterruptEnable;
      }
   
      /**
       * Constructor for Character Wait Timer (CWT) Interrupt Enable
       * (uart_ie7816_cwte)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartCharacterWaitTimerCwtInterruptEna 
       */
      template <typename... Types>
      constexpr Init(UartCharacterWaitTimerCwtInterruptEna uartCharacterWaitTimerCwtInterruptEna, Types... rest) : Init(rest...) {
   
         ie7816 = (ie7816&~UART_IE7816_CWTE_MASK) | uartCharacterWaitTimerCwtInterruptEna;
      }
   
      /**
       * Constructor for Block Wait Timer (BWT) Interrupt Enable
       * (uart_ie7816_bwte)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartBlockWaitTimerBwtInterruptEnable 
       */
      template <typename... Types>
      constexpr Init(UartBlockWaitTimerBwtInterruptEnable uartBlockWaitTimerBwtInterruptEnable, Types... rest) : Init(rest...) {
   
         ie7816 = (ie7816&~UART_IE7816_BWTE_MASK) | uartBlockWaitTimerBwtInterruptEnable;
      }
   
      /**
       * Constructor for Initial Character Detected (INITD) Interrupt Enable
       * (uart_ie7816_initde)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartInitialCharacterDetectedInitdInter 
       */
      template <typename... Types>
      constexpr Init(UartInitialCharacterDetectedInitdInter uartInitialCharacterDetectedInitdInter, Types... rest) : Init(rest...) {
   
         ie7816 = (ie7816&~UART_IE7816_INITDE_MASK) | uartInitialCharacterDetectedInitdInter;
      }
   
      /**
       * Constructor for Guard Timer Violated (GTV) Interrupt Enable
       * (uart_ie7816_gtve)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartGuardTimerViolatedGtvInterruptEna 
       */
      template <typename... Types>
      constexpr Init(UartGuardTimerViolatedGtvInterruptEna uartGuardTimerViolatedGtvInterruptEna, Types... rest) : Init(rest...) {
   
         ie7816 = (ie7816&~UART_IE7816_GTVE_MASK) | uartGuardTimerViolatedGtvInterruptEna;
      }
   
      /**
       * Constructor for Transmit Threshold Exceeded (TXT) Interrupt Enable
       * (uart_ie7816_txte)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitThresholdExceededTxtInterr 
       */
      template <typename... Types>
      constexpr Init(UartTransmitThresholdExceededTxtInterr uartTransmitThresholdExceededTxtInterr, Types... rest) : Init(rest...) {
   
         ie7816 = (ie7816&~UART_IE7816_TXTE_MASK) | uartTransmitThresholdExceededTxtInterr;
      }
   
      /**
       * Constructor for Receive Threshold Exceeded Interrupt Enable
       * (uart_ie7816_rxte)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveThresholdExceededInterruptEna 
       */
      template <typename... Types>
      constexpr Init(UartReceiveThresholdExceededInterruptEna uartReceiveThresholdExceededInterruptEna, Types... rest) : Init(rest...) {
   
         ie7816 = (ie7816&~UART_IE7816_RXTE_MASK) | uartReceiveThresholdExceededInterruptEna;
      }
   
      /**
       * Constructor for Wait Timer Interrupt
       * (uart_is7816_wt)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartWaitTimerInterrupt Set when the Wait Time (WT) has been violated
       */
      template <typename... Types>
      constexpr Init(UartWaitTimerInterrupt uartWaitTimerInterrupt, Types... rest) : Init(rest...) {
   
         is7816 = (is7816&~UART_IS7816_WT_MASK) | uartWaitTimerInterrupt;
      }
   
      /**
       * Constructor for Character Wait Timer Interrupt
       * (uart_is7816_cwt)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartCharacterWaitTimerInterrupt Set when the Character Wait Time (CWT) has been violated
       */
      template <typename... Types>
      constexpr Init(UartCharacterWaitTimerInterrupt uartCharacterWaitTimerInterrupt, Types... rest) : Init(rest...) {
   
         is7816 = (is7816&~UART_IS7816_CWT_MASK) | uartCharacterWaitTimerInterrupt;
      }
   
      /**
       * Constructor for Block Wait Timer Interrupt
       * (uart_is7816_bwt)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartBlockWaitTimerInterrupt Set when the Block Wait Time (BWT) has been violated
       */
      template <typename... Types>
      constexpr Init(UartBlockWaitTimerInterrupt uartBlockWaitTimerInterrupt, Types... rest) : Init(rest...) {
   
         is7816 = (is7816&~UART_IS7816_BWT_MASK) | uartBlockWaitTimerInterrupt;
      }
   
      /**
       * Constructor for Initial Character Detected Interrupt
       * (uart_is7816_initd)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartInitialCharacterDetectedInterrupt Set when a valid initial character has been received
       */
      template <typename... Types>
      constexpr Init(UartInitialCharacterDetectedInterrupt uartInitialCharacterDetectedInterrupt, Types... rest) : Init(rest...) {
   
         is7816 = (is7816&~UART_IS7816_INITD_MASK) | uartInitialCharacterDetectedInterrupt;
      }
   
      /**
       * Constructor for Guard Timer Violated Interrupt
       * (uart_is7816_gtv)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartGuardTimerViolatedInterrupt Set if a guard time (GT, CGT or BGT) has been violated
       */
      template <typename... Types>
      constexpr Init(UartGuardTimerViolatedInterrupt uartGuardTimerViolatedInterrupt, Types... rest) : Init(rest...) {
   
         is7816 = (is7816&~UART_IS7816_GTV_MASK) | uartGuardTimerViolatedInterrupt;
      }
   
      /**
       * Constructor for Transmit Threshold Exceeded Interrupt
       * (uart_is7816_txt)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitThresholdExceededInterrupt Set if the number of retries and corresponding NACKS &gt; the value in the ET7816[TXTHRESHOLD] field
       */
      template <typename... Types>
      constexpr Init(UartTransmitThresholdExceededInterrupt uartTransmitThresholdExceededInterrupt, Types... rest) : Init(rest...) {
   
         is7816 = (is7816&~UART_IS7816_TXT_MASK) | uartTransmitThresholdExceededInterrupt;
      }
   
      /**
       * Constructor for Receive Threshold Exceeded Interrupt
       * (uart_is7816_rxt)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveThresholdExceededInterrupt Set if the number of consecutive NACKS generated as a result of parity errors and buffer overruns is &gt;= the 
       *        value in ET7816[RXTHRESHOLD]
       */
      template <typename... Types>
      constexpr Init(UartReceiveThresholdExceededInterrupt uartReceiveThresholdExceededInterrupt, Types... rest) : Init(rest...) {
   
         is7816 = (is7816&~UART_IS7816_RXT_MASK) | uartReceiveThresholdExceededInterrupt;
      }
   
      /**
       * Constructor for Wait Timer Interrupt (C7816[TTYPE] = 0)
       * (uart_wp7816t0_wi)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartWaitTimerInterruptC7816ttype0 
       */
      template <typename... Types>
      constexpr Init(UartWaitTimerInterruptC7816ttype0 uartWaitTimerInterruptC7816ttype0, Types... rest) : Init(rest...) {
   
         wp7816t0 = (wp7816t0&~UART_WP7816T0_WI_MASK) | UART_WP7816T0_WI(uartWaitTimerInterruptC7816ttype0);
      }
   
      /**
       * Constructor for Character Wait Time Integer (C7816[TTYPE] = 1)
       * (uart_wp7816t1_cwi)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartCharacterWaitTimeIntegerC7816ttype 
       */
      template <typename... Types>
      constexpr Init(UartCharacterWaitTimeIntegerC7816ttype uartCharacterWaitTimeIntegerC7816ttype, Types... rest) : Init(rest...) {
   
         wp7816t1 = (wp7816t1&~UART_WP7816T1_CWI_MASK) | UART_WP7816T1_CWI(uartCharacterWaitTimeIntegerC7816ttype);
      }
   
      /**
       * Constructor for Block Wait Time Integer(C7816[TTYPE] = 1)
       * (uart_wp7816t1_bwi)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartBlockWaitTimeIntegerC7816ttype1 
       */
      template <typename... Types>
      constexpr Init(UartBlockWaitTimeIntegerC7816ttype1 uartBlockWaitTimeIntegerC7816ttype1, Types... rest) : Init(rest...) {
   
         wp7816t1 = (wp7816t1&~UART_WP7816T1_BWI_MASK) | UART_WP7816T1_BWI(uartBlockWaitTimeIntegerC7816ttype1);
      }
   
      /**
       * Constructor for Guard Band N
       * (uart_wn7816_gtn)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartGuardBandN 
       */
      template <typename... Types>
      constexpr Init(UartGuardBandN uartGuardBandN, Types... rest) : Init(rest...) {
   
         wn7816 = (wn7816&~UART_WN7816_GTN_MASK) | UART_WN7816_GTN(uartGuardBandN);
      }
   
      /**
       * Constructor for FD Multiplier
       * (uart_wf7816_gtfd)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartFdMultiplier 
       */
      template <typename... Types>
      constexpr Init(UartFdMultiplier uartFdMultiplier, Types... rest) : Init(rest...) {
   
         wf7816 = (wf7816&~UART_WF7816_GTFD_MASK) | UART_WF7816_GTFD(uartFdMultiplier);
      }
   
      /**
       * Constructor for Transmit NACK Threshold
       * (uart_et7816_txthreshold)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitNackThreshold The value written to this field indicates the maximum number of failed attempts (NACKs) a transmitted character
       *         can have before the host processor is notified
       */
      template <typename... Types>
      constexpr Init(UartTransmitNackThreshold uartTransmitNackThreshold, Types... rest) : Init(rest...) {
   
         et7816 = (et7816&~UART_ET7816_TXTHRESHOLD_MASK) | UART_ET7816_TXTHRESHOLD(uartTransmitNackThreshold);
      }
   
      /**
       * Constructor for Receive NACK Threshold
       * (uart_et7816_rxthreshold)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveNackThreshold The value written to this field indicates the maximum number of consecutive NACKs generated as a result of a 
       *        parity error or receiver buffer overruns before the host processor is notified
       */
      template <typename... Types>
      constexpr Init(UartReceiveNackThreshold uartReceiveNackThreshold, Types... rest) : Init(rest...) {
   
         et7816 = (et7816&~UART_ET7816_RXTHRESHOLD_MASK) | UART_ET7816_RXTHRESHOLD(uartReceiveNackThreshold);
      }
   
      /**
       * Constructor for Transmit Length
       * (uart_tl7816_tlen)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitLength 
       */
      template <typename... Types>
      constexpr Init(UartTransmitLength uartTransmitLength, Types... rest) : Init(rest...) {
   
         tl7816 = (tl7816&~UART_TL7816_TLEN_MASK) | UART_TL7816_TLEN(uartTransmitLength);
      }
   
      /**
       * Constructor for EN709
       * (uart_c6_en709)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartEn709 
       */
      template <typename... Types>
      constexpr Init(UartEn709 uartEn709, Types... rest) : Init(rest...) {
   
         c6 = (c6&~UART_C6_EN709_MASK) | uartEn709;
      }
   
      /**
       * Constructor for CEA709.1-B Transmit Enable
       * (uart_c6_tx709)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartCea709 
       */
      template <typename... Types>
      constexpr Init(UartCea709 uartCea709, Types... rest) : Init(rest...) {
   
         c6 = (c6&~UART_C6_TX709_MASK) | uartCea709;
      }
   
      /**
       * Constructor for Collision Enable
       * (uart_c6_ce)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartCollisionEnable 
       */
      template <typename... Types>
      constexpr Init(UartCollisionEnable uartCollisionEnable, Types... rest) : Init(rest...) {
   
         c6 = (c6&~UART_C6_CE_MASK) | uartCollisionEnable;
      }
   
      /**
       * Constructor for Collision Signal Polarity
       * (uart_c6_cp)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartCollisionSignalPolarity 
       */
      template <typename... Types>
      constexpr Init(UartCollisionSignalPolarity uartCollisionSignalPolarity, Types... rest) : Init(rest...) {
   
         c6 = (c6&~UART_C6_CP_MASK) | uartCollisionSignalPolarity;
      }
   
      /**
       * Constructor for Packet Cycle Time Counter High
       * (uart_pcth_pcth)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPacketCycleTimeCounterHigh 
       */
      template <typename... Types>
      constexpr Init(UartPacketCycleTimeCounterHigh uartPacketCycleTimeCounterHigh, Types... rest) : Init(rest...) {
   
         pcth = (pcth&~UART_PCTH_PCTH_MASK) | UART_PCTH_PCTH(uartPacketCycleTimeCounterHigh);
      }
   
      /**
       * Constructor for Packet Cycle Time Counter Low
       * (uart_pctl_pctl)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPacketCycleTimeCounterLow 
       */
      template <typename... Types>
      constexpr Init(UartPacketCycleTimeCounterLow uartPacketCycleTimeCounterLow, Types... rest) : Init(rest...) {
   
         pctl = (pctl&~UART_PCTL_PCTL_MASK) | UART_PCTL_PCTL(uartPacketCycleTimeCounterLow);
      }
   
      /**
       * Constructor for Beta1 Timer
       * (uart_b1t_b1t)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartBeta1Timer 
       */
      template <typename... Types>
      constexpr Init(UartBeta1Timer uartBeta1Timer, Types... rest) : Init(rest...) {
   
         b1t = (b1t&~UART_B1T_B1T_MASK) | UART_B1T_B1T(uartBeta1Timer);
      }
   
      /**
       * Constructor for Secondary Delay Timer High
       * (uart_sdth_sdth)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartSecondaryDelayTimerHigh 
       */
      template <typename... Types>
      constexpr Init(UartSecondaryDelayTimerHigh uartSecondaryDelayTimerHigh, Types... rest) : Init(rest...) {
   
         sdth = (sdth&~UART_SDTH_SDTH_MASK) | UART_SDTH_SDTH(uartSecondaryDelayTimerHigh);
      }
   
      /**
       * Constructor for Secondary Delay Timer Low
       * (uart_sdtl_sdtl)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartSecondaryDelayTimerLow 
       */
      template <typename... Types>
      constexpr Init(UartSecondaryDelayTimerLow uartSecondaryDelayTimerLow, Types... rest) : Init(rest...) {
   
         sdtl = (sdtl&~UART_SDTL_SDTL_MASK) | UART_SDTL_SDTL(uartSecondaryDelayTimerLow);
      }
   
      /**
       * Constructor for Transmit Packet Length Register
       * (uart_tpl_tpl)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitPacketLengthRegister 
       */
      template <typename... Types>
      constexpr Init(UartTransmitPacketLengthRegister uartTransmitPacketLengthRegister, Types... rest) : Init(rest...) {
   
         tpl = (tpl&~UART_TPL_TPL_MASK) | UART_TPL_TPL(uartTransmitPacketLengthRegister);
      }
   
      /**
       * Constructor for Wbase Expired Interrupt Enable
       * (uart_ie_wbeie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartWbaseExpiredInterruptEnable 
       */
      template <typename... Types>
      constexpr Init(UartWbaseExpiredInterruptEnable uartWbaseExpiredInterruptEnable, Types... rest) : Init(rest...) {
   
         ie = (ie&~UART_IE_WBEIE_MASK) | uartWbaseExpiredInterruptEnable;
      }
   
      /**
       * Constructor for Initial Sync Detection Interrupt Enable
       * (uart_ie_isdie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartInitialSyncDetectionInterruptEnable 
       */
      template <typename... Types>
      constexpr Init(UartInitialSyncDetectionInterruptEnable uartInitialSyncDetectionInterruptEnable, Types... rest) : Init(rest...) {
   
         ie = (ie&~UART_IE_ISDIE_MASK) | uartInitialSyncDetectionInterruptEnable;
      }
   
      /**
       * Constructor for Packet Received Interrupt Enable
       * (uart_ie_prxie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPacketReceivedInterruptEnable 
       */
      template <typename... Types>
      constexpr Init(UartPacketReceivedInterruptEnable uartPacketReceivedInterruptEnable, Types... rest) : Init(rest...) {
   
         ie = (ie&~UART_IE_PRXIE_MASK) | uartPacketReceivedInterruptEnable;
      }
   
      /**
       * Constructor for Packet Transmitted Interrupt Enable
       * (uart_ie_ptxie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPacketTransmittedInterruptEnable 
       */
      template <typename... Types>
      constexpr Init(UartPacketTransmittedInterruptEnable uartPacketTransmittedInterruptEnable, Types... rest) : Init(rest...) {
   
         ie = (ie&~UART_IE_PTXIE_MASK) | uartPacketTransmittedInterruptEnable;
      }
   
      /**
       * Constructor for Packet Cycle Timer Interrupt Enable
       * (uart_ie_pcteie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPacketCycleTimerInterruptEnable 
       */
      template <typename... Types>
      constexpr Init(UartPacketCycleTimerInterruptEnable uartPacketCycleTimerInterruptEnable, Types... rest) : Init(rest...) {
   
         ie = (ie&~UART_IE_PCTEIE_MASK) | uartPacketCycleTimerInterruptEnable;
      }
   
      /**
       * Constructor for Preamble Start Interrupt Enable
       * (uart_ie_psie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPreambleStartInterruptEnable 
       */
      template <typename... Types>
      constexpr Init(UartPreambleStartInterruptEnable uartPreambleStartInterruptEnable, Types... rest) : Init(rest...) {
   
         ie = (ie&~UART_IE_PSIE_MASK) | uartPreambleStartInterruptEnable;
      }
   
      /**
       * Constructor for Transmission Fail Interrupt Enable
       * (uart_ie_txfie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmissionFailInterruptEnable 
       */
      template <typename... Types>
      constexpr Init(UartTransmissionFailInterruptEnable uartTransmissionFailInterruptEnable, Types... rest) : Init(rest...) {
   
         ie = (ie&~UART_IE_TXFIE_MASK) | uartTransmissionFailInterruptEnable;
      }
   
      /**
       * Constructor for Preamble Error Flag
       * (uart_s3_pef)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPreambleErrorFlag 
       */
      template <typename... Types>
      constexpr Init(UartPreambleErrorFlag uartPreambleErrorFlag, Types... rest) : Init(rest...) {
   
         s3 = (s3&~UART_S3_PEF_MASK) | uartPreambleErrorFlag;
      }
   
      /**
       * Constructor for Wbase Expired Flag
       * (uart_s3_wbef)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartWbaseExpiredFlag 
       */
      template <typename... Types>
      constexpr Init(UartWbaseExpiredFlag uartWbaseExpiredFlag, Types... rest) : Init(rest...) {
   
         s3 = (s3&~UART_S3_WBEF_MASK) | uartWbaseExpiredFlag;
      }
   
      /**
       * Constructor for Packet Received Flag
       * (uart_s3_prxf)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPacketReceivedFlag 
       */
      template <typename... Types>
      constexpr Init(UartPacketReceivedFlag uartPacketReceivedFlag, Types... rest) : Init(rest...) {
   
         s3 = (s3&~UART_S3_PRXF_MASK) | uartPacketReceivedFlag;
      }
   
      /**
       * Constructor for Packet Transmitted Flag
       * (uart_s3_ptxf)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPacketTransmittedFlag 
       */
      template <typename... Types>
      constexpr Init(UartPacketTransmittedFlag uartPacketTransmittedFlag, Types... rest) : Init(rest...) {
   
         s3 = (s3&~UART_S3_PTXF_MASK) | uartPacketTransmittedFlag;
      }
   
      /**
       * Constructor for Packet Cycle Timer Expired Flag
       * (uart_s3_pctef)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPacketCycleTimerExpiredFlag 
       */
      template <typename... Types>
      constexpr Init(UartPacketCycleTimerExpiredFlag uartPacketCycleTimerExpiredFlag, Types... rest) : Init(rest...) {
   
         s3 = (s3&~UART_S3_PCTEF_MASK) | uartPacketCycleTimerExpiredFlag;
      }
   
      /**
       * Constructor for Preamble Start Flag
       * (uart_s3_psf)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartPreambleStartFlag 
       */
      template <typename... Types>
      constexpr Init(UartPreambleStartFlag uartPreambleStartFlag, Types... rest) : Init(rest...) {
   
         s3 = (s3&~UART_S3_PSF_MASK) | uartPreambleStartFlag;
      }
   
      /**
       * Constructor for Transmission Fail Flag
       * (uart_s3_txff)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmissionFailFlag 
       */
      template <typename... Types>
      constexpr Init(UartTransmissionFailFlag uartTransmissionFailFlag, Types... rest) : Init(rest...) {
   
         s3 = (s3&~UART_S3_TXFF_MASK) | uartTransmissionFailFlag;
      }
   
      /**
       * Constructor for CDET
       * (uart_s4_cdet)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartCdet 
       */
      template <typename... Types>
      constexpr Init(UartCdet uartCdet, Types... rest) : Init(rest...) {
   
         s4 = (s4&~UART_S4_CDET_MASK) | uartCdet;
      }
   
      /**
       * Constructor for Improper Line Code Violation
       * (uart_s4_ilcv)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartImproperLineCodeViolation 
       */
      template <typename... Types>
      constexpr Init(UartImproperLineCodeViolation uartImproperLineCodeViolation, Types... rest) : Init(rest...) {
   
         s4 = (s4&~UART_S4_ILCV_MASK) | uartImproperLineCodeViolation;
      }
   
      /**
       * Constructor for Error
       * (uart_s4_fe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartError 
       */
      template <typename... Types>
      constexpr Init(UartError uartError, Types... rest) : Init(rest...) {
   
         s4 = (s4&~UART_S4_FE_MASK) | uartError;
      }
   
   }; // class UartBasicInfo::Init
   
   /**
    * Configure UART from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param uart            Hardware instance pointer
    * @param clockFrequency  Clock frequency
    * @param init            Class containing initialisation values
    */
   static void configure(
                  volatile UART_Type *uart,
                  uint32_t            clockFrequency,
                  const Init         &init) {
   
   
      // Transmitter Enable (uart_c2_te)
      // Receiver Enable (uart_c2_re)
      uart->C2 = 0;
   
      // LIN break detect action (uart_bdh_lbkdie)
      // RxD input active edge action (uart_bdh_rxedgie)
      uart->BDH = init.bdh;
   
      // UART baud rate (uart_baudrate)
      setBaudRate(uart, clockFrequency, init.baudrate);
   
      // Loop Mode Select (uart_c1_loops)
      // Stops in Wait Mode (uart_c1_uartswai)
      // Receiver Source Select (uart_c1_rsrc)
      // 9-Bit or 8-Bit Mode Select (uart_c1_m)
      // Receiver Wakeup Method Select (uart_c1_wake)
      // Idle Line Type Select (uart_c1_ilt)
      // Parity Enable (uart_c1_pe)
      // Parity Type (uart_c1_pt)
      uart->C1 = init.c1;
   
      // LIN Break Detect Interrupt Flag (uart_s2_lbkdif)
      // RxD Pin Active Edge Interrupt Flag (uart_s2_rxedgif)
      // Most Significant Bit First (uart_s2_msbf)
      // Receive Data Inversion (uart_s2_rxinv)
      // Receive Wakeup Idle Detect (uart_s2_rwuid)
      // Break Transmit Character Length (uart_s2_brk13)
      // LIN Break Detection Enable (uart_s2_lbkde)
      uart->S2 = init.s2;
   
      // Transmit Bit 8 (uart_c3_t8)
      // Transmitter Pin Direction in Single-Wire mode (uart_c3_txdir)
      // Transmit Data Inversion (uart_c3_txinv)
      // Overrun Error Interrupt Enable (uart_c3_orie)
      // Noise Error Interrupt Enable (uart_c3_neie)
      // Framing Error Interrupt Enable (uart_c3_feie)
      // Parity Error Interrupt Enable (uart_c3_peie)
      uart->C3 = init.c3;
   
      // Match Address Mode Enable 1 (uart_c4_maen1)
      // Match Address Mode Enable 2 (uart_c4_maen2)
      // 10-bit Mode select (uart_c4_m10)
      // Baud Rate Fine Adjust (uart_c4_brfa)
      uart->C4 = init.c4;
   
      // Transmitter Interrupt/DMA Select (uart_c5_tdmas)
      // Receiver Full Interrupt/DMA Select (uart_c5_rdmas)
      uart->C5 = init.c5;
   
      // Receiver request-to-send enable (uart_modem_rxrtse)
      // Transmitter request-to-send polarity (uart_modem_txrtspol)
      // Transmitter request-to-send enable (uart_modem_txrtse)
      // Transmitter clear-to-send enable (uart_modem_txctse)
      uart->MODEM = init.modem;
   
      // Infrared enable (uart_ir_iren)
      // Transmitter narrow pulse (uart_ir_tnp)
      uart->IR = init.ir;
   
      // Transmit FIFO Enable (uart_pfifo_txfe)
      // Receive FIFO Enable (uart_pfifo_rxfe)
      uart->PFIFO = init.pfifo;
   
      // Transmit FIFO/Buffer Flush (uart_cfifo_txflush)
      // Receive FIFO/Buffer Flush (uart_cfifo_rxflush)
      // Receive FIFO Overflow Interrupt Enable (uart_cfifo_rxofe)
      // Transmit FIFO Overflow Interrupt Enable (uart_cfifo_txofe)
      // Receive FIFO Underflow Interrupt Enable (uart_cfifo_rxufe)
      uart->CFIFO = init.cfifo;
   
      // Receiver Buffer Overflow Flag (uart_sfifo_rxof)
      // Transmitter Buffer Overflow Flag (uart_sfifo_txof)
      // Receiver Buffer Underflow Flag (uart_sfifo_rxuf)
      uart->SFIFO = init.sfifo;
   
      // Transmit Watermark (uart_twfifo_txwater)
      uart->TWFIFO = init.twfifo;
   
      // Receive Watermark (uart_rwfifo_rxwater)
      uart->RWFIFO = init.rwfifo;
   
      // Generate NACK on Overflow (uart_c7816_onack)
      // Generate NACK on Error (uart_c7816_anack)
      // Detect Initial Character (uart_c7816_init)
      // Transfer Type (uart_c7816_ttype)
      // ISO-7816 Functionality Enabled (uart_c7816_iso_7816e)
      uart->C7816 = init.c7816;
   
      // Wait Timer Interrupt Enable (uart_ie7816_wte)
      // Character Wait Timer (CWT) Interrupt Enable (uart_ie7816_cwte)
      // Block Wait Timer (BWT) Interrupt Enable (uart_ie7816_bwte)
      // Initial Character Detected (INITD) Interrupt Enable (uart_ie7816_initde)
      // Guard Timer Violated (GTV) Interrupt Enable (uart_ie7816_gtve)
      // Transmit Threshold Exceeded (TXT) Interrupt Enable (uart_ie7816_txte)
      // Receive Threshold Exceeded Interrupt Enable (uart_ie7816_rxte)
      uart->IE7816 = init.ie7816;
   
      // Wait Timer Interrupt (uart_is7816_wt)
      // Character Wait Timer Interrupt (uart_is7816_cwt)
      // Block Wait Timer Interrupt (uart_is7816_bwt)
      // Initial Character Detected Interrupt (uart_is7816_initd)
      // Guard Timer Violated Interrupt (uart_is7816_gtv)
      // Transmit Threshold Exceeded Interrupt (uart_is7816_txt)
      // Receive Threshold Exceeded Interrupt (uart_is7816_rxt)
      uart->IS7816 = init.is7816;
   
      // Wait Timer Interrupt (C7816[TTYPE] = 0) (uart_wp7816t0_wi)
      uart->WP7816T0 = init.wp7816t0;
   
      // Character Wait Time Integer (C7816[TTYPE] = 1) (uart_wp7816t1_cwi)
      // Block Wait Time Integer(C7816[TTYPE] = 1) (uart_wp7816t1_bwi)
      uart->WP7816T1 = init.wp7816t1;
   
      // Guard Band N (uart_wn7816_gtn)
      uart->WN7816 = init.wn7816;
   
      // FD Multiplier (uart_wf7816_gtfd)
      uart->WF7816 = init.wf7816;
   
      // Transmit NACK Threshold (uart_et7816_txthreshold)
      // Receive NACK Threshold (uart_et7816_rxthreshold)
      uart->ET7816 = init.et7816;
   
      // Transmit Length (uart_tl7816_tlen)
      uart->TL7816 = init.tl7816;
   
      // EN709 (uart_c6_en709)
      // CEA709.1-B Transmit Enable (uart_c6_tx709)
      // Collision Enable (uart_c6_ce)
      // Collision Signal Polarity (uart_c6_cp)
      uart->C6 = init.c6;
   
      // Packet Cycle Time Counter High (uart_pcth_pcth)
      uart->PCTH = init.pcth;
   
      // Packet Cycle Time Counter Low (uart_pctl_pctl)
      uart->PCTL = init.pctl;
   
      // Beta1 Timer (uart_b1t_b1t)
      uart->B1T = init.b1t;
   
      // Secondary Delay Timer High (uart_sdth_sdth)
      uart->SDTH = init.sdth;
   
      // Secondary Delay Timer Low (uart_sdtl_sdtl)
      uart->SDTL = init.sdtl;
   
      // Transmit Packet Length Register (uart_tpl_tpl)
      uart->TPL = init.tpl;
   
      // Wbase Expired Interrupt Enable (uart_ie_wbeie)
      // Initial Sync Detection Interrupt Enable (uart_ie_isdie)
      // Packet Received Interrupt Enable (uart_ie_prxie)
      // Packet Transmitted Interrupt Enable (uart_ie_ptxie)
      // Packet Cycle Timer Interrupt Enable (uart_ie_pcteie)
      // Preamble Start Interrupt Enable (uart_ie_psie)
      // Transmission Fail Interrupt Enable (uart_ie_txfie)
      uart->IE = init.ie;
   
      // Preamble Error Flag (uart_s3_pef)
      // Wbase Expired Flag (uart_s3_wbef)
      // Packet Received Flag (uart_s3_prxf)
      // Packet Transmitted Flag (uart_s3_ptxf)
      // Packet Cycle Timer Expired Flag (uart_s3_pctef)
      // Preamble Start Flag (uart_s3_psf)
      // Transmission Fail Flag (uart_s3_txff)
      uart->S3 = init.s3;
   
      // CDET (uart_s4_cdet)
      // Improper Line Code Violation (uart_s4_ilcv)
      // Error (uart_s4_fe)
      uart->S4 = init.s4;
   
      // Transmit complete action (uart_c2_tcie)
      // Idle line detect action (uart_c2_ilie)
      // Transmitter Enable (uart_c2_te)
      // Receiver Enable (uart_c2_re)
      // Receiver Wakeup Control (uart_c2_rwu)
      // Send Break (uart_c2_sbk)
      uart->C2 = init.c2;
   }
   
   /**
    * Configure UART from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param init Class containing initialisation values
    */
   void configure(const Init &init) const {
   
      configure(uart, getInputClockFrequency(), init);
   }
   
}; // class UartBasicInfo 

class Uart0Info : public UartBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 5;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: UART0_TX             = PTA2(p19)                      */  { PinIndex::PTA2,         PcrValue(0x00200UL) },
         /*   1: UART0_RX             = PTA1(p18)                      */  { PinIndex::PTA1,         PcrValue(0x00200UL) },
         /*   2: UART0_RTS_b          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   3: UART0_CTS_b          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: UART0_COL_b          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK);
      PORTA->GPCLR = (0x0200UL|PORT_GPCLR_GPWE(0x0006UL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK);
      PORTA->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0006UL);
   }

   /*
    * Template:uart0_mk10d10_c7816_cea709
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with UART0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with UART0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = UART0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * IRQ entry
    * (irq_enum)
    *
    * Select amongst interrupts associated with the peripheral
    */
   enum IrqNum {
      IrqNum_Lon     = 0,  ///< Maps to UART0_Lon_IRQn
      IrqNum_RxTx    = 1,  ///< Maps to UART0_RxTx_IRQn
      IrqNum_Error   = 2,  ///< Maps to UART0_Error_IRQn
   };

   /**
    * Enable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum) {
      NVIC_EnableIRQ(irqNums[irqNum]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum, NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[irqNum], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void disableNvicInterrupts(IrqNum irqNum) {
      NVIC_DisableIRQ(irqNums[irqNum]);
   }
   
   /**
    *  Enable clock to Uart0
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_UART0_MASK;
   }
   
   /**
    *  Disable clock to Uart0
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_UART0_MASK;
   }
   
   /**
    * Basic enable of Uart0
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      enableClock();
      configureAllPins();
   }
   
   /**
    * Disables Uart0
    */
   static void disable() {
   
      
      disableNvicInterrupts(IrqNum_Lon);
      disableNvicInterrupts(IrqNum_RxTx);
      disableNvicInterrupts(IrqNum_Error);
      disableAllPins();
      disableClock();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = UART0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<UART_Type> uart = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   /**
    * Clear UART status 

    * This includes:
    * - Idle detect flag
    * - Overrun flag
    * - Noise flag
    * - Framing error flag
    * - Parity error flag
    */
   static void clearError() {
   
      // Flags are cleared by reading status and then data
      (void)uart->S1;
      (void)uart->D;
   }
   
   /**
    * Get input clock frequency
    * (Individual to each peripheral)
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   virtual uint32_t getInputClockFrequency() const override {
      return SimInfo::getUart0Clock();
   }
   
   /*
    *   Default Constructor
    */
   Uart0Info() : UartBasicInfo(uart) {
      defaultConfigure();
   }
   
   /*
    *   Constructor
    */
   Uart0Info(const Init &init) : UartBasicInfo(uart) {
      configure(init);
   }
   
   /**
    * Set baud rate
    *
    * @param uartBaudRate Baud rate for UART
    *        Values available will depend on peripheral clock frequency
    */
   static void setBaudRate(UartBaudRate uartBaudRate) {
   
      UartBasicInfo::setBaudRate(uart,  SimInfo::getUart0Clock(), uartBaudRate);
   }
   
   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   void initialise() const {
   
      defaultConfigure();
   }
   
   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   static void defaultConfigure() {
   
      configure(DefaultInitValue);
   }
   
   /**
    * Configure UART from values specified in init
    *
    * @param init Class containing initialisation values
    */
   static void configure(const Init &init) {
   
      // Enable peripheral
      enable();
   
      UartBasicInfo::configure(uart, SimInfo::getUart0Clock(), init);
   }
   
   /**
    * Default initialisation value for Uart0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr UartBasicInfo::Init DefaultInitValue = {
   
      UartBaudRate_115200 ,             // (uart_baudrate)            UART baud rate - 115200
      UartTxEmptyAction_None ,          // (uart_txempty_action)      Transmit empty DMA/Interrupt action - None
      UartRxFullAction_None ,           // (uart_rxfull_action)       Receive full DMA/interrupt action - None
      UartTransmitterEnable_Enabled ,   // (uart_c2_te)               Transmitter Enable - Transmitter enabled
      UartReceiverEnable_Enabled ,      // (uart_c2_re)               Receiver Enable - Receiver enabled
      UartReceiveWatermark(1) ,         // (uart_rwfifo_rxwater)      Receive Watermark
   };
   
}; // class Uart0Info

/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart1BasicInfo : public FormattedIO {

public:
}; // class Uart1BasicInfo 

class Uart1Info : public Uart1BasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: UART1_TX             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: UART1_RX             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: UART1_RTS_b          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   3: UART1_CTS_b          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:uart1_mk10d10
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with UART1
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with UART1
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = UART1_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * IRQ entry
    * (irq_enum)
    *
    * Select amongst interrupts associated with the peripheral
    */
   enum IrqNum {
      IrqNum_RxTx    = 0,  ///< Maps to UART1_RxTx_IRQn
      IrqNum_Error   = 1,  ///< Maps to UART1_Error_IRQn
   };

   /**
    * Enable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum) {
      NVIC_EnableIRQ(irqNums[irqNum]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum, NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[irqNum], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void disableNvicInterrupts(IrqNum irqNum) {
      NVIC_DisableIRQ(irqNums[irqNum]);
   }
   
   /**
    *  Enable clock to Uart1
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_UART1_MASK;
   }
   
   /**
    *  Disable clock to Uart1
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_UART1_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = UART1_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<UART1_Type> uart = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 1;
   
}; // class Uart1Info

/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart2Info : public Uart1BasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: UART2_TX             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: UART2_RX             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: UART2_RTS_b          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   3: UART2_CTS_b          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:uart1_mk10d10
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with UART2
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with UART2
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = UART2_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * IRQ entry
    * (irq_enum)
    *
    * Select amongst interrupts associated with the peripheral
    */
   enum IrqNum {
      IrqNum_RxTx    = 0,  ///< Maps to UART2_RxTx_IRQn
      IrqNum_Error   = 1,  ///< Maps to UART2_Error_IRQn
   };

   /**
    * Enable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum) {
      NVIC_EnableIRQ(irqNums[irqNum]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum, NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[irqNum], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void disableNvicInterrupts(IrqNum irqNum) {
      NVIC_DisableIRQ(irqNums[irqNum]);
   }
   
   /**
    *  Enable clock to Uart2
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_UART2_MASK;
   }
   
   /**
    *  Disable clock to Uart2
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_UART2_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = UART2_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<UART1_Type> uart = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 2;
   
}; // class Uart2Info


/**
 * @brief Template class representing an UART interface with buffered reception
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  UartBuffered_T<100, 100> bufferedUart{console};
 *
 *  for(int i=0; i++;) {
 *     bufferedUart.writeln("Tick... ", i);
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing UART hardware
 */
template<typename T, int rxSize=100, int txSize=100>
class UartBuffered_T : public T {

private:
   UartBuffered_T(const UartBuffered_T&) = delete;
   UartBuffered_T(UartBuffered_T&&) = delete;

   static constexpr typename T::Init initValue = {
         UartBaudRate_115200,
         UartTxEmptyAction_Interrupt ,    // (uart_txempty_action)      Transmit empty DMA/Interrupt action - Interrupt
         UartRxFullAction_Interrupt ,     // (uart_rxfull_action)       Receive full DMA/interrupt action - Interrupt
#if false // /UART/uart_pfifo_txfe_present
         UartTransmitFifoEnable_Enabled ,  // (uart_pfifo_txfe)          Transmit FIFO Enable - Enabled
         UartReceiveFifoEnable_Enabled ,   // (uart_pfifo_rxfe)          Receive FIFO Enable - Enabled
#endif
   };

public:

   UartBuffered_T(const T &uart) : T(uart) {
      T::setCallback(T::IrqNum_RxTx,  T::wrapCallback(this, &USBDM::UartBuffered_T<T, rxSize, txSize>::callback));
      T::configure(initValue);
   }

   UartBuffered_T(const T &uart, typename T::Init init) : UartBasicInfo(uart) {
      T::setCallback(T::IrqNum_RxTx,  T::wrapCallback(this, &USBDM::UartBuffered_T<T, rxSize, txSize>::callback));
      T::configure(init);
   }

   virtual ~UartBuffered_T() {
      T::setTransmitCompleteAction(UartTxCompleteAction_None);
      T::setReceiveFullAction(UartRxFullAction_None);
   }

protected:
   /**
    * Queue for Buffered reception (if used)
    */
   static inline UartQueue<char, rxSize> rxQueue;
   /**
    * Queue for Buffered transmission (if used)
    */
   static inline UartQueue<char, txSize> txQueue;

   /**
    * Writes a character (blocking on transmit queue full)
    *
    * @param[in]  ch - character to send
    */
   virtual void _writeChar(char ch) override {
      T::lock();
      // Add character to buffer
      while (!txQueue.enQueueDiscardOnFull(ch)) {
         __asm__("nop");
      }
      T::setTransmitCompleteAction(UartTxCompleteAction_Interrupt);
      T::unlock();
      if (ch=='\n') {
        _writeChar('\r');
      }
   }

   /**
    * Receives a single character (blocking on receive queue empty)
    *
    * @return Character received
    */
   virtual int _readChar() override {
      T::lock();
      while (rxQueue.isEmpty()) {
         __asm__("nop");
      }
      char t = rxQueue.deQueue();
      T::unlock();
      return t;
   }

   /**
    * Check if character is available
    *
    * @return true  Character available i.e. _readChar() will not block
    * @return false No character available
    */
   virtual bool _isCharAvailable() override {
      return (!rxQueue.isEmpty());
   }

public:
   /**
    * Receive/Transmit/Error IRQ handler call-back
    */
   void callback()  {
      UartStatusFlag status = T::getStatusFlags();

      // Empty UART Rx FIFO
      while(status&UartStatusFlag::ReceiveDataRegisterFullFlag) {
         // Receive data register full - save data
         rxQueue.enQueueDiscardOnFull(T::getReceiveData());
         status = T::getStatusFlags();
      }
      // Fill UART Tx FIFO
      while(status&UartStatusFlag::TransmitDataRegisterEmptyFlag) {
         // Transmitter ready
         if (txQueue.isEmpty()) {
            // No data available - disable further transmit interrupts
            T::setTransmitCompleteAction(UartTxCompleteAction_None);
            break;
         }
         else {
            // Transmit next byte
            T::setTransmitData(txQueue.deQueue());
         }
         status = T::getStatusFlags();
      }
   }

   /**
    *  Flush output data.
    *  This blocks until all pending data has been sent
    */
   virtual UartBuffered_T &flushOutput() override {
      while (!txQueue.isEmpty()) {
         // Wait until queue empty
      }
      while ((T::uart->S1 & UART_S1_TC_MASK) == 0) {
         // Wait until transmission of last character is complete
      }
      return *this;
   }

   /**
    *  Flush input data
    */
   virtual UartBuffered_T &flushInput() override {
      rxQueue.clear();
      UartBasicInfo::flushInput();
      return *this;
   }

};
   /**
    * Class representing UART instance
    */
   typedef UartBasicInfo UartInstance;
   /**
    * Class representing UART0
    */
   typedef Uart0Info Uart0;
   

/**
 * End UART_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_UART_H_ */
