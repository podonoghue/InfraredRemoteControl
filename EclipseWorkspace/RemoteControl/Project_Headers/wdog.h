/**
 * @file     wdog.h (180.ARM_Peripherals/Project_Headers/wdog.h)
 * @brief    External Watchdog Monitor
 */

#ifndef HEADER_WDOG_H_
#define HEADER_WDOG_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

// No handler defined for WDOG


namespace USBDM {
 
/**
 * @addtogroup WDOG_Group WDOG, Watchdog Timer
 * @brief Abstraction for Watchdog Timer
 * @{
 */
/**
 * Peripheral information for WDOG, Watchdog Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */

   /**
    * Watchdog enable
    * (wdog_stctrlh_wdogen)
    *
    * Main enable for WDOG
    * When disabled, the watchdog timer is kept in the reset state, but the other exception conditions can 
    * still trigger a reset/interrupt
    */
   enum WdogEnable : uint16_t {
      WdogEnable_Disabled   = WDOG_STCTRLH_WDOGEN(0),  ///< Watchdog disabled
      WdogEnable_Enabled    = WDOG_STCTRLH_WDOGEN(1),  ///< Watchdog enabled
   };

   /**
    * Test mode disable
    * (wdog_stctrlh_distestwdog)
    *
    * Disables watchdog test mode until next reset
    */
   enum WdogTestMode : uint16_t {
      WdogTestMode_Enabled    = WDOG_STCTRLH_DISTESTWDOG(0),  ///< Test mode enabled
      WdogTestMode_Disabled   = WDOG_STCTRLH_DISTESTWDOG(1),  ///< Test mode disabled
   };

   /**
    * Enable watchdog in WAIT mode
    * (wdog_stctrlh_waiten)
    *
    * Control watchdog operation in WAIT mode
    */
   enum WdogEnableInWait : uint16_t {
      WdogEnableInWait_Disabled   = WDOG_STCTRLH_WAITEN(0),  ///< Disabled in WAIT mode
      WdogEnableInWait_Enabled    = WDOG_STCTRLH_WAITEN(1),  ///< Enabled in WAIT mode
   };

   /**
    * Enable watchdog in STOP mode
    * (wdog_stctrlh_stopen)
    *
    * Control watchdog operation in STOP mode
    */
   enum WdogEnableInStop : uint16_t {
      WdogEnableInStop_Disabled   = WDOG_STCTRLH_STOPEN(0),  ///< Disabled in STOP mode
      WdogEnableInStop_Enabled    = WDOG_STCTRLH_STOPEN(1),  ///< Enabled in STOP mode
   };

   /**
    * Enable watchdog in DEBUG mode
    * (wdog_stctrlh_dbgen)
    *
    * Control watchdog operation in DEBUG mode
    */
   enum WdogEnableInDebug : uint16_t {
      WdogEnableInDebug_Disabled   = WDOG_STCTRLH_DBGEN(0),  ///< Disabled in DEBUG mode
      WdogEnableInDebug_Enabled    = WDOG_STCTRLH_DBGEN(1),  ///< Enabled in DEBUG mode
   };

   /**
    * Allow watchdog update
    * (wdog_stctrlh_allowupdate)
    *
    * Enables updates to watchdog write-once registers, after 
    * the reset-triggered initial configuration window closes
    * This still requires the unlock sequence
    */
   enum WdogAllowUpdate : uint16_t {
      WdogAllowUpdate_Disabled   = WDOG_STCTRLH_ALLOWUPDATE(0),  ///< Update Disabled
      WdogAllowUpdate_Enabled    = WDOG_STCTRLH_ALLOWUPDATE(1),  ///< Update Enabled
   };

   /**
    * Enable watchdog windowing mode
    * (wdog_stctrlh_winen)
    *
    * Windowing mode only allows refresh during a restricted window
    */
   enum WdogWindow : uint16_t {
      WdogWindow_Disabled   = WDOG_STCTRLH_WINEN(0),  ///< Windowing mode disabled
      WdogWindow_Enabled    = WDOG_STCTRLH_WINEN(1),  ///< Windowing mode enabled
   };

   /**
    * Action on watchdog event
    * (wdog_stctrlh_irqrsten)
    *
    * This write-once bit allows an interrupt handler to record state prior to forcing a reset.
    * The reset occurs after a delay of 128 bus clocks following the interrupt vector fetch.
    */
   enum WdogAction : uint16_t {
      WdogAction_ImmediateReset        = WDOG_STCTRLH_IRQRSTEN(0),  ///< Immediate Reset
      WdogAction_ResetAfterInterrupt   = WDOG_STCTRLH_IRQRSTEN(1),  ///< Interrupt followed by reset
   };

   /**
    * Watchdog clock source
    * (wdog_stctrlh_clksrc)
    *
    * Clock source for watchdog
    */
   enum WdogClock : uint16_t {
      WdogClock_LpoClk         = WDOG_STCTRLH_CLKSRC(0),  ///< 1 kHz low-power oscillator (LPOCLK)
      WdogClock_SystemBusClk   = WDOG_STCTRLH_CLKSRC(1),  ///< System bus clock
   };

   /**
    * Prescaler for the watchdog clock source
    * (wdog_presc_prescval)
    *
    * This prescaler divides the input clock for the watchdog counter
    */
   enum WdogPrescale : uint16_t {
      WdogPrescale_Direct   = WDOG_PRESC_PRESCVAL(0),  ///< Prescaler = 1
      WdogPrescale_DivBy2   = WDOG_PRESC_PRESCVAL(1),  ///< Prescaler = 2
      WdogPrescale_DivBy3   = WDOG_PRESC_PRESCVAL(2),  ///< Prescaler = 3
      WdogPrescale_DivBy4   = WDOG_PRESC_PRESCVAL(3),  ///< Prescaler = 4
      WdogPrescale_DivBy5   = WDOG_PRESC_PRESCVAL(4),  ///< Prescaler = 5
      WdogPrescale_DivBy6   = WDOG_PRESC_PRESCVAL(5),  ///< Prescaler = 6
      WdogPrescale_DivBy7   = WDOG_PRESC_PRESCVAL(6),  ///< Prescaler = 7
      WdogPrescale_DivBy8   = WDOG_PRESC_PRESCVAL(7),  ///< Prescaler = 8
   };

   /**
    * Interrupt flag.
    * (wdog_stctrll_intflg)
    *
    * It is set when an exception occurs. IRQRSTEN = 1 is a precondition to set this flag.
    * INTFLG = 1 results in an interrupt being issued followed by a reset, WCT time later. 
    * The interrupt can be cleared by writing 1 to this bit. It also gets cleared on a system reset
    */
   enum WdogException {
      WdogException_NoInterrupt        = WDOG_STCTRLL_INTFLG(0),  ///< No interrupt
      WdogException_InterruptPending   = WDOG_STCTRLL_INTFLG(1),  ///< Interrupt pending
   };

   /**
    * Watchdog refresh
    * (wdog_constants1)
    *
    * Key values needed for refreshing the WDOG
    */
   enum WdogRefresh {
      WdogRefresh_1   = 0xA602,  ///< 1st refresh value
      WdogRefresh_2   = 0xB480,  ///< 2nd refresh value
   };

   /**
    * Watchdog unlock
    * (wdog_constants2)
    *
    * Key values needed for unlocking the WDOG
    */
   enum WdogUnlock {
      WdogUnlock_1   = 0xC520,  ///< 1st unlock value
      WdogUnlock_2   = 0xD928,  ///< 2nd unlock value
   };


   // Bit operators for STCTRLH register fields
   constexpr inline uint16_t operator|(WdogEnable op1, WdogAllowUpdate op2)      { return uint16_t(op1)|uint16_t(op2); };
   constexpr inline uint16_t operator|(WdogAllowUpdate op1, WdogEnable op2)      { return uint16_t(op1)|uint16_t(op2); };
   
class WdogBasicInfo {

public:

   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   /**
    * Calculate clock frequency settings
    *
    * @param[in]     clockFrequency Input clock frequency to WDOG
    * @param[in,out] timeout        .seconds Timeout value in seconds -> .ticks   Timeout value in ticks
    * @param[in,out] window         .seconds  Window value in seconds -> .ticks   Window value in ticks
    * @param[out]    presc          Calculated prescale value (PRESC.PRESCVAL)
    *
    * @return Error code
    */
   static ErrorCode calculateTimingParameters(
         uint32_t       clockFrequency,
         Seconds_Ticks &timeout,
         Seconds_Ticks &window,
         uint16_t      &presc) {
   
      float constexpr maxCount = float(~1UL);
   
      if ((int)window.toTicks()>(int)timeout.toTicks()) {
         return E_ILLEGAL_PARAM;
      }
      Seconds maxTime = maxCount/clockFrequency;
   
      for(int prescale=1; prescale<=8; prescale++) {
         float counterFrequency = clockFrequency/(float)prescale;
         maxTime = maxCount/clockFrequency;
         if (maxTime > timeout.toSeconds()) {
            timeout.fromTicks(Ticks(roundf(float(timeout.toSeconds())*counterFrequency)));
            window.fromTicks(Ticks(roundf(float(window.toSeconds())*counterFrequency)));
            presc = WDOG_PRESC_PRESCVAL(prescale-1);
            return E_NO_ERROR;
         }
      }
      return setErrorCode(E_TOO_LARGE);
   }
   
   /**
    * Class used to do initialisation of the Wdog
    *
    * This class has a templated constructor that accepts various values.
    * Parameters available may vary with device - see Wdog::DefaultInitValue for relevant example.
    * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * ///
    * /// WDOG call-back
    * ///
    * /// @param status  Status reflecting active inputs
    * ///
    * void wdogCallback(ErrorCode ec) {
    *    ....
    * }
    *
    * static const Wdog::Init wdogInit {
    *
    *   // Setup values
    *   WdogEnable_Enabled ,          // Watchdog enable
    *   WdogEnableInWait_Disabled ,   // Enable watchdog in WAIT mode
    *   WdogEnableInStop_Disabled ,   // Enable watchdog in STOP mode
    *   WdogEnableInDebug_Disabled ,  // Enable watchdog in DEBUG mode
    *   WdogAllowUpdate_Enabled ,     // Allow watchdog update
    *   WdogWindow_Disabled ,         // Enable watchdog windowing mode
    *   WdogAction_ImmediateReset ,   // Action on watchdog event
    *   WdogClock_SystemBusClk ,      // Watchdog clock source
    *   NvicPriority_Normal,          // IRQ level for this peripheral
    *   wdogCallback,                // Call-back to execute on event - call-back function name
    *   // Either
    *   WdogPrescale_Direct ,         // Prescaler for the watchdog clock source (must be in this order)
    *   2000_ticks, 1000_ticks,       // Timeout and Window values
    *   // ____ OR ____
    *   20_seconds, 10_seconds,       // Timeout and Window values (must be in this order)
    *   // Option
    *   Wdog::DefaultInitValue,       // Take base values from DefaultInitValue
    *
    *   wdogCallback,                 // Call-back to execute on event - call-back function name
    *   NvicPriority_Low,                 // Priority for interrupt - Low
    *
    *   // Optional base value to start with (must be last parameter)
    *   Wdog::DefaultInitValue   // Used as base value modified by above
    * };
    *
    * // Initialise Wdog from values specified above
    * Wdog::configure(wdogInit)
    * @endcode
    */
   class Init {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr Init(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      // Test mode disable (wdog_stctrlh_distestwdog)
      // Enable watchdog in WAIT mode (wdog_stctrlh_waiten)
      // Enable watchdog in STOP mode (wdog_stctrlh_stopen)
      // Enable watchdog in DEBUG mode (wdog_stctrlh_dbgen)
      // Allow watchdog update (wdog_stctrlh_allowupdate)
      // Enable watchdog windowing mode (wdog_stctrlh_winen)
      // Action on watchdog event (wdog_stctrlh_irqrsten)
      // Watchdog clock source (wdog_stctrlh_clksrc)
      // Watchdog enable (wdog_stctrlh_wdogen)
      uint16_t stctrlh = 0;

      // Prescaler for the watchdog clock source (wdog_presc_prescval)
      uint16_t presc = 0;

      // IRQ priority levels (nvic_irqLevel)
      NvicPriority irqlevel = NvicPriority_Normal;

   }; // class WdogBasicInfo::Init
   
}; // class WdogBasicInfo 

class WdogInfo : public WdogBasicInfo {

public:

   /*
    * Template:wdog_mk
    */
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = WDOG_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    * Basic enable of Wdog
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
   }
   
   /**
    * Disables Wdog
    */
   static void disable() {
   
      
      disableNvicInterrupts();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = WDOG_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<WDOG_Type> wdog = baseAddress;
   
   /**
    * Writing the sequence of 0xA602 (WdogRefresh_1) followed by 0xB480 (WdogRefresh_2) within 20 bus clock
    * cycles refreshes the WDOG and prevents it from resetting the system. Writing a value other than
    * the above mentioned sequence or if the sequence is longer than 20 bus cycles, resets the system,
    * or if IRQRSTEN is set, it interrupts and then resets the system.
    *
    * @param wdogRefresh_1 1st value to write (WdogRefresh_1)
    * @param wdogRefresh_2 2nd value to write (WdogRefresh_2)
    *
    * @note This operation is time-critical so interrupts are disabled during refresh
    * @note Due to clock domain issues it is necessary to wait at least 5 clock
    *       cycles between attempted refreshes.  This is most significant when
    *       using the LPO clock source (i.e. at least 5 ms in that case).
    */
   static void refresh(WdogRefresh wdogRefresh_1, WdogRefresh wdogRefresh_2) {
   
      // Protect sequence from interrupts
      CriticalSection cs;
   
      wdog->REFRESH = wdogRefresh_1;
      wdog->REFRESH = wdogRefresh_2;
   }
   /**
    * Gets watchdog reset count.
    * This is a count of the number of watchdog timeout resets since power-on reset
    *
    * @return Count of timeout resets
    */
   static uint16_t getResetCount() {
      return wdog->RSTCNT;
   }
   
   /**
    * Gets watchdog timer value.
    *
    * @return current timer value
    */
   static Ticks getTimer() {
      return Ticks((wdog->TMROUTH<<16)|wdog->TMROUTL);
   }
   
   /**
    * Sets watchdog pre-scaler and time-out value in ticks.
    * The watchdog clock is divided by this value to provide the prescaled WDOG_CLK
    *
    * @param wdogPrescale This prescaler divides the input clock for the watchdog counter
    * @param timeout      The watchdog must be refreshed before the counter reaches this value
    * @param window       If windowed operation is enabled, then the watchdog can only be refreshed
    *        if the timer reaches a value greater than or equal to this window length value.
    *        A refresh outside of this window resets the system
    *
    * @note This is a protected operation which uses unlock
    */
   static void setTimeout(
            WdogPrescale wdogPrescale,
            Ticks        timeout,
            Ticks        window = 0_ticks) {
   
      // Disable interrupts while accessing watchdog
      CriticalSection cs;
   
      // Unlock before changing settings
      wdog->UNLOCK = WdogUnlock_1;
      wdog->UNLOCK = WdogUnlock_2;
   
      wdog->PRESC  = wdogPrescale;
      wdog->TOVALH = (unsigned)timeout>>16;
      wdog->TOVALL = (unsigned)timeout;
      wdog->WINH   = (unsigned)window>>16;
      wdog->WINL   = (unsigned)window;
   }
   /**
    * Lock watchdog register against further changes
    */
   static void lockRegisters() {
      // Protect sequence from interrupts
      CriticalSection cs;
   
      // Unlock before changing settings
      wdog->UNLOCK = WdogUnlock_1;
      wdog->UNLOCK = WdogUnlock_2;
   
      // Read-back to delay until change effected
      (void)(wdog->UNLOCK);
   
      wdog->STCTRLH = wdog->STCTRLH & ~WDOG_STCTRLH_ALLOWUPDATE_MASK;
   }
   
   /**
    * Enable/disable interrupts
    *
    * @param[in]  enable        True => enable, False => disable
    *
    * @note This is a protected operation which requires unlock
    */
   static void enableInterrupt(bool enable=true) {
      // Protect sequence from interrupts
      CriticalSection cs;
      if (enable) {
         wdog->STCTRLH = wdog->STCTRLH | WDOG_STCTRLH_IRQRSTEN_MASK;
      }
      else {
         wdog->STCTRLH = wdog->STCTRLH & ~WDOG_STCTRLH_IRQRSTEN_MASK;
      }
   }
   
   /**
    * Disable WDOG
    */
   static inline void disableWdog() {
   
      if (wdog->STCTRLH&WdogEnable_Enabled) {
   
         // Unlock before changing settings
         wdog->UNLOCK  = WdogUnlock_1;
         wdog->UNLOCK  = WdogUnlock_2;
   
         // Read-back to delay until change effected
         (void)(wdog->UNLOCK);
   
         // Disable watchdog
         wdog->STCTRLH = WdogEnable_Disabled|WdogAllowUpdate_Disabled;
      }
   }
   
}; // class WdogInfo


   /**
    * Class representing WDOG
    */
   using Wdog = WdogInfo;
   

/**
 * End WDOG_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_WDOG_H_ */
