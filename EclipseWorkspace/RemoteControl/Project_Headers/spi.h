/**
 * @file     spi.h (180.ARM_Peripherals/Project_Headers/spi-MK.h)
 * @brief    Serial Peripheral Interface
 */

#ifndef INCLUDE_USBDM_SPI_H_
#define INCLUDE_USBDM_SPI_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"
#include "gpio.h"

#include "dma.h"

#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif


// No handler defined for SPI0


namespace USBDM {

/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief C++ Class allowing access to SPI interface
 * @{
 */
/**
 * Peripheral information for SPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Transmit FIFO Fill Request interrupt/DMA enable
    * (spi_rser_txfifo)
    *
    * Enable DMA or interrupts requests on Transmit FIFO space
    */
   enum SpiTxFifoRequest {
      SpiTxFifoRequest_Disabled    = SPI_RSER_TFFF_RE(0)|SPI_RSER_TFFF_DIRS(0),  ///< No requests
      SpiTxFifoRequest_Interrupt   = SPI_RSER_TFFF_RE(1)|SPI_RSER_TFFF_DIRS(0),  ///< Interrupt
      SpiTxFifoRequest_Dma         = SPI_RSER_TFFF_RE(1)|SPI_RSER_TFFF_DIRS(1),  ///< DMA
   };

   /**
    * Receive FIFO Drain Request interrupt/DMA enable
    * (spi_rser_rxfifo)
    *
    * Enable DMA or interrupts requests on Receive FIFO data
    */
   enum SpiRxFifoRequest {
      SpiRxFifoRequest_Disabled    = SPI_RSER_RFDF_RE(0)|SPI_RSER_RFDF_DIRS(0),  ///< No requests
      SpiRxFifoRequest_Interrupt   = SPI_RSER_RFDF_RE(1)|SPI_RSER_RFDF_DIRS(0),  ///< Interrupt
      SpiRxFifoRequest_Dma         = SPI_RSER_RFDF_RE(1)|SPI_RSER_RFDF_DIRS(1),  ///< DMA
   };

   /**
    * TxFIFO Underflow interrupts
    * (spi_rser_tfuf_re)
    *
    * Controls Transmit FIFO Underflow interrupts (on TFUF flag)
    */
   enum SpiTxFifoUnderflowInterrupt {
      SpiTxFifoUnderflowInterrupt_Disabled   = SPI_RSER_TFUF_RE(0),  ///< No requests
      SpiTxFifoUnderflowInterrupt_Enabled    = SPI_RSER_TFUF_RE(1),  ///< Interrupt on underflow
   };

   /**
    * RxFIFO Overflow interrupts
    * (spi_rser_rfof_re)
    *
    * Receive FIFO Overflow interrupts (on RFOF flag)
    */
   enum SpiRxFifoOverflowInterrupt {
      SpiRxFifoOverflowInterrupt_Disabled   = SPI_RSER_RFOF_RE(0),  ///< No requests
      SpiRxFifoOverflowInterrupt_Enabled    = SPI_RSER_RFOF_RE(1),  ///< Interrupt on overflow
   };

   /**
    * Tx complete interrupts
    * (spi_rser_tcf_re)
    *
    * Transmit complete interrupts (TCF Flag)
    */
   enum SpiTxCompleteInterrupt {
      SpiTxCompleteInterrupt_Disabled   = SPI_RSER_TCF_RE(0),  ///< No requests
      SpiTxCompleteInterrupt_Enabled    = SPI_RSER_TCF_RE(1),  ///< Interrupt on completion
   };

   /**
    * EOQ interrupts
    * (spi_rser_eoqf_re)
    *
    * End of Queue interrupts (EOQF flag)
    */
   enum SpiEndOfQueueInterrupt {
      SpiEndOfQueueInterrupt_Disabled   = SPI_RSER_EOQF_RE(0),  ///< No requests
      SpiEndOfQueueInterrupt_Enabled    = SPI_RSER_EOQF_RE(1),  ///< Interrupt on end of queue
   };

   /**
    * Polarity for PCS signals
    * (spi_mcr_pcsis_enum)
    *
    * Mask to select the polarity of Peripheral Chip Select Lines (PCSx)
    * Selected PCS signals will be active-low i.e. PCS will go low when accessing the peripheral
    */
   enum SpiPcsActiveLow : uint32_t {
      SpiPcsActiveLow_Pcs0   = SPI_MCR_PCSIS(1U<<0),  ///< PCS0 is active-low
      SpiPcsActiveLow_Pcs1   = SPI_MCR_PCSIS(1U<<1),  ///< PCS1 is active-low
      SpiPcsActiveLow_Pcs2   = SPI_MCR_PCSIS(1U<<2),  ///< PCS2 is active-low
      SpiPcsActiveLow_Pcs3   = SPI_MCR_PCSIS(1U<<3),  ///< PCS3 is active-low
      SpiPcsActiveLow_Pcs4   = SPI_MCR_PCSIS(1U<<4),  ///< PCS4 is active-low
      SpiPcsActiveLow_Pcs5   = SPI_MCR_PCSIS(1U<<5),  ///< PCS5 is active-low
      SpiPcsActiveLow_None   = SPI_MCR_PCSIS(0),      ///< All PCSx active-high
      SpiPcsActiveLow_All    = SPI_MCR_PCSIS(-1),     ///< All PCSx active-low
   };


   /**
    * Combines two SpiPcsActiveLow values (by ORing)
    * Used to create a combined SpiPcsActiveLow mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return  Combined value
    */
   constexpr SpiPcsActiveLow operator|(SpiPcsActiveLow left, SpiPcsActiveLow right) {
      return SpiPcsActiveLow(uint32_t(left)|uint32_t(right));
   }
   
   /**
    * Combines two SpiPcsActiveLow values (by ANDing) to produce a bool result
    * Used to check a value against a SpiPcsActiveLow mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return boolean value indicating if the result is non-zero
    */
   constexpr bool operator&(SpiPcsActiveLow left, SpiPcsActiveLow right) {
      return bool(uint32_t(left)&uint32_t(right));
   }
   
   /**
    * Clear selected FIFOs
    * (spi_mcr_clr_fifox)
    *
    * Selectively clear transmit or receive FIFOs
    */
   enum SpiClearFifo {
      SpiClearFifo_None   = SPI_MCR_CLR_TXF(0)|SPI_MCR_CLR_RXF(0),  ///< FIFOs not affected
      SpiClearFifo_Rx     = SPI_MCR_CLR_TXF(0)|SPI_MCR_CLR_RXF(1),  ///< Clear Rx FIFO
      SpiClearFifo_Tx     = SPI_MCR_CLR_TXF(1)|SPI_MCR_CLR_RXF(0),  ///< Clear Tx FIFO
      SpiClearFifo_Both   = SPI_MCR_CLR_TXF(1)|SPI_MCR_CLR_RXF(1),  ///< Clear Rx & Tx FIFOs
   };

   /**
    * Enable selected FIFOs
    * (spi_mcr_dis_fifox)
    *
    * Selectively enable transmit or receive FIFOs
    */
   enum SpiEnableFifo {
      SpiEnableFifo_Both   = SPI_MCR_DIS_TXF(0)|SPI_MCR_DIS_RXF(0),  ///< Rx and Tx FIFOs enabled
      SpiEnableFifo_Rx     = SPI_MCR_DIS_TXF(0)|SPI_MCR_DIS_RXF(1),  ///< Enable Rx FIFO
      SpiEnableFifo_Tx     = SPI_MCR_DIS_TXF(1)|SPI_MCR_DIS_RXF(0),  ///< Enable Tx FIFO
      SpiEnableFifo_None   = SPI_MCR_DIS_TXF(1)|SPI_MCR_DIS_RXF(1),  ///< Disable Rx & Tx FIFOs
   };

   /**
    * Master or Slave operation
    * (spi_mcr_mstr)
    *
    * Whether to operate as Master or Slave device
    */
   enum SpiMasterSlave {
      SpiMasterSlave_Slave    = SPI_MCR_MSTR(0),  ///< Operate as Master
      SpiMasterSlave_Master   = SPI_MCR_MSTR(1),  ///< Operate as Slave
   };

   /**
    * Modified Timing Format
    * (spi_mcr_mtfe)
    *
    * Controls when the module master samples serial-in,
    * This field is only valid when CPHA bit 0.
    */
   enum SpiModifiedTiming {
      SpiModifiedTiming_Normal     = SPI_MCR_MTFE(0)|SPI_MCR_SMPL_PT(0),  ///< Normal Timing
      SpiModifiedTiming_0_Clocks   = SPI_MCR_MTFE(1)|SPI_MCR_SMPL_PT(0),  ///< No delay from SCK edge to SIN sample
      SpiModifiedTiming_1_Clocks   = SPI_MCR_MTFE(1)|SPI_MCR_SMPL_PT(1),  ///< 1 clock  from SCK edge to SIN sample
      SpiModifiedTiming_2_Clocks   = SPI_MCR_MTFE(1)|SPI_MCR_SMPL_PT(2),  ///< 2 clocks from SCK edge to SIN sample
   };

   /**
    * Handling of Rx Overflow Data
    * (spi_mcr_rooe)
    *
    * Discard incoming data or overwite previous data on RxFIFO overflow
    */
   enum SpiRxOverflowHandling {
      SpiRxOverflowHandling_Ignore      = SPI_MCR_ROOE(0),  ///< Ignore incoming
      SpiRxOverflowHandling_Overwrite   = SPI_MCR_ROOE(1),  ///< Overwrite existing
   };

   /**
    * Enables Doze mode (when processor is waiting?)
    * (spi_mcr_doze)
    *
    * Enables Doze mode (when processor is waiting?)
    */
   enum SpiDoze {
      SpiDoze_Disabled   = SPI_MCR_DOZE(0),  ///< Ignore doze
      SpiDoze_Enabled    = SPI_MCR_DOZE(1),  ///< Suspend in doze
   };

   /**
    * Controls SPI operation while in debug mode
    * (spi_mcr_frz)
    *
    * Enable transfers to be stopped on the next frame boundary when the device enters Debug mode.
    */
   enum SpiFreeze {
      SpiFreeze_Disabled   = SPI_MCR_FRZ(0),  ///< Continue in debug
      SpiFreeze_Enabled    = SPI_MCR_FRZ(1),  ///< Suspend in debug
   };

   /**
    * Continuous SCK Enable
    * (spi_mcr_cont_scke)
    *
    * Whether the Serial Communication Clock (SCK) runs continuously
    */
   enum SpiContinuousClock {
      SpiContinuousClock_Disable   = SPI_MCR_CONT_SCKE(0),  ///< Clock during transfers only
      SpiContinuousClock_Enable    = SPI_MCR_CONT_SCKE(1),  ///< Continuous clock
   };

   /**
    * Mode
    * (spi_ctar_mode[0])
    *
    * Communication mode
    * 0: Active-high clock (idles low), Data is captured on leading edge of SCK and changes on the following edge.
    * 1: Active-high clock (idles low), Data changes on leading edge of SCK and is captured on the following edge.
    * 2: Active-low clock (idles high), Data is captured on leading edge of SCK and changes on the following edge.
    * 3: Active-low clock (idles high), Data changes on leading edge of SCK and is captured on the following edge.
    */
   enum SpiMode {
      SpiMode_0   = SPI_CTAR_CPOL(0)|SPI_CTAR_CPHA(0),  ///< Mode 0: CPOL=0, CPHA=0
      SpiMode_1   = SPI_CTAR_CPOL(0)|SPI_CTAR_CPHA(1),  ///< Mode 1: CPOL=0, CPHA=1
      SpiMode_2   = SPI_CTAR_CPOL(1)|SPI_CTAR_CPHA(0),  ///< Mode 2: CPOL=1, CPHA=0
      SpiMode_3   = SPI_CTAR_CPOL(1)|SPI_CTAR_CPHA(1),  ///< Mode 3: CPOL=1, CPHA=1
   };

   /**
    * SPI Frame sizes
    * (spi_ctar_fmsz[0])
    *
    * Transfers are from 4 to 16 bits in size
    */
   enum SpiFrameSize {
      SpiFrameSize_4_bits    = SPI_CTAR_FMSZ(4-1),   ///< 4 bits/transfer
      SpiFrameSize_5_bits    = SPI_CTAR_FMSZ(5-1),   ///< 5 bits/transfer
      SpiFrameSize_6_bits    = SPI_CTAR_FMSZ(6-1),   ///< 6 bits/transfer
      SpiFrameSize_7_bits    = SPI_CTAR_FMSZ(7-1),   ///< 7 bits/transfer
      SpiFrameSize_8_bits    = SPI_CTAR_FMSZ(8-1),   ///< 8 bits/transfer
      SpiFrameSize_9_bits    = SPI_CTAR_FMSZ(9-1),   ///< 9 bits/transfer
      SpiFrameSize_10_bits   = SPI_CTAR_FMSZ(10-1),  ///< 10 bits/transfer
      SpiFrameSize_11_bits   = SPI_CTAR_FMSZ(11-1),  ///< 11 bits/transfer
      SpiFrameSize_12_bits   = SPI_CTAR_FMSZ(12-1),  ///< 12 bits/transfer
      SpiFrameSize_13_bits   = SPI_CTAR_FMSZ(13-1),  ///< 13 bits/transfer
      SpiFrameSize_14_bits   = SPI_CTAR_FMSZ(14-1),  ///< 14 bits/transfer
      SpiFrameSize_15_bits   = SPI_CTAR_FMSZ(15-1),  ///< 15 bits/transfer
      SpiFrameSize_16_bits   = SPI_CTAR_FMSZ(16-1),  ///< 16 bits/transfer
   };

   /**
    * Transmission order
    * (spi_ctar_lsbfe[0])
    *
    * Transmission order
    */
   enum SpiBitOrder {
      SpiBitOrder_MsbFirst   = SPI_CTAR_LSBFE(0),  ///< MSB sent first
      SpiBitOrder_LsbFirst   = SPI_CTAR_LSBFE(1),  ///< LSB sent first
   };

   /**
    * CTAR Selection
    * (spi_ctar_sel)
    *
    * Selects between available CTAR registers
    */
   enum SpiCtarSelect : uint8_t {
      SpiCtarSelect_0   = 0,  ///< CTAR 0
      SpiCtarSelect_1   = 1,  ///< CTAR 1
   };

   /**
    * Behaviour of peripheral select signals between transfers/transactions
    * (PeripheralSelectMode)
    *
    * Select whether Peripheral Select is returned to idle between transfers or transactions
    */
   enum SpiPeripheralSelectMode : uint8_t {
      SpiPeripheralSelectMode_Transfer      = (0),  ///< Asserted for each transfer within transaction
      SpiPeripheralSelectMode_Transaction   = (1),  ///< Asserted for entire transaction
      SpiPeripheralSelectMode_Continuous    = (2),  ///< Asserted until another device is selected
   };

   /**
    * Assert PCS between transfers
    * (spi_pushr_cont)
    *
    * Select whether Peripheral Select is returned to idle between transfers
    */
   enum SpiSelectMode {
      SpiSelectMode_Idle         = SPI_PUSHR_CONT(0),  ///< Idle between transfers
      SpiSelectMode_Continuous   = SPI_PUSHR_CONT(1),  ///< Asserted between transfers
   };

   /**
    * Peripheral Chip Select
    * (spi_pushr_pcs_enum)
    *
    * Mask to select which Peripheral Chip Select Line (PCS) to assert during transaction
    * Note: more than one PCS may be asserted (allows use of an external decoder)
    */
   enum SpiPeripheralSelect : uint32_t {
      SpiPeripheralSelect_Pcs0   = SPI_PUSHR_PCS(1U<<0),  ///< Assert PCS0 during transaction
      SpiPeripheralSelect_Pcs1   = SPI_PUSHR_PCS(1U<<1),  ///< Assert PCS1 during transaction
      SpiPeripheralSelect_Pcs2   = SPI_PUSHR_PCS(1U<<2),  ///< Assert PCS2 during transaction
      SpiPeripheralSelect_Pcs3   = SPI_PUSHR_PCS(1U<<3),  ///< Assert PCS3 during transaction
      SpiPeripheralSelect_Pcs4   = SPI_PUSHR_PCS(1U<<4),  ///< Assert PCS4 during transaction
      SpiPeripheralSelect_Pcs5   = SPI_PUSHR_PCS(1U<<5),  ///< Assert PCS5 during transaction
      SpiPeripheralSelect_None   = SPI_PUSHR_PCS(0),      ///< PCSx not asserted
   };


   /**
    * Combines two SpiPeripheralSelect values (by ORing)
    * Used to create a combined SpiPeripheralSelect mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return  Combined value
    */
   constexpr SpiPeripheralSelect operator|(SpiPeripheralSelect left, SpiPeripheralSelect right) {
      return SpiPeripheralSelect(uint32_t(left)|uint32_t(right));
   }
   
   /**
    * Combines two SpiPeripheralSelect values (by ANDing) to produce a bool result
    * Used to check a value against a SpiPeripheralSelect mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return boolean value indicating if the result is non-zero
    */
   constexpr bool operator&(SpiPeripheralSelect left, SpiPeripheralSelect right) {
      return bool(uint32_t(left)&uint32_t(right));
   }
   
class SpiBasicInfo {

public:
   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   /**
    * Class used to hold a calculated configuration that may be reused to avoid calculation overhead
    */
   class SpiCalculatedConfiguration {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr SpiCalculatedConfiguration(const SpiCalculatedConfiguration &other) = default;
   
      uint16_t pushrCommand       = 0;   //!<  PUSHR.COMMAND register value for most transfer
      uint16_t pushrFinalCommand  = 0;   //!<  PUSHR.COMMAND register value for final transfer
      uint32_t ctar               = 0;   //!<  CTAR register value e.g. Baud, number of bits, timing
   
      /**
       * Default Constructor
       */
      constexpr SpiCalculatedConfiguration() = default;
   
      /**
       * Constructor
       */
      SpiCalculatedConfiguration(uint16_t pushrCommand, uint16_t pushrFinalCommand, uint32_t ctar) :
         pushrCommand(pushrCommand),
         pushrFinalCommand(pushrFinalCommand),
         ctar(ctar) {
      }
   }; // class SerialInit

   
   /**
    * Class used to do initialisation of a CTAR in Spi0
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * // Initialisation values for Spi0
    * // Options available vary with device - See Spi0::DefaultInitValue for example
    * static const Spi0::SerialInit serialInit {
    *
    *    // Omitted parameters are take to be zero unless a base value is given
    *
    *    SpiCtarSelect_1,        // CTAR 1 initialisation
    *    1_MHz ,                 // Speed of interface
    *    SpiMode_o ,             // Mode - Mode 0: CPOL=0, CPHA=0
    *    SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
    *    SpiBitOrder_LsbFirst,   // Transmission order - LSB sent first
    *
    *    // Optional base value to start with (must be last parameter)
    *    Spi1::DefaultSerialInitValue,
    * };
    *
    * // Initialise SPI from values specified above
    * Spi0::configure(serialInit);
    * @endcode
    */
   class SerialInit {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr SerialInit(const SerialInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr SerialInit() = default;
   
      ///  CTAR Selection
      SpiCtarSelect ctarNum = SpiCtarSelect_0;

      ///  Clock and Transfer Attributes Register
      uint32_t ctar = 0;

      ///  Module Configuration Register
      uint32_t speed = 0_Hz;

      /**
       * Constructor for Mode
       * (spi_ctar_mode)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiMode Communication mode
       *        0: Active-high clock (idles low), Data is captured on leading edge of SCK and changes on the following edge.
       *        1: Active-high clock (idles low), Data changes on leading edge of SCK and is captured on the following edge.
       *        2: Active-low clock (idles high), Data is captured on leading edge of SCK and changes on the following edge.
       *        3: Active-low clock (idles high), Data changes on leading edge of SCK and is captured on the following edge.
       */
      template <typename... Types>
      constexpr SerialInit(SpiMode spiMode, Types... rest) : SerialInit(rest...) {
   
         ctar = (ctar&~(SPI_CTAR_CPOL_MASK|SPI_CTAR_CPHA_MASK)) | spiMode;
      }
   
      /**
       * Constructor for SPI Frame sizes
       * (spi_ctar_fmsz)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiFrameSize Transfers are from 4 to 16 bits in size
       */
      template <typename... Types>
      constexpr SerialInit(SpiFrameSize spiFrameSize, Types... rest) : SerialInit(rest...) {
   
         ctar = (ctar&~SPI_CTAR_FMSZ_MASK) | spiFrameSize;
      }
   
      /**
       * Constructor for Transmission order
       * (spi_ctar_lsbfe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiBitOrder Transmission order
       */
      template <typename... Types>
      constexpr SerialInit(SpiBitOrder spiBitOrder, Types... rest) : SerialInit(rest...) {
   
         ctar = (ctar&~SPI_CTAR_LSBFE_MASK) | spiBitOrder;
      }
   
      /**
       * Constructor for Speed of interface
       * (speed)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param hertz Speed of transmission
       */
      template <typename... Types>
      constexpr SerialInit(const Hertz& hertz, Types... rest) : SerialInit(rest...) {
   
         speed = hertz;
      }
   
      /**
       * CTAR Selection
       * (spi_ctar_sel)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiCtarSelect Selects between available CTAR registers
       */
      template <typename... Types>
      constexpr SerialInit(SpiCtarSelect spiCtarSelect, Types... rest) : SerialInit(rest...) {
   
         ctarNum = spiCtarSelect;
      }
   
   }; // class SerialInit
   /**
    * Class used to do initialisation of shared settings for Spi0
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * // Initialisation values for Spi0
    * // Options available vary with device - See Spi0::DefaultConfigValue for example
    * static const Spi0::Config spiConfig {
    *
    *    // Omitted parameters are take to be zero unless a base value is given
    *
    *    // Common setting that are seldom changed
    *    SpiModifiedTiming_Normal ,                   // Modified Timing Format - Normal Timing
    *    SpiPcsMode_PCS5 ,                            // PCS5/PCSS* pin mode - PCS5/PCSS normal operation (PCS5)
    *    SpiDoze_Enabled ,                            // Enables Doze mode (when processor is waiting?) - Suspend in doze
    *    SpiFreeze_Enabled ,                          // Controls SPI operation while in debug mode - Suspend in debug
    *    SpiRxOverflowHandling_Overwrite ,            // Handling of Rx Overflow Data - Overwrite existing
    *    SpiContinuousClock_Disable,                  // Continuous SCK Enable - Clock during transfers only
    *    SpiPcsPolarity_3_ActiveLow,                  // Polarity for PCS signals (similar lines may be repeated)
    *
    *    // The following are initial settings that would commonly be changed by selectConfiguration()
    *    SpiPeripheralSelect_Ptc4 ,              // Peripheral to select
    *    SpiCtarSelect_1,                        // CTAR to use
    *    SpiPeripheralSelectMode_Transaction     // Peripheral select mode
    *
    *    // Optional base value to start with (must be last parameter)
    *    Spi0::DefaultValue
    * };
    *
    * @endcode
    */
   class Config {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Config(const Config &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Config() = default;
   
      ///  Module Configuration Register
      uint32_t mcr = 0;

      ///  PUSHR values
      uint32_t pushr      = 0;
      uint32_t pushrFinal = 0;
   
      /**
       * Constructor for Modified Timing Format
       * (spi_mcr_mtfe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiModifiedTiming Controls when the module master samples serial-in,
       *        This field is only valid when CPHA bit 0.
       */
      template <typename... Types>
      constexpr Config(SpiModifiedTiming spiModifiedTiming, Types... rest) : Config(rest...) {
   
         mcr = (mcr&~(SPI_MCR_MTFE_MASK|SPI_MCR_SMPL_PT_MASK)) | spiModifiedTiming;
      }
   
      /**
       * Constructor for Enables Doze mode (when processor is waiting?)
       * (spi_mcr_doze)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiDoze Enables Doze mode (when processor is waiting?)
       */
      template <typename... Types>
      constexpr Config(SpiDoze spiDoze, Types... rest) : Config(rest...) {
   
         mcr = (mcr&~SPI_MCR_DOZE_MASK) | spiDoze;
      }
   
      /**
       * Constructor for Controls SPI operation while in debug mode
       * (spi_mcr_frz)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiFreeze Enable transfers to be stopped on the next frame boundary when the device enters Debug mode.
       */
      template <typename... Types>
      constexpr Config(SpiFreeze spiFreeze, Types... rest) : Config(rest...) {
   
         mcr = (mcr&~SPI_MCR_FRZ_MASK) | spiFreeze;
      }
   
      /**
       * Constructor for Handling of Rx Overflow Data
       * (spi_mcr_rooe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiRxOverflowHandling Discard incoming data or overwite previous data on RxFIFO overflow
       */
      template <typename... Types>
      constexpr Config(SpiRxOverflowHandling spiRxOverflowHandling, Types... rest) : Config(rest...) {
   
         mcr = (mcr&~SPI_MCR_ROOE_MASK) | spiRxOverflowHandling;
      }
   
      /**
       * Constructor for Continuous SCK Enable
       * (spi_mcr_cont_scke)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiContinuousClock Whether the Serial Communication Clock (SCK) runs continuously
       */
      template <typename... Types>
      constexpr Config(SpiContinuousClock spiContinuousClock, Types... rest) : Config(rest...) {
   
         mcr = (mcr&~SPI_MCR_CONT_SCKE_MASK) | spiContinuousClock;
      }
   
      /**
       * Constructor for Active-low PCSx
       * By default PCSx signals are active-high i.e. they are high to indicate a transfers/transactions
       * This constructor changes the given PCSx to active-low i.e. PCSx will go low for transfer
       * (spi_mcr_pcsis)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiPcsActiveLow PCS signal to be made Active-low
       *                         SpiPcsActiveLow_None clears all selections
       *                         SpiPcsActiveLow_PCSn values are cumulative
       */
      template <typename... Types>
      constexpr Config(SpiPcsActiveLow spiPcsActiveLow, Types... rest) : Config(rest...) {
   
         if (spiPcsActiveLow == SpiPcsActiveLow_None) {
            mcr &= ~SPI_MCR_PCSIS_MASK;
         }
         else {
            mcr |= spiPcsActiveLow;
         }
      }
   
      /**
       * Constructor for initial Peripheral selection
       * (spi_pushr_pcs)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiPeripheralSelect PCS signal to assert during transfers
       *                SpiPeripheralSelect_None clears all selections
       *                SpiPeripheralSelect_XXXX values are cumulative
       */
      template <typename... Types>
      constexpr Config(SpiPeripheralSelect spiPeripheralSelect, Types... rest) : Config(rest...) {
   
         if (spiPeripheralSelect == SpiPeripheralSelect_None) {
            pushr      &= ~SPI_PUSHR_PCS_MASK;
            pushrFinal &= ~SPI_PUSHR_PCS_MASK;
         }
         else {
            pushr      |= spiPeripheralSelect;
            pushrFinal |= spiPeripheralSelect;
         }
      }
   
      /**
       * Constructor for initial CTAR selection
       * (spi_ctar_sel)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiCtarSelect CTAR to use during transfers
       */
      template <typename... Types>
      constexpr Config(SpiCtarSelect spiCtarSelect, Types... rest) : Config(rest...) {
   
         pushr      = (pushr      & ~SPI_PUSHR_CTAS_MASK)|SPI_PUSHR_CTAS(spiCtarSelect);
         pushrFinal = (pushrFinal & ~SPI_PUSHR_CTAS_MASK)|SPI_PUSHR_CTAS(spiCtarSelect);
      }
   
      /**
       * Constructor for initial Peripheral selection timing
       * (PeripheralSelectMode)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param spiPeripheralSelectMode Behaviour of peripheral select signals between transfers/transactions
       */
      template <typename... Types>
      constexpr Config(SpiPeripheralSelectMode spiPeripheralSelectMode, Types... rest) : Config(rest...) {
   
         pushr      |= (spiPeripheralSelectMode>=1)?SPI_PUSHR_CONT_MASK:0;
         pushrFinal |= (spiPeripheralSelectMode>=2)?SPI_PUSHR_CONT_MASK:0;
      }
   
   }; // class Config
   /**
    * Class used to do initialisation of Spi0
    *
    * This class has multiple constructors that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example1:
    * This example breaks the initialisation into several constants which may allow re-use
    * @code
    * // Shared init values
    * static constexpr Config SharedConfigValue = {
    *    // Common setting that are seldom changed
    *    SpiModifiedTiming_Normal ,                   // Modified Timing Format - Normal Timing
    *    SpiPcsMode_PCS5 ,                            // PCS5/PCSS* pin mode - PCS5/PCSS normal operation (PCS5)
    *    SpiDoze_Enabled ,                            // Enables Doze mode (when processor is waiting?) - Suspend in doze
    *    SpiFreeze_Enabled ,                          // Controls SPI operation while in debug mode - Suspend in debug
    *    SpiRxOverflowHandling_Overwrite ,            // Handling of Rx Overflow Data - Overwrite existing
    *    SpiContinuousClock_Disable,                  // Continuous SCK Enable - Clock during transfers only
    *    SpiPcsPolarity_3_ActiveLow,                  // Polarity for PCS signals (similar lines may be repeated)
    *
    *    // The following are initial settings that would commonly be changed by selectConfiguration()
    *    SpiPeripheralSelect_Ptc4 ,              // Peripheral to select
    *    SpiCtarSelect_1,                        // CTAR to use
    *    SpiPeripheralSelectMode_Transaction     // Peripheral select mode
    * };
    *
    * static constexpr SerialInit SerialInitValue0 = {
    *       SpiCtarSelect_0,        // CTAR 0 initialisation
    *       10_MHz ,                // Speed of interface
    *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
    *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
    *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
    *
    *       // Optional base value to start with (must be last parameter)
    *       Spi1::DefaultSerialInitValue,
    * };
    *
    * static constexpr SerialInit SerialInitValue1 = {
    *       SpiCtarSelect_1,        // CTAR 1 initialisation
    *       1_MHz ,                 // Speed of interface
    *       SpiMode_o ,             // Mode - Mode 0: CPOL=0, CPHA=0
    *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
    *       SpiBitOrder_LsbFirst,   // Transmission order - LSB sent first
    *
    *       // Optional base value to start with (must be last parameter)
    *       Spi1::DefaultSerialInitValue,
    * };
    *
    * // Initialisation values for Spi0
    * static const Spi0::Init spiInit {
    *    SharedConfigValue,
    *    SerialInitValue0,
    *    SerialInitValue1
    * };
    *
    * // Initialise SPI from values specified above
    * Spi0::configure(spiInit);
    * @endcode
    *
    * Example2:
    * This example shows an all-in-one intialisation
    * @code
    * // Initialisation values for Spi0
    * // Options available vary with device - See Spi0::DefaultInitValue for example
    * static const Spi0::Init spiInit {
    *
    *    // Omitted parameters are take to be zero unless a base value is given
    *    {
    *    // Common setting that are seldom changed
    *    SpiModifiedTiming_Normal ,                   // Modified Timing Format - Normal Timing
    *    SpiPcsMode_PCS5 ,                            // PCS5/PCSS* pin mode - PCS5/PCSS normal operation (PCS5)
    *    SpiDoze_Enabled ,                            // Enables Doze mode (when processor is waiting?) - Suspend in doze
    *    SpiFreeze_Enabled ,                          // Controls SPI operation while in debug mode - Suspend in debug
    *    SpiRxOverflowHandling_Overwrite ,            // Handling of Rx Overflow Data - Overwrite existing
    *    SpiContinuousClock_Disable,                  // Continuous SCK Enable - Clock during transfers only
    *    SpiPcsPolarity_3_ActiveLow,                  // Polarity for PCS signals (similar lines may be repeated)
    *
    *    // The following are initial settings that would commonly be changed by selectConfiguration()
    *    SpiPeripheralSelect_Ptc4 ,              // Peripheral to select
    *    SpiCtarSelect_1,                        // CTAR to use
    *    SpiPeripheralSelectMode_Transaction     // Peripheral select mode
    *    },
    *    {
    *       // CTAR 0 initialisation
    *       10_MHz ,                // Speed of interface
    *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
    *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
    *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
    *    },
    *    {
    *       // CTAR 1 initialisation - May be ommited
    *       1_MHz ,                 // Speed of interface
    *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
    *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
    *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
    *    },
    *
    *    // Optional base value to start with (must be last parameter)
    *    Spi0::DefaultValue
    * };
    *
    * // Initialise SPI from values specified above
    * Spi0::configure(spiInit);
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      ///  Used to construct CTARx values
      SerialInit ctars[2];
   
      /// Common configuration
      Config config;
   
      /**
       * Constructor for CTAR0, CTAR1 values
       *
       * @tparam   Types
       * @param    rest
       *
       * @param config  Shared configuration values
       * @param ctar0   Configuration values for CTAR0
       * @param ctar1   Configuration values for CTAR1
       */
      template <typename... Types>
      constexpr Init(const Config &config, const SerialInit &ctar0, const SerialInit &ctar1, Types... rest) : Init(rest...) {
   
         this->config     = config;
         ctars[0]         = ctar0;
         ctars[0].ctarNum = SpiCtarSelect_0;
         ctars[1]         = ctar1;
         ctars[1].ctarNum = SpiCtarSelect_1;
      }
   
      /**
       * Constructor for CTAR0, CTAR1 values
       *
       * @tparam   Types
       * @param    rest
       *
       * @param config  Shared configuration values
       * @param ctar    Configuration values for all CTARs
       */
      template <typename... Types>
      constexpr Init(const Config &config, const SerialInit &ctar, Types... rest) : Init(rest...) {
   
         this->config     = config;
         ctars[0]         = ctar;
         ctars[0].ctarNum = SpiCtarSelect_0;
         ctars[1]         = ctar;
         ctars[1].ctarNum = SpiCtarSelect_1;
      }
   
   }; // class Init
   
}; // class SpiBasicInfo 

class Spi0Info : public SpiBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: SPI0_SCK             = PTC5(p38)                      */  { PinIndex::PTC5,         PcrValue(0x00200UL) },
         /*   1: SPI0_SIN             = PTC7(p40)                      */  { PinIndex::PTC7,         PcrValue(0x00200UL) },
         /*   2: SPI0_SOUT            = PTC6(p39)                      */  { PinIndex::PTC6,         PcrValue(0x00200UL) },
         /*   3: SPI0_PCS0            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: SPI0_PCS1            = PTC3(p36)                      */  { PinIndex::PTC3,         PcrValue(0x00200UL) },
         /*   5: SPI0_PCS2            = PTC2(p35)                      */  { PinIndex::PTC2,         PcrValue(0x00200UL) },
         /*   6: SPI0_PCS3            = PTC1(p34)                      */  { PinIndex::PTC1,         PcrValue(0x00200UL) },
         /*   7: SPI0_PCS4            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTC_CLOCK_MASK);
      PORTC->GPCLR = (0x0200UL|PORT_GPCLR_GPWE(0x00EEUL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTC_CLOCK_MASK);
      PORTC->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x00EEUL);
   }

   /*
    * Template:spi0_mk_pcsis6
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with SPI0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with SPI0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = SPI0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Spi0
    */
   static void enableClock() {
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_SPI0_MASK;
   }
   
   /**
    *  Disable clock to Spi0
    */
   static void disableClock() {
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_SPI0_MASK;
   }
   
   /**
    * Basic enable of Spi0
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      enableClock();
      configureAllPins();
   }
   
   /**
    * Disables Spi0
    */
   static void disable() {
   
      
      disableNvicInterrupts();
      disableAllPins();
      disableClock();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SPI0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<SPI_Type> spi = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   //! Pin number in Info table for SCK if mapped to a pin
   static constexpr int sckPin  = 0;

   //! Pin number in Info table for SIN if mapped to a pin
   static constexpr int sinPin  = 1;

   //! Pin number in Info table for SOUT if mapped to a pin
   static constexpr int soutPin  = 2;

   /**
    * Default initialisation value for Spi0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr SpiBasicInfo::SerialInit DefaultSerialInitValue[] = {
   {
      SpiCtarSelect_0,

      10000000_Hz ,                // (speed[0])                 Speed of interface
      SpiMode_0 ,                  // (spi_ctar_mode[0])         Mode - Mode 0: CPOL=0, CPHA=0
      SpiFrameSize_8_bits ,        // (spi_ctar_fmsz[0])         SPI Frame sizes - 8 bits/transfer
      SpiBitOrder_MsbFirst,        // (spi_ctar_lsbfe[0])        Transmission order - MSB sent first
   },
   {
      SpiCtarSelect_1,

      10000000_Hz ,                // (speed[1])                 Speed of interface
      SpiMode_0 ,                  // (spi_ctar_mode[1])         Mode - Mode 0: CPOL=0, CPHA=0
      SpiFrameSize_8_bits ,        // (spi_ctar_fmsz[1])         SPI Frame sizes - 8 bits/transfer
      SpiBitOrder_MsbFirst,        // (spi_ctar_lsbfe[1])        Transmission order - MSB sent first
   },
   };
   
   /**
    * Default initialisation value for Spi0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr SpiBasicInfo::Config DefaultConfigValue = {
      SpiModifiedTiming_Normal ,   // (spi_mcr_mtfe)             Modified Timing Format - Normal Timing
      SpiDoze_Enabled ,            // (spi_mcr_doze)             Enables Doze mode (when processor is waiting?) - Suspend in doze
      SpiFreeze_Enabled ,          // (spi_mcr_frz)              Controls SPI operation while in debug mode - Suspend in debug
   
   };

   /**
    * Default initialisation value for Spi0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr SpiBasicInfo::Init DefaultInitValue = {
      DefaultConfigValue,
      DefaultSerialInitValue[0],
      DefaultSerialInitValue[1],
   };

   /**
    * Get SPI input clock frequency
    *
    * @return Frequency in Hz
    */
   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

}; // class Spi0Info


/**
 * @brief Base class for representing an SPI interface
 */
class Spi : public SpiBasicInfo {

   template<unsigned itemCount>
   friend class SpiDmaHandlerBase;
   template<class Info>
   friend class SpiBase_T;

protected:

   /** Hardware pointer */
   const HardwarePtr<SPI_Type> spi;

   /**
    * Value to combine with transmit data
    * Controls which device (PCS), configuration (CTAR) and PCS assertion between transfers (CONT)
    */
   uint32_t  pushrMask;

   /**
    * Value to combine with transmit data
    * Controls which device (PCS), configuration (CTAR) and PCS assertion between transactions (CONT)
    */
   uint32_t  pushrMaskFinal;

//   /**
//    * Callback function type
//    */
//   CallbackFunction callback = unhandledCallback;
//
//#if true
//   /**
//    * Callback function (trampoline)
//    */
//   void irqHandler(uint32_t status) {
//      callback(status);
//   }
//
//   struct IrqInformation {
//      Spi *This;
//   };
//
//   // Table used to obtain SPI class instance from static interrupt handler
//   static IrqInformation irqInformation[];
//#endif

   /**
    * Constructor
    *
    * @param[in]  baseAddress    Base address of SPI
    */
   Spi(uint32_t baseAddress) :
      spi(baseAddress), pushrMask(0), pushrMaskFinal(0) {
   }

   /**
    * Destructor
    */
   virtual ~Spi() {
   }

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback(uint32_t) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /**
    * Calculate communication speed from SPI clock frequency and speed factors
    *
    * @param[in]  clockFrequency  Clock frequency of SPI in Hz
    * @param[in]  spiCtarSelect   CTAR selection providing SPI_CTAR_BR, SPI_CTAR_PBR fields
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
   uint32_t calculateSpeed(uint32_t clockFrequency, SpiCtarSelect spiCtarSelect) {
      return calculateSpeed(clockFrequency, spi->CTAR[spiCtarSelect]);
   }

   /**
    * Calculate Delay factors
    * Used for ASC, DT and CSSCK
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  delay_ns       Desired delay in nanoseconds
    * @param[out] bestPrescale   Best prescaler value (0=>/1, 1=>/3, 2=/5, 3=>/7)
    * @param[out] bestDivider    Best divider value (N=>/(2**(N+1)))
    *
    * Note: Determines bestPrescaler and bestDivider for the smallest delay that is not less than delay.
    */
   static void calculateDelay(uint32_t clockFrequency, uint32_t delay_ns, int &bestPrescale, int &bestDivider);

   /**
    * Calculate communication speed factors for SPI
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  frequency      Communication frequency in Hz
    *
    * @return CTAR register value only including (BR and PBR)
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   static uint32_t calculateDividers(uint32_t clockFrequency, uint32_t frequency);

   /**
    * Get the frequency of the input clock to the SPI
    *
    * @return Frequency on Hz
    */
   virtual uint32_t getSpiInputClockFrequency() = 0;

   /**
    * Set SPI.CTAR0 value
    *
    * @param[in]  ctar 32-bit CTAR value
    */
   void setCtar0Value(uint32_t ctar) {
      spi->CTAR[0] = ctar;
   }

   /**
    * Set SPI.CTAR1 value
    *
    * @param[in]  ctar 32-bit CTAR value
    */
   void setCtar1Value(uint32_t ctar) {
      spi->CTAR[1] = ctar;
   }

   /**
    * Get SPI.CTAR0 value
    *
    * @return ctar 32-bit CTAR value
    */
   uint32_t getCtar0Value() {
      return spi->CTAR[0];
   }

   /**
    * Get SPI.CTAR1 value
    *
    * @return ctar 32-bit CTAR value
    */
   uint32_t getCtar1Value() {
      return spi->CTAR[1];
   }

   /**
    * Calculate SPI selection for a transaction
    *
    * @param[in]  spiCtarSelect           CTAR to select during transfer
    * @param[in]  spiPeripheralSelect     Peripheral(s) to select for transfer
    * @param[in]  spiPeripheralSelectMode Behaviour of peripheral select signals between transfers/transactions
    * @param[out] pushrMask               PUSHR value for intermediate transfers within a transaction
    * @param[out] pushrMaskFinal          PUSHR value for final transfer in transaction
    */
   static void calculatePeripheralSelect(
         SpiCtarSelect           spiCtarSelect,
         SpiPeripheralSelect     spiPeripheralSelect,
         SpiPeripheralSelectMode spiPeripheralSelectMode,
         uint32_t                &pushrMask,
         uint32_t                &pushrMaskFinal
         ) {
      //                                        Transfer          : Transaction             : Continuous, ;
      static const SpiSelectMode val[]      = {SpiSelectMode_Idle, SpiSelectMode_Continuous, SpiSelectMode_Continuous};
      static const SpiSelectMode valFinal[] = {SpiSelectMode_Idle, SpiSelectMode_Idle,       SpiSelectMode_Continuous};

      // Common bits
      uint32_t common = SPI_PUSHR_CTAS(spiCtarSelect)|spiPeripheralSelect;

      // Value used for each transfer i.e. controls PCS assertion between transfers
      pushrMask      = common|val[spiPeripheralSelectMode];

      // Value used for last transfer in each transaction i.e. controls PCS assertion between transactions
      pushrMaskFinal = common|valFinal[spiPeripheralSelectMode];
   }

   /**
    * Sets Communication mode for SPI
    *
    * @param[in] spiMode       Controls clock polarity and the timing relationship between clock and data
    * @param[in] spiBitOrder   Bit transmission order (LSB/MSB first)
    * @param[in] spiCtarSelect Configuration to modify
    */
   void setMode(SpiMode spiMode=SpiMode_0, SpiBitOrder spiBitOrder=SpiBitOrder_MsbFirst, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      // Sets the default CTAR value with 8 bits
      spi->CTAR[spiCtarSelect] =
         (spiMode|spiBitOrder)|
         (spi->CTAR[spiCtarSelect]&~(SPI_CTAR_MODE_MASK|SPI_CTAR_LSBFE_MASK));
   }

   /**
    * Sets Communication mode for SPI
    *
    * @param[in]  spiFrameSize  Number of bits in each transfer
    * @param[in]  spiCtarSelect Configuration to modify
    */
   void setFrameSize(SpiFrameSize spiFrameSize, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      // Sets the frame size in CTAR
      spi->CTAR[spiCtarSelect] = (spi->CTAR[spiCtarSelect]&~(SPI_CTAR_FMSZ_MASK)) | spiFrameSize;
   }

   /**
    * Sets up hardware peripheral select (SPI_PCSx) for transfer.
    * Also controls which CTAR is used for the transaction.
    *
    * @param[in]  spiPeripheralSelect     Peripheral(s) to select for transfer
    * @param[in]  spiPeripheralSelectMode Behaviour of peripheral select signals between transfers/transactions
    * @param[in]  spiCtarSelect           Which configuration to use for transaction
    */
   void setPeripheralSelect(
         SpiPeripheralSelect     spiPeripheralSelect,
         SpiPeripheralSelectMode spiPeripheralSelectMode  = SpiPeripheralSelectMode_Transaction,
         SpiCtarSelect           spiCtarSelect            = SpiCtarSelect_0) {

      pushrMask = spiPeripheralSelect|SPI_PUSHR_CTAS(spiCtarSelect);

      calculatePeripheralSelect(spiCtarSelect, spiPeripheralSelect, spiPeripheralSelectMode, pushrMask, pushrMaskFinal);
   }

   /**
    * Basic enable of SPI
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected in configuration
    */
   virtual void enable() = 0;

   /**
    * Disables the clock to SPI and disable all mappable pins
    */
   virtual void disable() = 0;

   /**
    * Sets communication speed for SPI
    *
    * @param[in]  frequency      Communication frequency in Hz
    * @param[in]  spiCtarSelect  Configuration to modify
    *
    * @note Chooses the highest speed that is not greater than frequency.
    */
   void setSpeed(uint32_t frequency, SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      spi->CTAR[spiCtarSelect] =
            (spi->CTAR[spiCtarSelect] & (SPI_CTAR_FMSZ_MASK|SPI_CTAR_MODE_MASK|SPI_CTAR_LSBFE_MASK)) |
            calculateCtarTiming(getSpiInputClockFrequency(), frequency);
   }

   /**
    * Get communication speed
    *
    * @param[in]  spiCtarSelect   Configuration to use
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
   uint32_t getSpeed(SpiCtarSelect spiCtarSelect=SpiCtarSelect_0) {
      return calculateSpeed(getSpiInputClockFrequency(), spiCtarSelect);
   }
   
public:
/* Template /SPI/methods - start */
   
   /**
    * Set Continuous SCK Enable
       * (spi_mcr_cont_scke)
    *
    * @param spiContinuousClock Whether the Serial Communication Clock (SCK) runs continuously
    */
   void setContinousClock(SpiContinuousClock spiContinuousClock) {
      spi->MCR = (spi->MCR&~SPI_MCR_CONT_SCKE_MASK) | spiContinuousClock;
   }

   /**
    * Set Master or Slave operation
    * (spi_mcr_mstr)
    *
    * @param spiMasterSlave Whether to operate as Master or Slave device
    */
   void setMasterSlave(SpiMasterSlave spiMasterSlave) {
      spi->MCR = (spi->MCR&~SPI_MCR_MSTR_MASK) | spiMasterSlave;
   }

   /**
    * Set Polarity for PCS signals
    * Note: All PCSs are affected.
    * (spi_mcr_pcsis)
    *
    * @param spiPcsActiveLow Mask to select the polarity of Peripheral Chip Select Lines (PCSx)
    *        Selected PCS signals will be active-low i.e. PCS will go low when accessing the peripheral
    *
    * The mask would be created by ORing together the <b>active-low</b> PCS selection values
    * Examples:
    * @code
    *    // Set PCS0 and PCS3 active-low and all others active-high
    *    setPcsPolarity(SpiPcsActiveLow_Pcs0|SpiPcsActiveLow_Pcs1)
    *
    *    // Set all PCSx to active high (the most common situation)
    *    setPcsPolarity(SpiPcsActiveLow_None)
    * @endcode
    */
   void setPcsPolarity(SpiPcsActiveLow spiPcsActiveLow) {
      spi->MCR = (spi->MCR&~SPI_MCR_PCSIS_MASK) | spiPcsActiveLow;
   }

   /**
    * Set Polarity for PCS signals to active-low
    * (spi_mcr_pcsis,spi_pushr_pcs)
    *
    * @param spiPeripheralSelect Mask to select which Peripheral Chip Select Line (PCS) to assert during transaction
    *        Note: more than one PCS may be asserted (allows use of an external decoder)
    *
    * The mask would be created by ORing together the PCS selection values
    * Example:
    * @code
    *    // Set PCS0 and PCS3 active-low and all others unchanged
    *    setPcsPolarityActiveLow(SpiPeripheralSelect_Pcs0|SpiPeripheralSelect_Pcs3);
    * @endcode
    */
   void setPcsPolarityActiveLow(SpiPeripheralSelect spiPeripheralSelect) {
      spi->MCR = spi->MCR|spiPeripheralSelect;
   }
   
   /**
    * Set Polarity for PCS signals to active-high
    * (spi_mcr_pcsis,spi_pushr_pcs)
    *
    * @param spiPeripheralSelect Mask to select which Peripheral Chip Select Line (PCS) to assert during transaction
    *        Note: more than one PCS may be asserted (allows use of an external decoder)
    *
    * The mask would be created by ORing together the PCS selection values
    * Example:
    * @code
    *    // Set PCS0 and PCS3 active-high and all others unchanged
    *    setPcsPolarityActiveHigh(SpiPeripheralSelect_Pcs0|SpiPeripheralSelect_Pcs3);
    * @endcode
    */
   void setPcsPolarityActiveHigh(SpiPeripheralSelect spiPeripheralSelect) {
      spi->MCR = spi->MCR&~spiPeripheralSelect;
   }


   // For debug
   union Ctar {
      uint32_t value;
      struct {
         unsigned br    :4 ;
         unsigned dt    :4 ;
         unsigned asc   :4 ;
         unsigned cssck :4 ;
         unsigned pbr   :2 ;
         unsigned pdt   :2 ;
         unsigned pasc  :2 ;
         unsigned pcssck:2 ;
         unsigned lsbfe :1 ;
         unsigned cpha  :2 ;
         unsigned fmsz  :4 ;
         unsigned dbr   :1 ;
      };
   };

   /**
    * Calculate communication speed from SPI clock frequency and speed factors
    *
    * @param[in]  clockFrequency  Clock frequency of SPI in Hz
    * @param[in]  spiCtarValue    Configuration providing SPI_CTAR_BR, SPI_CTAR_PBR fields
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
   static uint32_t calculateSpeed(uint32_t clockFrequency, uint32_t spiCtarValue);
   
   /**
    * Calculate CTAR timing related values \n
    * Uses default delays
    *
    * @param[in]  clockFrequency Clock frequency of SPI in Hz
    * @param[in]  frequency      Communication frequency in Hz
    *
    * @return Combined masks for CTAR (BR, PBR, PCSSCK, CSSCK, PDT, DT, PCSSCK and CSSCK)
    */
   static uint32_t calculateCtarTiming(uint32_t clockFrequency, uint32_t frequency) {

      int bestPrescale, bestDivider;
      Ctar ctarValue;

      if (frequency==0) {
         // Prevent /0
         frequency = 1000;
      }

      ctarValue.value = calculateDividers(clockFrequency, frequency);

      // Assume we need 1/2 of a transmission clock period for setup and hold times
      // This is the time in ns (rounded)
      const uint32_t clockPeriodDiv2_ns = (500'000'000+(frequency/2))/frequency;

      calculateDelay(clockFrequency, clockPeriodDiv2_ns, bestPrescale, bestDivider);
      ctarValue.value |= SPI_CTAR_PCSSCK(bestPrescale)|SPI_CTAR_CSSCK(bestDivider);

//      calculateDelay(clockFrequency, clockPeriodDiv2_ns, bestPrescale, bestDivider);
      ctarValue.value |= SPI_CTAR_PASC(bestPrescale)|SPI_CTAR_ASC(bestDivider);

      // Assume 1 clock minimum between CS negation and assertion
      calculateDelay(clockFrequency, 2*clockPeriodDiv2_ns, bestPrescale, bestDivider);
      ctarValue.value |= SPI_CTAR_PDT(bestPrescale)|SPI_CTAR_DT(bestDivider);

      return ctarValue.value;
   }

/* Template /SPI/InitMethod - start */
   
   /**
    * Configure SPI from values specified in init
    *
    * @param init Class containing initialisation values
    */
   void configure(const typename SpiBasicInfo::Init &init) {
   /*
      if constexpr (Info::irqHandlerInstalled) {
         // Only set call-back if feature enabled
         setCallback(init.callbackFunction);
         enableNvicInterrupts(init.irqlevel);
      }
   */
      enable();
   
      spi->MCR =
            init.config.mcr |
            SpiClearFifo_Both|         // Clear FIFOs
            SPI_MCR_HALT(1)|           // Halt transfers initially
            SPI_MCR_MSTR(1);           // Master mode
   
      const uint32_t spiFrequency = getSpiInputClockFrequency();
   
      // CTAR 0
      spi->CTAR[0] = init.ctars[0].ctar|calculateCtarTiming(spiFrequency, init.ctars[0].speed);
   
      // CTAR 1
      spi->CTAR[1] = init.ctars[1].ctar|calculateCtarTiming(spiFrequency, init.ctars[1].speed);
   
      // PUSHR values for intermediate and last transfer in transaction
      pushrMask      = init.config.pushr;
      pushrMaskFinal = init.config.pushrFinal;
   }
   

#ifdef __CMSIS_RTOS
   /**
    * Obtain SPI mutex and set SPI configuration
    *
    * @param[in]  configuration  The configuration to set for the transaction
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(SpiCalculatedConfiguration &configuration, int milliseconds=osWaitForever) = 0;

   /**
    * Obtain SPI mutex (SPI configuration unchanged)
    *
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait.
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(int milliseconds=osWaitForever) = 0;

   /**
    * Release SPI mutex
    *
    * @return osOK:              The mutex has been correctly released.
    * @return osErrorResource:   The mutex was not obtained before.
    * @return osErrorISR:        Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus endTransaction() = 0;
#else
   /**
    * Obtain SPI (non RTOS)
    */
   int startTransaction(int =0) {
      spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      return 0;
   }

   /**
    * Obtain SPI and set SPI configuration
    *
    * @param[in] configuration The configuration values to set for the transaction.
    *
    * @note Uses CTAR[0]
    */
   int startTransaction(const SpiCalculatedConfiguration &configuration, int =0) {
      spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      setConfiguration(configuration);
      return 0;
   }

   /**
    * Release SPI - dummy routine (non RTOS)
    */
   int endTransaction() {
      spi->MCR = spi->MCR | SPI_MCR_HALT_MASK;
      return 0;
   }
#endif

   /**
    * Select pre-loaded communication parameters
    *
    * @param spiCtarSelect            Indicates which pre-loaded settings to use (which CTAR)
    * @param spiPeripheralSelect      Which peripheral is to be accessed (via PCSx)
    * @param spiPeripheralSelectMode  Behaviour of peripheral select signals between transfers/transactions
    *
    * @note Typically used with pre-loaded values in CTARs:
    *     constructor(...) or configure(...);   // Load multiple configurations
    *     OR
    *     constructor() or defaultConfigure();  // Load multiple configurations determined by Configure.usbdmProject settings
    *     ...
    *     setConfiguration(...);    // Choose pre-loaded settings to use
    */
   void selectConfiguration(
         SpiCtarSelect             spiCtarSelect,
         SpiPeripheralSelect       spiPeripheralSelect,
         SpiPeripheralSelectMode   spiPeripheralSelectMode = SpiPeripheralSelectMode_Transaction) {

      // Select PCS behaviour
      calculatePeripheralSelect(spiCtarSelect, spiPeripheralSelect, spiPeripheralSelectMode, pushrMask, pushrMaskFinal);
   }

   /**
    * Set communication parameters
    *
    * @param spiCtarSettings         Settings to use
    * @param spiPeripheralSelect     Peripheral to select (PCS to assert)
    * @param spiPeripheralSelectMode Behaviour of peripheral select signals between transfers/transactions
    *
    * @note Typically use:
    *     setConfiguration(...);             // This is a time-consuming operation
    *     auto config = getConfiguration();  // Save configuration calculated above
    *     ...
    *     setConfiguration(config);          // Re-use pre-calculated settings
    *
    * @note Uses CTAR[0]
    */
   void setConfiguration(
         const SpiBasicInfo::SerialInit &spiCtarSettings,
         SpiPeripheralSelect             spiPeripheralSelect,
         SpiPeripheralSelectMode         spiPeripheralSelectMode = SpiPeripheralSelectMode_Transaction) {

      // Set up CTAR0
      const uint32_t spiFrequency = getSpiInputClockFrequency();
      spi->CTAR[0] = spiCtarSettings.ctar|calculateCtarTiming(spiFrequency, spiCtarSettings.speed);

      // Select PCS behaviour
      calculatePeripheralSelect(SpiCtarSelect_0, spiPeripheralSelect, spiPeripheralSelectMode, pushrMask, pushrMaskFinal);
   }

   /**
    *  Get calculated SPI configuration\n
    *  This includes timing settings, word length and transmit order\n
    *  This value may be reused by @ref setConfiguration()
    *
    * @return Configuration value
    *
    * @note Typically use:
    *     setConfiguration(...);             // This is a time-consuming operation
    *     auto config = getConfiguration();  // Save configuration calculated above
    *     ...
    *     setConfiguration(config);          // Re-use pre-calculated settings
    *
    * @note Uses CTAR[0]
    */
   SpiCalculatedConfiguration getConfiguration() {
      return SpiCalculatedConfiguration{(uint16_t)(pushrMask>>16), (uint16_t)(pushrMaskFinal>>16), spi->CTAR[0]};
   }

   /**
    *  Set configuration for the next transaction using pre-calculated settings\n
    *  This includes timing settings, word length and transmit order etc.\n
    *  Assumes the interface is already acquired through startTransaction
    *
    * @param[in]  configuration Configuration value
    *
    * @note Typically use:
    *     setConfiguration(...);             // This is a time-consuming operation
    *     auto config = getConfiguration();  // Save configuration calculated above
    *     ...
    *     setConfiguration(config);          // Re-use pre-calculated settings
    *
    * @note Uses CTAR[0]
    */
   void setConfiguration(const SpiCalculatedConfiguration &configuration) {
      spi->CTAR[0]   = configuration.ctar;
      pushrMask      = configuration.pushrCommand<<16;
      pushrMaskFinal = configuration.pushrFinalCommand<<16;
   }

   /**
    * Set communication parameters (CTAR value)
    *
    * @param spiCtarSettings  Settings to use
    * @param spiCtarSelect    Configuration to modify
    */
   void setConfiguration(
         const SpiBasicInfo::SerialInit &spiCtarSettings,
         SpiCtarSelect                   spiCtarSelect = SpiCtarSelect_0) {

      const uint32_t spiFrequency = getSpiInputClockFrequency();
      spi->CTAR[spiCtarSelect] = spiCtarSettings.ctar|calculateCtarTiming(spiFrequency, spiCtarSettings.speed);
   }

   /**
    * Calculate communication parameters (CTAR and PUSH register values)
    * Note: These settings will only remain correct if the SPI clock source is unchanged.
    *
    * @param spiCtarSettings          Settings to use
    * @param spiPeripheralSelect      Peripheral(s) to select for transfer
    * @param spiPeripheralSelectMode  Behaviour of peripheral select signals between transfers/transactions
    * @param spiCtarSelect            CTAR to use
    */
   const SpiCalculatedConfiguration calculateConfiguration(
         const SerialInit            &spiCtarSettings,
         SpiPeripheralSelect         spiPeripheralSelect,
         SpiPeripheralSelectMode     spiPeripheralSelectMode = SpiPeripheralSelectMode_Transaction,
         SpiCtarSelect               spiCtarSelect           = SpiCtarSelect_0) {

      uint32_t pushrMask, pushrMaskFinal;
      calculatePeripheralSelect(spiCtarSelect, spiPeripheralSelect, spiPeripheralSelectMode, pushrMask, pushrMaskFinal);

      return SpiCalculatedConfiguration {
         uint16_t(pushrMask>>16),
         uint16_t(pushrMaskFinal>>16),
         spiCtarSettings.ctar|calculateCtarTiming(getSpiInputClockFrequency(), spiCtarSettings.speed)
      };
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *
    *  @param[in]  dataSize        Number of values to transfer
    *  @param[in]  txData          Transmit bytes (may be nullptr for Receive only)
    *  @param[out] rxData          Receive byte buffer (may be nullptr for Transmit only)
    *  @param[in]  lastTransaction Indicate last transaction in a transfer
    *
    *  @note: rxData may use same buffer as txData
    *  @note: Size of txData and rxData should be appropriate for transmission size.
    */
   template<typename T>
   void __attribute__((noinline)) txRx(const uint32_t dataSize, const T *txData, T *rxData, bool lastTransaction) {

      static_assert (((sizeof(T) == 1)||(sizeof(T) == 2)), "Size of data type T must be 8 or 16-bits");

      // Clear FIFOs just in case they are corrupted
      clearFifos(SpiClearFifo_Both);

      uint32_t rxDataSize = dataSize;
      uint32_t txDataSize = dataSize;
      do {
         // Keep Tx FIFO full while monitoring Rx FIFO

         // Clear Tx FIFO fill flag (it will remain set if Tx FIFO still has space available)
         spi->SR = SPI_SR_TFFF_MASK;

         while ((txDataSize>0) && ((spi->SR&SPI_SR_TFFF_MASK)!=0)) {

            // Send data value (may be dummy)
            uint32_t sendData = 0xFFFF;
            if (txData != nullptr) {
               sendData = (uint16_t)*txData++;
            }

            txDataSize--;

            // Push to Tx FIFO
            if (lastTransaction && (txDataSize == 0)) {
               // Mark last data
               spi->PUSHR = sendData|pushrMaskFinal;
            }
            else {
               // Keep SPI_PCS control
               spi->PUSHR = sendData|pushrMask;
            }

            // Clear Rx FIFO drain flag (it will remain set if Rx FIFO still not empty)
            spi->SR = SPI_SR_RFDF_MASK|SPI_SR_TFFF_MASK;

            // Check Rx FIFO
            if ((spi->SR&SPI_SR_RFDF_MASK)!=0) {

               // Get Rx data (may be discarded)
               uint32_t receiveData = spi->POPR;
               if (rxData != nullptr) {
                  *rxData++ = receiveData;
               }
               rxDataSize--;
            }
         }
         // Drain Rx FIFO of remaining data

         // Clear Rx FIFO drain flag (it will remain set if there is still data)
         spi->SR = SPI_SR_RFDF_MASK;
         if ((spi->SR&SPI_SR_RFDF_MASK)!=0) {

            // Get Rx data (may be discarded)
            uint32_t receiveData = spi->POPR;
            if (rxData != nullptr) {
               *rxData++ = receiveData;
            }
            rxDataSize--;
         }
      } while(rxDataSize>0);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData    Transmit bytes (tx-rx size is inferred from this array)
    *  @param[out] rxData    Receive byte buffer
    *  @param[in]  lastTransaction Indicate last transaction in a transfer
    *
    *  @note: rxData may use same buffer as txData
    */
   template<typename T, unsigned N>
   void txRx(const T (&txData)[N], T rxData[], bool lastTransaction=true) {
      txRx(N, txData, rxData, lastTransaction);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData          Transmit bytes (tx-rx size is inferred from this array)
    *  @param[out] rxData          Receive byte buffer
    *  @param[in]  lastTransaction Indicate last transaction in a transfer
    *
    *  @note: rxData may use same buffer as txData
    */
   template<typename T, unsigned N>
   void txRx(const std::array<const T, N> &txData, std::array<T, N> &rxData, bool lastTransaction=true) {
      txRx(N, txData.data(), rxData.data(), lastTransaction);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData           Transmit bytes (tx-rx size is inferred from this array)
    *  @param[out] rxData           Receive byte buffer
    *  @param[in]  lastTransaction  Indicate last transaction in a transfer
    *
    *  @note: rxData may use same buffer as txData
    */
   template<typename T, unsigned N>
   void txRx(const std::array<T, N> &txData, std::array<T, N> &rxData, bool lastTransaction=true) {
      txRx(N, txData.data(), rxData.data());
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData           Transmit bytes (tx size is inferred from this array)
    *  @param[in]  lastTransaction  Indicate last transaction in a transfer
    */
   template<typename T, unsigned N>
   void tx(const std::array<const T, N> &txData, bool lastTransaction=true) {
      txRx(N, txData.data(), (T*)nullptr, lastTransaction);
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData           Transmit bytes (tx size is inferred from this array)
    *  @param[in]  lastTransaction  Indicate last transaction in a transfer
    */
   template<typename T, unsigned N>
   void tx(const std::array<T, N> &txData, bool lastTransaction=true) {
      txRx(N, txData.data(), (T*)nullptr, lastTransaction);
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[in]  txData           Transmit bytes (tx size is inferred from this array)
    *  @param[in]  lastTransaction  Indicate last transaction in a transfer
    */
   template<typename T, unsigned N>
   void tx(const T (&txData)[N], bool lastTransaction=true) {
      txRx(N, txData, (T*)nullptr, lastTransaction);
   }

   /**
    *  Transmit a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *
    *  @param[in]  dataSize         Number of values to transfer
    *  @param[in]  txData           Transmit bytes (tx size is inferred from this array)
    *  @param[in]  lastTransaction  Indicate last transaction in a transfer
    */
   template<typename T>
   void tx(uint32_t dataSize, const T *txData, bool lastTransaction=true) {
      txRx(dataSize, txData, (T*)nullptr, lastTransaction);
   }

   /**
    *  Transmit and receive a series of values
    *
    *  @tparam T Type for data transfer (may be inferred from parameters)
    *  @tparam N Size of arrays (may be inferred from parameters)
    *
    *  @param[out] rxData           Receive byte buffer (rx size is inferred from this array)
    *  @param[in]  lastTransaction  Indicate last transaction in a transfer
    */
   template<typename T, unsigned N>
   void rx(T (&rxData)[N], bool lastTransaction=true) {
      txRx(N, (T*)nullptr, rxData, lastTransaction);
   }

   /**
    * Transmit and receive a value over SPI
    *
    * @param[in] data - Data to send (4-16 bits) <br>
    *                   May include other control bits as for PUSHR
    *
    * @return Data received
    */
   uint32_t txRxRaw(uint32_t data);

   /**
    * Transmit and receive a value over SPI\n
    * This routine is intended for start or middle bytes of a transfer
    *
    * @param[in] data - Data to send (4-16 bits)
    *
    * @return Data received
    */
   uint16_t txRx(uint16_t data) {
      return txRxRaw(data|pushrMask);
   }

   /**
    * Transmit and receive a value over SPI\n
    * This routine is intended for the last byte of a transfer
    *
    * @param[in] data - Data to send (4-16 bits)
    *
    * @return Data received
    */
   uint16_t txRxFinal(uint16_t data) {
      return txRxRaw(data|pushrMaskFinal);
   }

   /**
    * Clear Transmit and/or Receive FIFOs
    *
    * @param spiClearFifo  Which FIFOs to clear
    */
   void clearFifos(SpiClearFifo spiClearFifo=SpiClearFifo_Both) {
      spi->MCR = spi->MCR | spiClearFifo;
   }

   /**
    *
    * @param[in] spiTxFifoRequest   Transmit FIFO Fill Request interrupt/DMA enable (TFFF flag)
    * @param[in] spiRxFifoRequest   Receive FIFO Drain Request interrupt/DMA enable (RFDF flag)
    */
   void configureFifoRequests(
         SpiTxFifoRequest spiTxFifoRequest,
         SpiRxFifoRequest spiRxFifoRequest) {

      spi->RSER = (spi->RSER&~(SPI_RSER_TFFF_DIRS(1)|SPI_RSER_TFFF_RE(1)|SPI_RSER_RFDF_DIRS(1)|SPI_RSER_RFDF_RE(1)))|spiTxFifoRequest|spiRxFifoRequest;
   }
   /**
    *
    * @param[in] spiTxCompleteInterrupt        Controls Transmit complete interrupts (TCF Flag)
    * @param[in] spiEndOfQueueInterrupt        Controls DSPI Finished interrupts (EOQF flag)
    * @param[in] spiTxFifoUnderflowInterrupt   Controls Transmit FIFO Underflow interrupts (TFUF flag)
    * @param[in] spiRxFifoOverflowInterrupt    Controls Transmit FIFO Overflow interrupts (TFUF flag)
    */
   void configureInterrupts(
         SpiTxCompleteInterrupt       spiTxCompleteInterrupt       = SpiTxCompleteInterrupt_Disabled,
         SpiEndOfQueueInterrupt       spiEndOfQueueInterrupt       = SpiEndOfQueueInterrupt_Disabled,
         SpiTxFifoUnderflowInterrupt  spiTxFifoUnderflowInterrupt  = SpiTxFifoUnderflowInterrupt_Disabled,
         SpiRxFifoOverflowInterrupt   spiRxFifoOverflowInterrupt   = SpiRxFifoOverflowInterrupt_Disabled
         ) {

      spi->RSER = (spi->RSER&~(SPI_RSER_TFUF_RE(1)|SPI_RSER_RFOF_RE(1)|SPI_RSER_TCF_RE(1)|SPI_RSER_EOQF_RE(1)))|
            spiTxFifoUnderflowInterrupt|spiRxFifoOverflowInterrupt|spiTxCompleteInterrupt|spiEndOfQueueInterrupt;
   }

   /**
    * Starts and stops the SPI transfers.
    *
    * @param[in] enable true to enable
    */
   void enableTransfer(bool enable=true) {
      if (enable) {
         spi->MCR = spi->MCR & ~SPI_MCR_HALT_MASK;
      }
      else {
         spi->MCR = spi->MCR | SPI_MCR_HALT_MASK;
      }
   }

   /**
    * Gets and clears status flags.
    *
    * @return Status value (SPI->SR)
    */
   uint32_t getStatus() {
      // Capture interrupt status
      uint32_t status = spi->SR;

      // Clear captured flags
      spi->SR = status;

      // Return status
      return status;
   }

};

#if false
/**
 * Class to handle SPI DMA operations
 * It will create the required buffer to format data for the DMA transfer.
 * This is necessary because of the really stupid SPI transfers that require 32-bit writes to include COMMAND+DATA
 * for each item transferred. Note that some later devices may not require this.
 * This means that to transfer a buffer of data (8/16 bit items) requires copying it to a RAM Buffer up to 4-times its size
 * and add in the command values for each entry.
 *
 * @tparam itemCount Maximum size of buffer that can be expanded (in items)
 */
template<unsigned itemCount>
class SpiDmaHandlerBase {

protected:

   // Maximum number of items in buffer
   static constexpr unsigned MaxItemCount = itemCount;

   // Size of items (always 4 irrespective of actual data size)
   static constexpr unsigned SizeofItems = 4;

   // Expanded buffer with added command values
   union {
      uint32_t bits;
      struct {
         uint16_t data;
         uint16_t command;
      };
   } __attribute__((packed)) expandedBuffer[itemCount];

   // The final Tx value is sent individually to allow different PUSHR value
   uint32_t finalTxValue   = 0;

   // Dummy location for discarding Rx data
   uint32_t discardRxBuffer = 0;

   // Associated SPI
   Spi &spi;

   // Allocated DMA channels - released after transfer completes
   DmaChannelNum dmaTransmitChannel = DmaChannelNum_None;
   DmaChannelNum dmaReceiveChannel  = DmaChannelNum_None;

   /**
    * Constructor
    *
    * @param spi  Associated SPI
    */
   SpiDmaHandlerBase(Spi &spi) : spi(spi) {
   }

public:
   /**
    * Copy-expand data into internal DMA buffer
    * The final value is placed in finalTxValue
    *
    * @tparam T      Type for data (deduced)
    * @tparam N      Size of data array in items (deduced)
    *
    * @param dataIn  Data array to expand
    *
    * @note It is necessary to set the transfer configuration in the SPI before using this
    *       routine as it will make use of information from the SPI to format data.
    */
   template<typename T, unsigned N>
   void loadTxData(const T (&dataIn)[N]) {

      static_assert((sizeof(T) == 1) || (sizeof(T) == 2) , "T must be of size 1 or 2 bytes");
      static_assert(N<=itemCount, "dataIn is too large for buffer allocated");

      // Copy-expand data
      for (unsigned count=0; count<N; count++) {
         expandedBuffer[count].bits = dataIn[count]|spi.pushrMask;
      }
      finalTxValue = dataIn[N-1]|spi.pushrMaskFinal|SPI_PUSHR_EOQ_MASK;
   }

   /**
    * Mark data item in DMA transmit buffer to clear transmit counter.
    *
    * The transmit counter will be cleared before transmission of the associated data.
    * This would usually be set on the first item in the buffer.
    *
    * @param index   Index in transfer
    * @param data    Data to write
    *
    * @note It is necessary to set the transfer configuration in the SPI before using this
    *       routine as it will make use of information from the SPI to format data.
    */
   void markDataToClearCounter(unsigned index=0) {

      usbdm_assert(index<MaxItemCount, "Array index error");

      expandedBuffer[index].bits |= SPI_PUSHR_COMMAND_CTCNT_MASK;
   }

   /**
    * Mark data item in DMA transmit buffer as end-of-queue.
    *
    * Indicates the associated data value is End of Queue, the transmit and
    * receive operations will be disabled after this item completes transmission
    * This should only be set on the last item in the buffer.
    *
    * @param index   Index in transfer
    * @param data    Data to write
    *
    * @note It is necessary to set the transfer configuration in the SPI before using this
    *       routine as it will make use of information from the SPI to format data.
    */
   void markDataAsEoq(unsigned index) {

      usbdm_assert(index<MaxItemCount, "Array index error");

      expandedBuffer[index].bits |= SPI_PUSHR_EOQ_MASK;
   }

   ErrorCode allocateDmaChannels() {

      // deallocate any channels in use
      cleanUp();

      // Allocate DMA channel to use for transmission
      dmaTransmitChannel = Dma0::allocateChannel();
      if (dmaTransmitChannel == DmaChannelNum_None) {
         return setErrorCode(E_NO_RESOURCE);
      }

      // Allocate DMA channel to use for reception
      dmaReceiveChannel = Dma0::allocateChannel();
      if (dmaReceiveChannel == DmaChannelNum_None) {
         // Release successfully allocated channel as we can't use it now
         Dma0::freeChannel(dmaTransmitChannel);
         return setErrorCode(E_NO_RESOURCE);
      }
      return E_NO_ERROR;
   }

   /**
    * This TCD is chained from the main Tx TCD and
    * allows the last value transferred to have a individual PUSHR value
    */
   DmaTcd __attribute__((aligned(32)))  finalTcd = DmaTcd (
      {  /* Source */
         /* Address                  */ 0,                                           // Source address (filled in)
         /* Offset                   */ 0,                                           // Source address doesn't change
         /* Size                     */ DmaSize_32bit,                               // 32-bit read from source address
      },
      {  /* Destination */
         /* Address                  */ 0,                                           // Destination address (filled in)
         /* Offset                   */ 0,                                           // Destination address doesn't change
         /* Size                     */ DmaSize_32bit,                               // 32-bit write to destination address
      },
      /* Minor loop byte count    */ sizeof(uint32_t),                               // Total transfer in one minor-loop
      /* Major loop count         */ 1,                                              // Transfer single item

      {  // CSR
         /* Disable Req. on complete */ DmaStopOnComplete_Enabled,                   // Clear hardware request when major loop completed
         /* IRQ on major complete    */ DmaIntMajor_Enabled,                         // Interrupt
      }
   );

   /*
    * Initialises the final Tx transfer to SPI.
    * This sets up a TCD that is chained from the main Tx TCD
    * and allows the last value transferred to have a individual PUSHR
    */
   ErrorCode initialiseFinalTransfer() {
      finalTcd.SADDR = (uint32_t)&finalTxValue;
      finalTcd.DADDR = (uint32_t)spi.spi+offsetof(SPI_Type, PUSHR);

      return E_NO_ERROR;
   }

   /**
    * Set up for DMA operation
    * - Configure DMA Mux for Tx channel
    * - Configures DMA TCD for Tx
    * No transfers are actually started
    *
    * @param numElements         Number of elements to transfer
    * @param advanceReadAddress  Whether to advance DMA read pointer during transfer
    *
    * @note This method may be called before the SPI configuration has been set.
    *
    * @return E_NOERROR on success
    * @return E_NO_RESOURCE if failed to allocate required DMA channels
    */
   ErrorCode initialiseTxDma(unsigned numElements, bool advanceReadAddress) {

      int32_t   offset          = advanceReadAddress?0:SizeofItems;
      uint32_t  spiPushrAddress = spi.spi+offsetof(SPI_Type, PUSHR);
      /**
       * Structure to define the Transmit DMA transfer
       *
       * Note: This uses a 32-bit transfer even though the transmit data may only be 8 or 16-bit
       */
      DmaTcd txTcd = DmaTcd (
         {  /* Source */
            /* Address                  */ (uint32_t)(expandedBuffer),  // Source is array
            /* Offset                   */ offset,                      // Source address advances 0/1 element per request
            /* Size                     */ DmaSize_32bit,               // 32-bit read from source address
         },
         {  /* Destination */
            /* Address                  */ spiPushrAddress,             // Destination is SPI.PUSHR data register
            /* Offset                   */ 0,                           // Destination address doesn't change
            /* Size                     */ DmaSize_32bit,               // 32-bit write to destination address
            /* ScatterGather address    */ (int32_t) &finalTcd,         // Chain to finalTcd
         },
         /* Minor loop byte count       */ dmaNBytes(SizeofItems),      // Total transfer in one minor-loop
         /* Major loop count            */ dmaCiter(numElements-1),     // Transfer entire buffer

         {  // CSR
           /* Scatter/Gather enable     */ DmaScatterGather_Enabled     // Chain to finalTcd
         }
      );

      // Connect DMA channel to SPI Tx
      DmaMux0::configure(dmaTransmitChannel, Dma0Slot_SPI0_Tx, DmaMuxEnable_Continuous);

      // Configure the Tx transfer
      Dma0::configureTransfer(dmaTransmitChannel, txTcd);

      return E_NO_ERROR;
   }

   /**
    * Set up for DMA operation
    * - Configure DMA Mux for Rx channels
    * - Configures DMA TCD for Rx
    * No transfers are actually started
    *
    * @param rxBuffer     Buffer for received data (may be null)
    * @param rxDataSize   Size of elements in rxBuffer (either 1 or 2 bytes)
    * @param numElements  Number of elements in rxBuffer
    *
    * @note This method may be called before the SPI configuration has been set.
    *
    * @return E_NOERROR on success
    * @return E_NO_RESOURCE if failed to allocate required DMA channels
    */
   ErrorCode initialiseRxDma(void *rxBuffer, unsigned rxDataSize, unsigned numElements) {

      // Size for Rx data DMA transfers
      DmaSize   rxDmaSize      = (rxDataSize==1)?DmaSize_8bit:DmaSize_16bit;
      uint32_t  spiPoprAddress = spi.spi+offsetof(SPI_Type, POPR);

      int32_t writeOffset = rxDataSize;
      if (rxBuffer==nullptr) {
         writeOffset = 0;
         rxBuffer = &discardRxBuffer;
      }

      /**
       * Structure to define the Receive DMA transfer
       *
       * Note: The transfer size used here is 8 or 16-bits only
       */
      DmaTcd rxTcd (
         {  /* Source */
            /* Address                  */ spiPoprAddress,            // Source is SPI.POPR data register
            /* Offset                   */ 0,                         // Source address doesn't change
            /* Size                     */ rxDmaSize,                 // Read from source address depends on data size
            /* Last address adjustment  */ 0,                         // Source address doesn't change
         },
         {  /* Destination */
            /* Address                  */ (uint32_t)(rxBuffer),      // Destination array
            /* Offset                   */ writeOffset,               // Destination address advances 1 element for each request
            /* Size                     */ rxDmaSize,                 // Write to destination address depends on data size
            /* Last address adjustment  */ 0,                         // Don't adjust destination address
         },
         /* Minor loop byte count       */ dmaNBytes(rxDataSize),     // Total transfer in one minor-loop
         /* Major loop count            */ dmaCiter(numElements),     // Transfer entire buffer

         {  // CSR
            /* Disable Req. on complete */ DmaStopOnComplete_Enabled, // Clear hardware request when major loop completed
            /* IRQ on major complete    */ DmaIntMajor_Enabled,       // Generate interrupt on completion of major-loop
         }
      );

      // Connect DMA channel to SPI Rx
      DmaMux0::configure(dmaReceiveChannel, Dma0Slot_SPI0_Rx, DmaMuxEnable_Continuous);

      // Configure the Rx transfer
      Dma0::configureTransfer(dmaReceiveChannel, rxTcd);

      return E_NO_ERROR;
   }

   /**
    * Set up for DMA operation
    * - Allocates DMA channels
    * - Configure DMA Mux for Tx and Rx channels
    * - Configures DMA channels for Tx and Rx
    * No transfers are actually started
    *
    * @tparam T  Type of elements in rxBuffer (deduced)
    * @tparam N  Number of elements in rxBuffer (deduced)
    *            This becomes the number of elements to Tx and Rx
    *
    * @param rxBuffer Buffer for received data
    *
    * @note This method may be called before the SPI configuration has been set.
    *
    * @return E_NOERROR on success
    * @return E_NO_RESOURCE if failed to allocate required DMA channels
    */
   template<typename T, unsigned N>
   ErrorCode initialiseDma(const T (&rxBuffer)[N]) {

      static_assert((sizeof(T) == 1) || (sizeof(T) == 2) , "T must be of size 1 or 2 bytes");
      ErrorCode rc;
      do {
         rc = allocateDmaChannels();
         if (rc != E_NO_ERROR) {
            break;
         }
         rc = initialiseTxDma(N, false);
         if (rc != E_NO_ERROR) {
            break;
         }
         rc = initialiseFinalTransfer();
         if (rc != E_NO_ERROR) {
            break;
         }
         rc = initialiseRxDma((void*)rxBuffer, sizeof(T), N);
         if (rc != E_NO_ERROR) {
            break;
         }
      } while(false);
      return rc;
   }

   /**
    * Set up for DMA operation
    * - Copies Tx data to internal buffer (with expansion)
    * - Allocates DMA channels
    * - Configure DMA Mux for Tx and Rx channels
    * - Configures DMA channels for Tx and Rx
    * No transfers are actually started
    *
    * @tparam T         Type for data (deduced)
    * @tparam N         Number of data items in transfer
    * @param dataIn     Data to send to SPI
    * @param rxBuffer   Buffer for received data
    *
    * @return E_NOERROR on success
    */
   template<typename T, unsigned N>
   ErrorCode initialiseTxRx(const T (&dataIn)[N], T (&rxBuffer)[N]) {

      // Set up transmit buffer
      loadTxData(dataIn);

      // Set up DMA
      return initialiseDma(rxBuffer);
   }

   /**
    * Start DMA transfers To/From SPI
    */
   void startTransfer() {

      // Clear SPI Status
      spi.getStatus();

      spi.configureInterrupts(
            SpiTxCompleteInterrupt_Enabled,
            SpiEndOfQueueInterrupt_Enabled,
            SpiTxFifoUnderflowInterrupt_Enabled,
            SpiRxFifoOverflowInterrupt_Enabled);

      spi.clearFifos(SpiClearFifo_Both);

      spi.configureFifoRequests(SpiTxFifoRequest_Dma, SpiRxFifoRequest_Dma);

      spi.enableTransfer();

      Dma0::enableMultipleErrorInterrupts((1<<dmaTransmitChannel)|(1<<dmaReceiveChannel), true);

      // Enable Rx hardware requests
      Dma0::enableRequests(dmaReceiveChannel);

      // Enable Tx hardware requests
      Dma0::enableRequests(dmaTransmitChannel);
   }

protected:
   static void cleanUp(DmaChannelNum &channel) {

      if (channel == DmaChannelNum_None) {
         return;
      }
      // Clear request and release DMA channel
      Dma0::enableRequests(channel, false);
      DmaMux0::disable(channel);
      Dma0::setCallback(channel, nullptr);
      Dma0::freeChannel(channel);
      channel = DmaChannelNum_None;
   }

public:
   void cleanUp() {
      cleanUp(dmaTransmitChannel);
      cleanUp(dmaReceiveChannel);
   }
};

#endif

/**
 * @brief Template class representing a SPI interface
 *
 * @tparam  Info           Class describing Spi hardware
 */
template<class Info>
class SpiBase_T : public Spi, public Info {

public:
   /** Pointer to SPI hardware as struct */
   static constexpr HardwarePtr<SPI_Type>spi = Info::baseAddress;

   /** Base address of SPI hardware as uint32_t */
   static constexpr uint32_t spiBase   = Info::baseAddress;
   /** Address of SPI.MCR register as uint32_t */
   static constexpr uint32_t spiMCR    = Info::baseAddress + offsetof(SPI_Type, MCR);
   /** Address of SPI.CR register as uint32_t */
   static constexpr uint32_t spiCR     = Info::baseAddress + offsetof(SPI_Type, TCR);
   /** Address of SPI.CTAR[n] register as uint32_t */
   static constexpr uint32_t spiCTAR(unsigned index) {return Info::baseAddress + offsetof(SPI_Type, CTAR) + index * sizeof(SPI_Type::CTAR[0]) ; }
   /** Address of SPI.SR register as uint32_t */
   static constexpr uint32_t spiSR     = Info::baseAddress + offsetof(SPI_Type, SR);
   /** Address of SPI.PUSHR register as uint32_t */
   static constexpr uint32_t spiPUSHR  = Info::baseAddress + offsetof(SPI_Type, PUSHR);
   /** Address of SPI.POPR register as uint32_t */
   static constexpr uint32_t spiPOPR   = Info::baseAddress + offsetof(SPI_Type, POPR);

protected:
//   static SpiBase_T<Info> *thisPtr;

public:
   /**
    * Gets and clears status flags.
    *
    * @return Status value (SPI->SR)
    */
   static uint32_t __attribute__((always_inline)) getStatus() {
      // Capture interrupt status
      uint32_t status = Info::spi->SR;
      // Clear captured flags
      Info::spi->SR = status;
      // Return status
      return status;
   }


#ifdef __CMSIS_RTOS
protected:
   /**
    * Mutex to protect access\n
    * Using a static accessor function avoids issues with static object initialisation order
    *
    * @return mutex
    */
   static CMSIS::Mutex &mutex() {
      /** Mutex to protect access - static so per SPI */
      static CMSIS::Mutex mutex;
      return mutex;
   }

public:
   /**
    * Obtain SPI mutex and set SPI configuration
    *
    * @param[in]  configuration  The configuration to set for the transaction
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(const SpiCalculatedConfiguration &configuration, int milliseconds=osWaitForever) override {
      // Obtain mutex
      osStatus status = mutex().wait(milliseconds);
      if (status == osOK) {
         spi->MCR    &= ~SPI_MCR_HALT_MASK;
         // Change configuration for this transaction
         setConfiguration(configuration);
      }
      else {
         CMSIS::setAndCheckCmsisErrorCode(status);
      }
      return status;
   }

   /**
    * Obtain SPI mutex (SPI configuration unchanged)
    *
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait.
    *
    * @return osOK:                    The mutex has been obtain.
    * @return osErrorTimeoutResource:  The mutex could not be obtained in the given time.
    * @return osErrorResource:         The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter:        The parameter mutex_id is incorrect.
    * @return osErrorISR:              Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus startTransaction(int milliseconds=osWaitForever) override {
      // Obtain mutex
      osStatus status = mutex().wait(milliseconds);
      if (status == osOK) {
         spi->MCR &= ~SPI_MCR_HALT_MASK;
      }
      else {
         CMSIS::setAndCheckCmsisErrorCode(status);
      }
      return status;
   }

   /**
    * Release SPI mutex
    *
    * @return osOK:              The mutex has been correctly released.
    * @return osErrorResource:   The mutex was not obtained before.
    * @return osErrorISR:        Cannot be called from interrupt service routines.
    *
    * @note The USBDM error code will also be set on error
    */
   virtual osStatus endTransaction() override {
      spi->MCR |= SPI_MCR_HALT_MASK;
      // Release mutex
      osStatus status = mutex().release();
      if (status != osOK) {
         CMSIS::setAndCheckCmsisErrorCode(status);
      }
      return status;
   }
#endif

public:
   /** SPI SCK (clock) Pin */
   using sckGpio  = GpioTable_T<Info, 0, ActiveHigh>;

   /** SPI SIN (data in = usually MISO) Pin */
   using sinGpio  = GpioTable_T<Info, 1, ActiveHigh>;

   /** SPI SOUT (data out = usually MOSI) Pin */
   using soutGpio = GpioTable_T<Info, 2, ActiveHigh>;

   /**
    * Basic enable of SPI
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected in configuration
    */
   virtual void enable() override {
      Info::enable();
   }

   /**
    * Disables the clock to SPI and disable all mappable pins
    */
   virtual void disable() override {
      Info::disable();
   }

   /**
    * Get the frequency of the input clock to the SPI
    *
    * @return Frequency on Hz
    */
   virtual uint32_t getSpiInputClockFrequency() override {
      return Info::getClockFrequency();
   }

   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   inline void defaultConfigure() {

      // Update settings
      configure(Info::DefaultInitValue);
   }

   /**
    * Dummy routine
    */
   static void irqHandler() {
//      thisPtr->_irqHandler();
   }

   /**
    * Constructor
    */
   SpiBase_T() : Spi(Info::baseAddress) {

      // Check pin assignments
      static_assert(Info::info[Info::sckPin].pinIndex  != PinIndex::UNMAPPED_PCR, "SPIx_SCK has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::sinPin].pinIndex  != PinIndex::UNMAPPED_PCR, "SPIx_SIN has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::soutPin].pinIndex != PinIndex::UNMAPPED_PCR, "SPIx_SOUT has not been assigned to a pin - Modify Configure.usbdm");

      configure(Info::DefaultInitValue);
   }

   /**
    * Constructor
    */
   SpiBase_T(const typename SpiBasicInfo::Init &init) : Spi(Info::baseAddress) {

      // Check pin assignments
      static_assert(Info::info[Info::sckPin].pinIndex  != PinIndex::UNMAPPED_PCR, "SPIx_SCK has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::sinPin].pinIndex  != PinIndex::UNMAPPED_PCR, "SPIx_SIN has not been assigned to a pin - Modify Configure.usbdm");
      static_assert(Info::info[Info::soutPin].pinIndex != PinIndex::UNMAPPED_PCR, "SPIx_SOUT has not been assigned to a pin - Modify Configure.usbdm");

      configure(init);
   }

   /**
    * Destructor
    */
   ~SpiBase_T() override {
   }

#if false

   static unsigned dmaComplete;
   static uint32_t dmaErrorCode;
   static bool     keepDmaConfiguration;

   /**
    * Class to handle SPI DMA operations
    * It will create the required buffer to format data for the DMA transfer.
    * This is necessary because of the really stupid SPI transfers that require 32-bit writes to include COMMAND+DATA
    * for each item transferred. Note that some later devices may not require this.
    * This means that to transfer a buffer of data (8/16 bit items) requires copying it to a RAM Buffer up to 4-times its size
    * and add in the command values for each entry.
    *
    * @tparam itemCount Maximum size of buffer that can be expanded (in items)
    */
   template<unsigned itemCount>
   class SpiDmaHandler_T : public SpiDmaHandlerBase<itemCount> {

   private:
      using Super = SpiDmaHandlerBase<itemCount>;

      /**
       * DMA complete callback
       *
       * Sets flag to indicate sequence complete.
       */
      static void dmaCallback(DmaChannelNum channel, uint32_t errorStatus) {

         Dma0::clearInterruptRequest(channel);
         Dma0::enableRequests(channel, false);
         if (dmaComplete>0) {
            dmaComplete--;
         }
         if (errorStatus&DMA_ES_VLD_MASK) {
            // Error callback
            dmaErrorCode = errorStatus;
            dmaComplete = 0;
         }
      }

      /**
       * SPI callback
       *
       * Used for debug timing checks.
       * LED toggles on each SPI event
       *
       * @param status Interrupt status value from SPI->SR
       */
      static void spiCallback(uint32_t status) {
         (void)status;
      }

   public:
      SpiDmaHandler_T(Spi &spi) : Super(spi) {
         spi.setCallback(spiCallback);
      }

      /**
       * Start transfer
       */
      void startTransfer() {

         dmaComplete = 2;

         // Set up DMA IRQ handlers
         Dma0::setCallback(Super::dmaTransmitChannel, dmaCallback);
         Dma0::setCallback(Super::dmaReceiveChannel,  dmaCallback);

         Dma0::enableNvicInterrupts(Super::dmaTransmitChannel, NvicPriority_Normal);
         Dma0::enableNvicInterrupts(Super::dmaReceiveChannel,  NvicPriority_Normal);
         Dma0::enableNvicErrorInterrupt(NvicPriority_MidHigh);
         Super::startTransfer();
      }

      bool isBusy() {
         if (errorCode != 0) {
            // Release resources on error
            Super::cleanUp();
         }
         if ((dmaComplete == 0) && !keepDmaConfiguration) {
            // Release DMA channels
            Super::cleanUp();
         }
         return dmaComplete != 0;
      }

      /**
       * If set:
       *    - The DMA configuration (including allocated DMA channels) set up by initialiseDma() are
       *      retained for re-use.
       *    - Resources must be manually released by calling cleanUp().
       *
       * If not set:
       *    - Allocated resources are released when the DMA transfer completes successfully
       *
       * @param keepConfiguration  true to keep configuration and resources
       */
      static void setKeepDmaConfiguration(bool keepConfiguration) {
         keepDmaConfiguration = keepConfiguration;
      }

   };

   /**
    * Creates a DMA buffer and associated code for DMA transfers to/from the SPI
    *
    * Examples use:
    * @code
    *    Spi0 spi;
    *
    *    // Configure SPI
    *
    *    constexpr unsigned NumDataItems = 10;
    *
    *    using DataSize = uint16_t; // Can be uint8_t or uint16_t
    *
    *    // Transmit data
    *    DataSize txBuffer[NumDataItems];
    *
    *    // Create DMA buffers etc.
    *    auto txBuffer = spi.createDmaHandler<NumDataItems>();
    *
    *    // Receive buffer
    *    DataSize rxBuffer[NumDataItems];
    *
    *    // Set up DMA transfer from internal buffer -> SPI -> rxBuffer
    *    txBuffer.initialiseDma(rxBuffer);
    *
    *    // Load data into SPI transmit buffer
    *    txBuffer.loadTxData(txBufferOriginal);
    *
    *    // Start transfer
    *    txBuffer.startTransfer();
    *
    *    // Wait for completion
    *    while (txBuffer.isBusy()) {
    *       __asm__("nop");
    *    }
    * @endcode
    *
    * @tparam itemCount Number of items in internal DMA buffer buffer
    *
    * @return Instance of SpiDmaHandler customised for buffer size
    */
   template<unsigned itemCount>
   SpiDmaHandler_T<itemCount> createDmaHandler() {
      return SpiDmaHandler_T<itemCount>(*this);
   }
#endif

};

/** Used by ISR to obtain handle of object */
//template<class Info> SpiBase_T<Info> *SpiBase_T<Info>::thisPtr = nullptr;

#if false
template<class Info>
unsigned SpiBase_T<Info>::dmaComplete = false;

template<class Info>
bool SpiBase_T<Info>::keepDmaConfiguration = false;

template<class Info>
uint32_t SpiBase_T<Info>::dmaErrorCode = 0;
#endif

// SPI0 mappings
static constexpr SpiPeripheralSelect SpiPeripheralSelect_Ptc3         = SpiPeripheralSelect_Pcs1; ///< Touch panel CS (PTC3(p36))
static constexpr SpiPeripheralSelect SpiPeripheralSelect_TouchCs      = SpiPeripheralSelect_Pcs1; ///< Touch panel CS (PTC3(p36))
static constexpr SpiPeripheralSelect SpiPeripheralSelect_Ptc2         = SpiPeripheralSelect_Pcs2; ///< TFT D/C select (PTC2(p35))
static constexpr SpiPeripheralSelect SpiPeripheralSelect_TftDc        = SpiPeripheralSelect_Pcs2; ///< TFT D/C select (PTC2(p35))
static constexpr SpiPeripheralSelect SpiPeripheralSelect_Ptc1         = SpiPeripheralSelect_Pcs3; ///< TFT CS (PTC1(p34))
static constexpr SpiPeripheralSelect SpiPeripheralSelect_TftCs        = SpiPeripheralSelect_Pcs3; ///< TFT CS (PTC1(p34))

   /**
    * Class representing SPI0 interface
    *
    * <b>Example</b>
    * @code
    * // Initialisation values for Spi
    * static const Spi0::Init spiInit {
    *
    *    {
    *       // Shared configuration
    *       SpiModifiedTiming_Normal ,        // Modified Timing Format - Normal Timing
    *       SpiDoze_Enabled ,                 // Enables Doze mode (when processor is waiting?) - Suspend in Doze
    *       SpiFreeze_Enabled ,               // Controls SPI operation while in debug mode - Suspend in debug
    *       SpiRxOverflowHandling_Overwrite , // Handling of Rx Overflow Data - Overwrite existing
    *       SpiContinuousClock_Enable,        // Continuous SCK Enable - Continuous clock
    *
    *       SpiPeripheralSelect_0,            // PCS0 is Active-low (others are active-high)
    *    },
    *    {
    *       // CTAR 0 initialisation
    *       10_MHz ,                // Speed of interface
    *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
    *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
    *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
    *    },
    * };
    *
    * Spi0 spi(spiInit);
    * ...
    *
    * uint8_t txData[] = {1,2,3};
    * uint8_t rxData[10];
    *
    * spi.txRxBytes(sizeof(txData), txData, rxData);
    * ...
    * @endcode
    */
   using Spi0 = SpiBase_T<Spi0Info>;
   

/**
 * End SPI_Group
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_SPI_H_ */
