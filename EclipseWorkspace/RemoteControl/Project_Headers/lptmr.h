/**
 * @file     lptmr.h (180.ARM_Peripherals/Project_Headers/lptmr.h)
 * @brief    Low power timer interface
 */

#ifndef HEADER_LPTMR_H
#define HEADER_LPTMR_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <climits>
#include <cmath>
#include "derivative.h"
#include "system.h"
#include "pin_mapping.h"

// No handler defined for LPTMR0


namespace USBDM {

/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */
#if false // /LPTMR/_BasicInfoGuard
/**
 * Peripheral information for LPTMR, Low Power Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */

   /**
    * Timer Enable
    * (lptmr_csr_ten)
    *
    * Enables timer
    */
   enum LptmrCsrTen : uint8_t {
      LptmrCsrTen_Disabled   = LPTMR_CSR_TEN(0),  ///< Disabled
      LptmrCsrTen_Enabled    = LPTMR_CSR_TEN(1),  ///< Enabled
   };

   /**
    * Operation mode of the LPTMR
    * (lptmr_csr_tms)
    *
    * Selects between timer Interval and Pulse Counting
    * Should only be altered when timer is disabled.
    */
   enum LptmrMode : uint8_t {
      LptmrMode_TimeInterval    = LPTMR_CSR_TMS(0),  ///< Time Interval mode
      LptmrMode_PulseCounting   = LPTMR_CSR_TMS(1),  ///< Pulse Counter mode
   };

   /**
    * Timer action on event
    * (lptmr_csr_tie)
    *
    * Enables LPTMR interrupts
    */
   enum LptmrEventAction : uint8_t {
      LptmrEventAction_None        = LPTMR_CSR_TIE(0),  ///< None
      LptmrEventAction_Interrupt   = LPTMR_CSR_TIE(1),  ///< Interrupt
   };

   /**
    * Counter Action on Compare Event
    * (lptmr_csr_tfc)
    *
    * Counter action when compare event occurs
    * The counter can continue counting or be reset to zero.
    * Should only be altered when timer is disabled.
    */
   enum LptmrCounterActionOnEvent : uint8_t {
      LptmrCounterActionOnEvent_Reset   = LPTMR_CSR_TFC(0),  ///< Counter is reset on event
      LptmrCounterActionOnEvent_None    = LPTMR_CSR_TFC(1),  ///< No effect on counter
   };

   /**
    * Timer Compare Flag
    * (lptmr_csr_tcf)
    *
    * Flag is set when the LPTMR is enabled and the CNR equals the CMR and increments.
    * Flag is cleared when the LPTMR is disabled or a logic 1 is written to it.
    */
   enum LptmrCompareFlag : uint8_t {
      LptmrCompareFlag_NoEvent   = LPTMR_CSR_TCF(0),  ///< No event
      LptmrCompareFlag_Event     = LPTMR_CSR_TCF(1),  ///< Event
   };

   /**
    * Clock source for LPTMR
    * (lptmr_psr_pcs)
    *
    * Selects the clock source for LPTMR
    * Should only be altered when timer is disabled.
    */
   enum LptmrClockSel : uint8_t {
      LptmrClockSel_Mcgirclk   = LPTMR_PSR_PCS(0),  ///< MCG Internal Reference Clock (MCGIRCLK)
      LptmrClockSel_Lpoclk     = LPTMR_PSR_PCS(1),  ///< Low power oscillator (LPO - 1kHz)
      LptmrClockSel_Erclk32    = LPTMR_PSR_PCS(2),  ///< 32kHz Clock Source (ERCLK32)
      LptmrClockSel_Oscerclk   = LPTMR_PSR_PCS(3),  ///< Oscillator External Reference Clock (OSCERCLK)
   };

   /**
    * Prescaler Value
    * (lptmr_psr_prescaler)
    *
    * Configures the size of the Prescaler in Time Interval mode
    * Should only be altered when timer is disabled.
    */
   enum LptmrPrescale : uint8_t {
      LptmrPrescale_Direct        = LPTMR_PSR_PBYP(1)|LPTMR_PSR_PRESCALE(0),   ///< Prescaler = 1
      LptmrPrescale_DivBy_2       = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(0),   ///< Prescaler = 2
      LptmrPrescale_DivBy_4       = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(1),   ///< Prescaler = 4
      LptmrPrescale_DivBy_8       = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(2),   ///< Prescaler = 8
      LptmrPrescale_DivBy_16      = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(3),   ///< Prescaler = 16,
      LptmrPrescale_DivBy_32      = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(4),   ///< Prescaler = 32,
      LptmrPrescale_DivBy_64      = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(5),   ///< Prescaler = 64
      LptmrPrescale_DivBy_128     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(6),   ///< Prescaler = 128
      LptmrPrescale_DivBy_256     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(7),   ///< Prescaler = 256
      LptmrPrescale_DivBy_512     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(8),   ///< Prescaler = 512
      LptmrPrescale_DivBy_1024    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(9),   ///< Prescaler = 1024
      LptmrPrescale_DivBy_2048    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(10),  ///< Prescaler = 2048
      LptmrPrescale_DivBy_4096    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(11),  ///< Prescaler = 4096
      LptmrPrescale_DivBy_8192    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(12),  ///< Prescaler = 8192
      LptmrPrescale_DivBy_16384   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(13),  ///< Prescaler = 16384
      LptmrPrescale_DivBy_32768   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(14),  ///< Prescaler = 32768
      LptmrPrescale_DivBy_65536   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(15),  ///< Prescaler = 65536
   };

   /**
    * Filter Value
    * (lptmr_psr_glitchFilter)
    *
    * Configures the size of the glitch filter in Pulse Counting mode
    * Should only be altered when timer is disabled.
    */
   enum LptmrGlitchFilter : uint8_t {
      LptmrGlitchFilter_Direct         = LPTMR_PSR_PBYP(1)|LPTMR_PSR_PRESCALE(0),   ///< No glitch filter
      LptmrGlitchFilter_2_clocks       = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(1),   ///< 2 clock cycle glitch filter
      LptmrGlitchFilter_4_clocks       = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(2),   ///< 4 clock cycle glitch filter
      LptmrGlitchFilter_8_clocks       = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(3),   ///< 8 clock cycle glitch filter
      LptmrGlitchFilter_16_clocks      = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(4),   ///< 16 clock cycle glitch filter
      LptmrGlitchFilter_32_clocks      = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(5),   ///< 32 clock cycle glitch filter
      LptmrGlitchFilter_64_clocks      = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(6),   ///< 64 clock cycle glitch filter
      LptmrGlitchFilter_128_clocks     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(7),   ///< 128 clock cycle glitch filter
      LptmrGlitchFilter_256_clocks     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(8),   ///< 256 clock cycle glitch filter
      LptmrGlitchFilter_512_clocks     = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(9),   ///< 512 clock cycle glitch filter
      LptmrGlitchFilter_1024_clocks    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(10),  ///< 1024 clock cycle glitch filter
      LptmrGlitchFilter_2048_clocks    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(11),  ///< 2048 clock cycle glitch filter
      LptmrGlitchFilter_4096_clocks    = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(12),  ///< 4096 clock cycle glitch filter
      LptmrGlitchFilter_81924_clocks   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(13),  ///< 8192 clock cycle glitch filter
      LptmrGlitchFilter_16384_clocks   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(14),  ///< 16384 clock cycle glitch filter
      LptmrGlitchFilter_32768_clocks   = LPTMR_PSR_PBYP(0)|LPTMR_PSR_PRESCALE(15),  ///< 32768 clock cycle glitch filter
   };

   /**
    * Input Pin
    * (lptmr_csr_tps)
    *
    * Input source to be used in Pulse Counter mode
    * Should only be altered when timer is disabled.
    */
   enum LptmrInput : uint8_t {
      LptmrInput_CMP0   = LPTMR_CSR_TPS(0),  ///< CMP0
      LptmrInput_ALT1   = LPTMR_CSR_TPS(1),  ///< LPTMR0_ALT1 [-]
      LptmrInput_ALT2   = LPTMR_CSR_TPS(2),  ///< LPTMR0_ALT2 [-]
   };

   /**
    * Pin Polarity
    * (lptmr_csr_tpp)
    *
    * Polarity of the input source in Pulse Counter mode
    * Should only be altered when timer is disabled.
    */
   enum LptmrInputEdge : uint8_t {
      LptmrInputEdge_Rising    = LPTMR_CSR_TPP(0),  ///< Active-high, increment count on rising-edge
      LptmrInputEdge_Falling   = LPTMR_CSR_TPP(1),  ///< Active-low, increment count on falling-edge
   };


   // Bit operators for PSR register fields
   constexpr inline uint8_t operator|(LptmrClockSel op1, LptmrPrescale op2)         { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(LptmrClockSel op1, LptmrGlitchFilter op2)     { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(LptmrPrescale op1, LptmrClockSel op2)         { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(LptmrPrescale op1, LptmrGlitchFilter op2)     { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(LptmrGlitchFilter op1, LptmrClockSel op2)     { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(LptmrGlitchFilter op1, LptmrPrescale op2)     { return uint8_t(op1)|uint8_t(op2); };
   

   // Bit operators for CSR register fields
   constexpr inline uint8_t operator|(LptmrInput op1, LptmrInputEdge op2)     { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(LptmrInputEdge op1, LptmrInput op2)     { return uint8_t(op1)|uint8_t(op2); };
   
class LptmrBasicInfo {

public:

}; // class LptmrBasicInfo 

class Lptmr0Info : public LptmrBasicInfo {

public:

   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   1: LPTMR0_ALT1          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: LPTMR0_ALT2          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:lptmr0
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with LPTMR0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with LPTMR0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LPTMR0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Lptmr0
    */
   static void enableClock() {
      SIM->SCGC5 = SIM->SCGC5 | SIM_SCGC5_LPTMR0_MASK;
   }
   
   /**
    *  Disable clock to Lptmr0
    */
   static void disableClock() {
      SIM->SCGC5 = SIM->SCGC5 & ~SIM_SCGC5_LPTMR0_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = LPTMR0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<LPTMR_Type> lptmr = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
}; // class Lptmr0Info



#ifdef PCC_PCC_LPTMR0_CGC_MASK
/**
 * Select the LPTMR clock source which determines count speed or glitch filtering
 */
enum LptmrClockSel {
   LptmrClockSel_SircDiv2Clk  = LPTMR_PSR_PCS(0), ///< Slow Internal Reference Div 2 Clock (SIRCDIV2_CLK)
   LptmrClockSel_Lpo1Kclk     = LPTMR_PSR_PCS(1), ///< Low power oscillator 1kHz (LPO1K_CLK)
   LptmrClockSel_Rtcclk       = LPTMR_PSR_PCS(2), ///< 32kHz Clock Source (RTC_CLK)
   LptmrClockSel_PccLptmrClk  = LPTMR_PSR_PCS(3), ///< Clock from PCC_LPTMRx multiplexor (PCC)
   LptmrClockSel_Default      = LptmrClockSel_Lpo1Kclk,
};
#endif



#endif // /LPTMR/_BasicInfoGuard
/**
 * End LPTMR_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_LPTMR_H */
