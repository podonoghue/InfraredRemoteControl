/**
 * @file     pdb.h (180.ARM_Peripherals/Project_Headers/pdb.h)
 * @brief    Programmable Delay Block
 */

#ifndef HEADER_PDB_H
#define HEADER_PDB_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <math.h>
#include "pin_mapping.h"

// No handler defined for PDB0


namespace USBDM {

#if false // /PDB/_BasicInfoGuard

/**
 * @addtogroup PDB_Group PDB, Programmable Delay Block
 * @brief Peripheral information for Programmable Delay Block
 * @{
 */
/**
 * Notes on the PDB.
 *
 * Components:\n
 *     - Channels+pre-triggers - Usually associated with an ADC
 *     - DAC delays            - Associated with a DAC
 *     - Pulse outputs         - Usually associated with a CMP
 *
 * Operation:\n
 * - The PDB can be triggered from another peripheral or directly by software using softwareTrigger().
 * - When triggered, the PDB counter and the DAC delay counters are restarted.
 * - The period of the PDB counter and the delay counters may be independently controlled.
 *    - The PDB counter counts [0..MOD]. Set with setPeriod().
 *    - The DAC delay counters count [0..DACINTx]. Set with configureDacTrigger().
 *      The counters may be bypassed for external triggers.
 * - The PDB may operate in one-shot or continuous mode.
 *    - One shot mode   - The PDB and DAC delay counters are reset on trigger. The PDB counter counts one sequence only.
 *      The DAC counter only operates while the main counter is counting but it may produce multiple triggers in the sequence.
 *    - Continuous mode - As above but the counter resets when it reaches the counter period and restarts.\n
 *      The DAC delay counters are NOT reset on PDB counter roll-over so operate independently after initial trigger.
 * - I would expect the DAC Delay counter period to be less than or equal to the PDB counter period in one-shot mode.
 * - The DAC Delay period may be set smaller than (PDB counter period/2) to trigger multiple DAC output
 *   triggers within a PDB period but more often there would be only a single DAC event e.g.
 *   <b>(PDB counter period/2) < (DAC Delay period) <= (PDB counter period)</b>. Again this is in one-shot mode.
 * - The pre-triggers within a channel are associated with different ADC pre-triggers e.g. SC1[n]/R[n]. The pre-triggers
 *   are referenced to the main PDB counter.\n
 *   This allows multiple ADC channels (inputs) to be used with a PDB period - usually only 2 are available per ADC.
 *   Set with configureAdcPretrigger().
 * - The pulse outputs may be configured as high for a pulse from [start...end] times based on the PDB counter.
 *   Set with configurePulseOutput().
 */
/**
 * Peripheral information for PDB, Programmable Delay Block.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Software Trigger
    * (pdb_sc_swtrig)
    *
    * When software trigger is selected, writing 1 to this field resets and restarts the counter. 
    * Writing 0 to this field has no effect. Reading this field yields 0
    */
   enum PdbSoftwareTrigger : uint32_t {
      PdbSoftwareTrigger_NoAction         = PDB_SC_SWTRIG(0),  ///< No Action
      PdbSoftwareTrigger_RestartCounter   = PDB_SC_SWTRIG(1),  ///< Load registers
   };

   /**
    * PDB Interrupt Flag
    * (pdb_sc_pdbif)
    *
    * This field is set when the counter value is equal to the IDLY register. Writing zero clears this field
    */
   enum PdbInterruptFlag : uint32_t {
      PdbInterruptFlag_NoEvent          = PDB_SC_PDBIF(0),  ///< No event
      PdbInterruptFlag_RequestPending   = PDB_SC_PDBIF(1),  ///< Request Pending
   };

   /**
    * PDB Load
    * (pdb_sc_ldok)
    *
    * Writing 1 to this bit updates the internal registers MOD, IDLY, CHnDLYm, DACINTx,and POyDLY from their buffers.
    * The new values will take effect according to the load mode (LDMOD).
    * It can only be set when PDBEN is already set, or at the same time as setting PDBEN.
    * It will remain set until the internal buffers are loaded into the registers or until the PDB is disabled.
    * Writing 0 has no effect.
    */
   enum PdbLoad : uint32_t {
      PdbLoad_NoAction        = PDB_SC_LDOK(0),  ///< No Action
      PdbLoad_LoadRegisters   = PDB_SC_LDOK(1),  ///< Load registers
   };

   /**
    * Channel Sequence Error Flags
    * (pdb_s_err)
    *
    * Indicates a sequence error was detected on pre-trigger from the PDB channel.
    * ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n.
    * While this conversion is in progress, a new pre-trigger m from the PDB channel cannot be
    * accepted by ADCn.
    * If this occurs then ERR[m] is set.
    * Write 0s to clear the sequence error flags.
    */
   enum class PdbChannelSequenceErrorFlag : uint32_t {
      PreTrigger0   = PDB_S_ERR(1U<<0),  ///< Pre-trigger 0 Sequence Error
      PreTrigger1   = PDB_S_ERR(1U<<1),  ///< Pre-trigger 1 Sequence Error
      NoError       = PDB_S_ERR(0x0U),   ///< No Error
      AnyError      = PDB_S_ERR(0x3U),   ///< Any Error
   };

   /**
    * Channel Pre-trigger Flags
    * (pdb_s_cf)
    *
    * The CF[m] bit is set when the PDB counter matches the pre-trigger delay (CHnDLYm+1).
    * Write 0 to clear these bits
    */
   enum class PdbChannelFlag : uint32_t {
      PreTrigger0   = PDB_S_CF(1U<<0),  ///< Pre-trigger 0 Sequence Error
      PreTrigger1   = PDB_S_CF(1U<<1),  ///< Pre-trigger 1 Sequence Error
      NoEvent       = PDB_S_CF(0x0U),   ///< No Event
      AnyEvent      = PDB_S_CF(0x3U),   ///< Any Event
   };

   /**
    * Trigger Input Source Select
    * (pdb_sc_trgsel)
    *
    * Selects the trigger input source for the PDB.
    * The trigger input source can be internal or external (EXTRG pin),
    * or the software trigger
    */
   enum PdbTrigger : uint32_t {
      PdbTrigger_PdbDisabled   = PDB_SC_PDBEN(0)|PDB_SC_TRGSEL(0),   ///< PDB Disabled
      PdbTrigger_External      = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(0),   ///< External Trigger (PDB0_EXTRG)
      PdbTrigger_Cmp0          = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(1),   ///< CMP 0
      PdbTrigger_Cmp1          = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(2),   ///< CMP 1
      PdbTrigger_PitCh0        = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(4),   ///< PIT Ch 0 Output
      PdbTrigger_PitCh1        = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(5),   ///< PIT Ch 1 Output
      PdbTrigger_PitCh2        = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(6),   ///< PIT Ch 2 Output
      PdbTrigger_PitCh3        = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(7),   ///< PIT Ch 3 Output
      PdbTrigger_Ftm0          = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(8),   ///< FTM0 Init and Ext Trigger Outputs
      PdbTrigger_Ftm1          = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(9),   ///< FTM1 Init and Ext Trigger Outputs
      PdbTrigger_RtcAlarm      = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(12),  ///< RTC Alarm
      PdbTrigger_RtcSeconds    = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(13),  ///< RTC Seconds
      PdbTrigger_Lptmr         = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(14),  ///< LPTMR
      PdbTrigger_Software      = PDB_SC_PDBEN(1)|PDB_SC_TRGSEL(15),  ///< Software trigger is selected
   };

   /**
    * Register Load Select
    * (pdb_sc_ldmod)
    *
    * Selects when to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,
    * after 1 is written to LDOK
    */
   enum PdbLoadMode : uint32_t {
      PdbLoadMode_Immediate       = PDB_SC_LDMOD(0),  ///< Registers loaded immediately on LDOK=1
      PdbLoadMode_Modulo          = PDB_SC_LDMOD(1),  ///< Registers loaded when PDB counter reaches MOD
      PdbLoadMode_Event           = PDB_SC_LDMOD(2),  ///< Registers loaded on trigger input event
      PdbLoadMode_EventOrModulo   = PDB_SC_LDMOD(3),  ///< Registers loaded when PDB counter reaches MOD or on trigger input event
   };

   /**
    * Sequence Error Interrupt Enable
    * (pdb_sc_pdbeie)
    *
    * This bit enables the sequence error interrupt
    * When this bit is set, any of the channel sequence error flags generates a sequence error interrupt
    */
   enum PdbErrorAction : uint32_t {
      PdbErrorAction_None        = PDB_SC_PDBEIE(0),  ///< No interrupt on error
      PdbErrorAction_Interrupt   = PDB_SC_PDBEIE(1),  ///< Interrupt on error
   };

   /**
    * PDB operation mode
    * (pdb_sc_cont)
    *
    * Select continuous or one-shot mode
    */
   enum PdbMode : uint32_t {
      PdbMode_OneShot      = PDB_SC_CONT(0),  ///< Sequence runs once only
      PdbMode_Continuous   = PDB_SC_CONT(1),  ///< Sequence runs continuously once triggered
   };

   /**
    * PDB Channel select
    * (pdb_channel)
    *
    * Indicates a PDB channel
    */
   enum PdbChannel {
      PdbChannel_0   = 0,  ///< Channel 0
   };

   /**
    * Clock Prescaler Divider Select
    * (pdb_sc_divider)
    *
    * The PDB input clock is divided by this factor
    */
   enum PdbPrescale : uint32_t {
      PdbPrescale_DivBy_1      = PDB_SC_MULT(0)|PDB_SC_PRESCALER(0),  ///< Divide by 1
      PdbPrescale_DivBy_2      = PDB_SC_MULT(0)|PDB_SC_PRESCALER(1),  ///< Divide by 2
      PdbPrescale_DivBy_4      = PDB_SC_MULT(0)|PDB_SC_PRESCALER(2),  ///< Divide by 4
      PdbPrescale_DivBy_8      = PDB_SC_MULT(0)|PDB_SC_PRESCALER(3),  ///< Divide by 8
      PdbPrescale_DivBy_10     = PDB_SC_MULT(1)|PDB_SC_PRESCALER(0),  ///< Divide by 10
      PdbPrescale_DivBy_16     = PDB_SC_MULT(0)|PDB_SC_PRESCALER(4),  ///< Divide by 16
      PdbPrescale_DivBy_20     = PDB_SC_MULT(1)|PDB_SC_PRESCALER(1),  ///< Divide by 20
      PdbPrescale_DivBy_32     = PDB_SC_MULT(0)|PDB_SC_PRESCALER(5),  ///< Divide by 32
      PdbPrescale_DivBy_40     = PDB_SC_MULT(1)|PDB_SC_PRESCALER(2),  ///< Divide by 40
      PdbPrescale_DivBy_64     = PDB_SC_MULT(0)|PDB_SC_PRESCALER(6),  ///< Divide by 64
      PdbPrescale_DivBy_80     = PDB_SC_MULT(1)|PDB_SC_PRESCALER(3),  ///< Divide by 80
      PdbPrescale_DivBy_128    = PDB_SC_MULT(0)|PDB_SC_PRESCALER(7),  ///< Divide by 128
      PdbPrescale_DivBy_160    = PDB_SC_MULT(1)|PDB_SC_PRESCALER(4),  ///< Divide by 160
      PdbPrescale_DivBy_320    = PDB_SC_MULT(1)|PDB_SC_PRESCALER(5),  ///< Divide by 320
      PdbPrescale_DivBy_640    = PDB_SC_MULT(1)|PDB_SC_PRESCALER(6),  ///< Divide by 640
      PdbPrescale_DivBy_1280   = PDB_SC_MULT(1)|PDB_SC_PRESCALER(7),  ///< Divide by 1280
      PdbPrescale_DivBy_2560   = PDB_SC_MULT(2)|PDB_SC_PRESCALER(7),  ///< Divide by 2560
      PdbPrescale_DivBy_5120   = PDB_SC_MULT(3)|PDB_SC_PRESCALER(7),  ///< Divide by 5120
   };

   /**
    * Clock prescaler is calculated from given period
    * (pdb_sc_autoDivider)
    *
    * 
    */
   enum PdbPrescale_Auto : uint32_t {
      PdbPrescale_Auto_Calculated   = PDB_SC_MULT(3)|PDB_SC_PRESCALER(0),  ///< Auto select
   };

   /**
    * Timer event action
    * (pdb_sc_action)
    *
    * Selects the action taken when the timer reaches the interrupt delay value
    */
   enum PdbAction {
      PdbAction_None        = PDB_SC_DMAEN(0)|PDB_SC_PDBIE(0),  ///< No action on event
      PdbAction_Interrupt   = PDB_SC_DMAEN(0)|PDB_SC_PDBIE(1),  ///< Interrupt on event
      PdbAction_Dma         = PDB_SC_DMAEN(1)|PDB_SC_PDBIE(1),  ///< DMA request on event
   };

   /**
    * Channel Pretrigger ADC.SC1[0]
    * (pdb_ch0_c1_pt0)
    *
    * Select pre-trigger mode
    */
   enum PdbPretrigger0 : uint32_t {
      PdbPretrigger0_Disabled     = PDB_C1_EN(0<<0)|PDB_C1_TOS(0<<0)|PDB_C1_BB(0<<0),  ///< Pretrigger disabled
      PdbPretrigger0_Bypassed     = PDB_C1_EN(1<<0)|PDB_C1_TOS(0<<0)|PDB_C1_BB(0<<0),  ///< Pretrigger asserts 1 clock after trigger
      PdbPretrigger0_Delayed      = PDB_C1_EN(1<<0)|PDB_C1_TOS(1<<0)|PDB_C1_BB(0<<0),  ///< Pretrigger asserts 1 clock + delay after trigger
      PdbPretrigger0_BackToBack   = PDB_C1_EN(1<<0)|PDB_C1_TOS(0<<0)|PDB_C1_BB(1<<0),  ///< Back-to-back, pretrigger asserts 2 clocks after previous acknowledge
   };

   /**
    * Channel Pretrigger ADC.SC1[1]
    * (pdb_ch0_c1_pt1)
    *
    * Select pre-trigger mode
    */
   enum PdbPretrigger1 : uint32_t {
      PdbPretrigger1_Disabled     = PDB_C1_EN(0<<1)|PDB_C1_TOS(0<<1)|PDB_C1_BB(0<<1),  ///< Pretrigger disabled
      PdbPretrigger1_Bypassed     = PDB_C1_EN(1<<1)|PDB_C1_TOS(0<<1)|PDB_C1_BB(0<<1),  ///< Pretrigger asserts 1 clock after trigger
      PdbPretrigger1_Delayed      = PDB_C1_EN(1<<1)|PDB_C1_TOS(1<<1)|PDB_C1_BB(0<<1),  ///< Pretrigger asserts 1 clock + delay after trigger
      PdbPretrigger1_BackToBack   = PDB_C1_EN(1<<1)|PDB_C1_TOS(0<<1)|PDB_C1_BB(1<<1),  ///< Back-to-back, pretrigger asserts 2 clocks after previous acknowledge
   };

   /**
    * Pulse output trigger enable
    * (pdb_poen_en0)
    *
    * Enable the trigger to DAC 0
    */
   enum PdbPulseOutput0 : uint8_t {
      PdbPulseOutput0_Disabled   = PDB_POEN_POEN(0<<0),  ///< Pulse output disabled
      PdbPulseOutput0_Enabled    = PDB_POEN_POEN(1<<0),  ///< Pulse output 0 is enabled
   };

   /**
    * Pulse output trigger enable
    * (pdb_poen_en1)
    *
    * Enable the trigger to DAC 1
    */
   enum PdbPulseOutput1 : uint8_t {
      PdbPulseOutput1_Disabled   = PDB_POEN_POEN(0<<1),  ///< Pulse output disabled
      PdbPulseOutput1_Enabled    = PDB_POEN_POEN(1<<1),  ///< Pulse output 1 is enabled
   };

class PdbBasicInfo {

public:
}; // class PdbBasicInfo 

class Pdb0Info : public PdbBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: PDB0_EXTRG           = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:pdb0_1ch_2pt_0dac_2po
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with PDB0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with PDB0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PDB0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Pdb0
    */
   static void enableClock() {
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_PDB_MASK;
   }
   
   /**
    *  Disable clock to Pdb0
    */
   static void disableClock() {
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_PDB_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PDB0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<PDB_Type> pdb = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
}; // class Pdb0Info




/**
 * End PDB_Group
 * @}
 */
#endif // /PDB/_BasicInfoGuard
} // End namespace USBDM

#endif /* HEADER_PDB_H */
