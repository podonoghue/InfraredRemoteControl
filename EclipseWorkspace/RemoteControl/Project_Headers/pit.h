/**
 * @file     pit.h (180.ARM_Peripherals/Project_Headers/pit-MK.h)
 *
 * @brief    Programmable Interrupt Timer interface
 */

#ifndef INCLUDE_USBDM_PIT_H_
#define INCLUDE_USBDM_PIT_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "math.h"
#include "derivative.h"
#include "system.h"
#include "pin_mapping.h"
#if false // (/DMA/_BasicInfoGuard)
#include "dma.h"
#endif

// No handler defined for PIT Ch0
// No handler defined for PIT Ch1
// No handler defined for PIT Ch2
// No handler defined for PIT Ch3


#if true // /PIT/_BasicInfoGuard

namespace USBDM {

/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Abstraction for Programmable Interrupt Timer
 * @{
 */
/**
 * Peripheral information for PIT, Programmable Interrupt Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Pit Channel Number
    * (pit_channelNumber)
    *
    * Selected PIT channel
    */
   enum PitChannelNum : uint8_t {
      PitChannelNum_0         = 0,           ///< Channel 0
      PitChannelNum_Pit_ch0   = 0,           ///< Pin PIT_CH0
      PitChannelNum_1         = 1,           ///< Channel 1
      PitChannelNum_Pit_ch1   = 1,           ///< Pin PIT_CH1
      PitChannelNum_2         = 2,           ///< Channel 2
      PitChannelNum_Pit_ch2   = 2,           ///< Pin PIT_CH2
      PitChannelNum_3         = 3,           ///< Channel 3
      PitChannelNum_Pit_ch3   = 3,           ///< Pin PIT_CH3
      PitChannelNum_None      = 0b10000000,  ///< Channel Not Allocated
   };

   /**
    * Module Disable
    * (pit_mcr_mdis)
    *
    * Disabled PIT module clock
    */
   enum PitOperation : uint8_t {
      PitOperation_Enabled    = PIT_MCR_MDIS(0),  ///< PIT enabled
      PitOperation_Disabled   = PIT_MCR_MDIS(1),  ///< PIT disabled
   };

   /**
    * Freeze in Debug
    * (pit_mcr_frz)
    *
    * Determines if timers are stopped in Debug mode
    */
   enum PitDebugMode : uint8_t {
      PitDebugMode_RunInDebug    = PIT_MCR_FRZ(0),  ///< Timers run in Debug
      PitDebugMode_StopInDebug   = PIT_MCR_FRZ(1),  ///< Timers stop in Debug
   };

   /**
    * Timer Channel Enable
    * (pit_tctrl_ten[0])
    *
    * Allows operation of this channel
    */
   enum PitChannelEnable : uint8_t {
      PitChannelEnable_Disabled   = PIT_TCTRL_TEN(0),  ///< Channel disabled
      PitChannelEnable_Enabled    = PIT_TCTRL_TEN(1),  ///< Channel enabled
   };

   /**
    * Action on timer event
    * (pit_tctrl_tie[0])
    *
    * Allows interrupts from this channel
    */
   enum PitChannelAction : uint8_t {
      PitChannelAction_None        = PIT_TCTRL_TIE(0),  ///< None
      PitChannelAction_Interrupt   = PIT_TCTRL_TIE(1),  ///< Interrupt
   };

class PitBasicInfo {

public:
   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = true;
   
   /**
    * Type definition for Pit interrupt call back.
    */
   typedef void (*CallbackFunction)();
   
   /** Bit-mask of allocated channels */
   static inline uint32_t allocatedChannels = 0;
   
   /**
    * Class used to do initialisation of the Pit
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Pit::Init pitInit {
    *
    *   // Setup values
    *   PitMcrMdis_ClockEnabled                   // Module Disable,
    *   PitMcrFrz_TimersRunInDebug                // Freeze,
    *
    * };
    *
    * // Initialise Pit from values specified above
    * Pit::configure(pitInit)
    * @endcode
    */
   class Init {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr Init(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      // Module Disable (pit_mcr_mdis)
      // Freeze in Debug (pit_mcr_frz)
      uint32_t mcr = 0;

      /**
       * Constructor for Module Disable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pitOperation Disabled PIT module clock
       */
      template <typename... Types>
      constexpr Init(PitOperation pitOperation, Types... rest) : Init(rest...) {
   
         this->mcr = (this->mcr&~PIT_MCR_MDIS_MASK) | pitOperation;
      }

      /**
       * Constructor for Freeze in Debug
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pitDebugMode Determines if timers are stopped in Debug mode
       */
      template <typename... Types>
      constexpr Init(PitDebugMode pitDebugMode, Types... rest) : Init(rest...) {
   
         this->mcr = (this->mcr&~PIT_MCR_FRZ_MASK) | pitDebugMode;
      }

   };// class PitBasicInfo::Init
   
   /**
    * Class used to do initialisation of a Pit channel
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * // Initialisation values for Pit channel
    * // Parameters available may vary with device - see Pit::DefaultChannelInitValues[] for relevant example
    * static const Pit::ChannelInit channelInit {
    *       PitChannelNum_0,
    *
    *       PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
    *       PitChannelChain_Disabled , // Chain with previous channel - Timers are not chained
    *       PitChannelAction_None ,    // Timer Interrupt Enable - Interrupts are disabled
    *       callBackFunction,          // Call-back function to use
    *       NvicPriority_Normal ,      // IRQ level for this peripheral - Normal
    *       3999_ticks,                // Reload value for channel (in ticks or seconds)
    *
    *       Pit::DefaultChannelInitValues[1], // An existing declaration may be referenced as the last item
    *                                            This becomes a base value modified by above values.
    * };
    *
    * // Initialise PIT channel from values specified above
    * Pit::configure(channelInit)
    * @endcode
    */
   class ChannelInit {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      ChannelInit(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr ChannelInit(const ChannelInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr ChannelInit() = default;
   
      // Peripheral interrupt handling (irqHandlingMethod)
      CallbackFunction callbackFunction = nullptr;

      // Reload value channel 0 (pit_ldval_tsv[0])
      Ticks ldval = 0_ticks;

      // Timer Channel Enable (pit_tctrl_ten[0])
      // Action on timer event (pit_tctrl_tie[0])
      uint8_t tctrl = 0;

      // IRQ priority levels (nvic_irqLevel)
      NvicPriority irqlevel = NvicPriority_Normal;
   
      // Pit Channel Number (pit_channelNumber)
      PitChannelNum channelnumber = PitChannelNum_None;

      /**
       * Constructor for Peripheral interrupt handling
       *
       * @tparam   Types
       * @param    rest
       *
       * @param callbackFunction If enabled, the handler may be set using the setCallback() function or
       *        by overriding the interrupt handler method in the peripheral class
       *        If not enabled, then interrupt handlers may be installed by naming them 
       *        (see weak names used in vector table).
       */
      template <typename... Types>
      constexpr ChannelInit(CallbackFunction callbackFunction, Types... rest) : ChannelInit(rest...) {
   
         this->callbackFunction = callbackFunction;
      }

      /**
       * Constructor for IRQ priority levels
       *
       * @tparam   Types
       * @param    rest
       *
       * @param nvicPriority Priority level used to configure the NVIC
       *        Subset of available levels
       */
      template <typename... Types>
      constexpr ChannelInit(NvicPriority nvicPriority, Types... rest) : ChannelInit(rest...) {
   
         irqlevel = nvicPriority;
      }

      /**
       * Constructor for Pit Channel Number
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pitChannelNum Selected PIT channel
       */
      template <typename... Types>
      constexpr ChannelInit(PitChannelNum pitChannelNum, Types... rest) : ChannelInit(rest...) {
   
         channelnumber = pitChannelNum;
      }
   
      /**
       * Constructor for Reload value channel 0
       *
       * @tparam   Types
       * @param    rest
       *
       * @param ticks Value loaded in timer register on roll-over
       */
      template <typename... Types>
      constexpr ChannelInit(const Ticks& ticks, Types... rest) : ChannelInit(rest...) {
   
         ldval = ticks;
      }
   
      /**
       * Constructor for Timer Channel Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pitChannelEnable Allows operation of this channel
       */
      template <typename... Types>
      constexpr ChannelInit(PitChannelEnable pitChannelEnable, Types... rest) : ChannelInit(rest...) {
   
         tctrl = (tctrl&~PIT_TCTRL_TEN_MASK) | pitChannelEnable;
      }
   
      /**
       * Constructor for Action on timer event
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pitChannelAction Allows interrupts from this channel
       */
      template <typename... Types>
      constexpr ChannelInit(PitChannelAction pitChannelAction, Types... rest) : ChannelInit(rest...) {
   
         tctrl = (tctrl&~PIT_TCTRL_TIE_MASK) | pitChannelAction;
      }
   
   };// class PitBasicInfo::ChannelInit
   
}; // class PitBasicInfo 

class PitInfo : public PitBasicInfo {

public:
   /*
    * Template:pit_4ch
    */
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = true;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PIT_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * IRQ entry
    * (irq_enum)
    *
    * Select amongst interrupts associated with the peripheral
    */
   enum IrqNum {
      IrqNum_Ch0   = 0,  ///< Maps to PIT_Ch0_IRQn
      IrqNum_Ch1   = 1,  ///< Maps to PIT_Ch1_IRQn
      IrqNum_Ch2   = 2,  ///< Maps to PIT_Ch2_IRQn
      IrqNum_Ch3   = 3,  ///< Maps to PIT_Ch3_IRQn
   };

   /**
    * Enable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum) {
      NVIC_EnableIRQ(irqNums[irqNum]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum, NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[irqNum], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void disableNvicInterrupts(IrqNum irqNum) {
      NVIC_DisableIRQ(irqNums[irqNum]);
   }
   
   template<typename T>
   using CallbackWrapper = USBDM::CallbackWrapper<T, PitInfo>;
   
   /**
    * Function to wrap a member function as a static callback function
    * Example:
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callbackFuction() {
    *       ...;
    *    }
    * };
    * ...
    *    AClass *tester = new AClass{};
    *
    *    auto cb = Pit::wrapCallback(tester, &AClass::callbackFuction);
    *    Pit::setCallback(cb);
    *   @endcode
    *
    * @tparam T               Type of class containing callback (inferred)
    *
    * @param classInstance    Pointer to instance of class
    * @param memberFunction   Pointer to the member function
    *
    * @return  Wrapper
    */
   template<typename T>
   static auto wrapCallback(T *classInstance, void (T::*memberFunction)()) {
      static CallbackWrapper<T> sClass(classInstance, memberFunction);
      return sClass.callback;
   }
   
   /** Callback function for Pit */
   static inline CallbackFunction sCallbacks[4] = {
      unhandledCallback,  // PIT_Ch0_IRQn 
      unhandledCallback,  // PIT_Ch1_IRQn 
      unhandledCallback,  // PIT_Ch2_IRQn 
      unhandledCallback,  // PIT_Ch3_IRQn 
   };
   
   /**
    * Set interrupt callback function.
    *
    * @param irqNum Select amongst interrupts associated with the peripheral
    * @param  pitCallback Callback function to execute on interrupt
    *                             Use nullptr to remove callback.
    */
   static void setCallback(IrqNum irqNum, CallbackFunction pitCallback) {
      if (pitCallback == nullptr) {
         pitCallback = unhandledCallback;
      }
      // Allow either no handler set yet, setting same handler or removing handler
      usbdm_assert(
            (sCallbacks[irqNum] == unhandledCallback) ||
            (sCallbacks[irqNum] == pitCallback) ||
            (pitCallback == unhandledCallback),
            "Handler already set");
      sCallbacks[irqNum] = pitCallback;
   }
   
   /**
    *  Enable clock to Pit
    */
   static void enableClock() {
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_PIT_MASK;
   }
   
   /**
    *  Disable clock to Pit
    */
   static void disableClock() {
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_PIT_MASK;
   }
   
   /**
    * Basic enable of Pit
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      enableClock();
   }
   
   /**
    * Disables Pit
    */
   static void disable() {
   
      
      disableNvicInterrupts(IrqNum_Ch0);
      disableNvicInterrupts(IrqNum_Ch1);
      disableNvicInterrupts(IrqNum_Ch2);
      disableNvicInterrupts(IrqNum_Ch3);
      disableClock();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PIT_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<PIT_Type> pit = baseAddress;
   
   /**
    * Information describing the priority and callback function for each interrupt
    */
   typedef InitVectors<Init, CallbackFunction, IrqNum, 4> Init;
   
   //! Number of PIT channels
   static constexpr uint32_t NumChannels  = 4;

   /** Bitmask used to indicate a channel call-back is one-shot */
   static inline uint8_t clearOnEvent = 0;
   
   /**
    *  PIT interrupt handler -  Calls PIT callback
    *  Used when each channel has an individual handler (IRQ vector)
    *
    *  @tparam pitChannelNum Channel number
    */
   template<IrqNum pitIrqNum>
   static void irqHandler() {
   
      auto &channel = pit->CHANNEL[pitIrqNum];
   
      // Clear interrupt flag
      channel.TFLG = PIT_TFLG_TIF_MASK;
   
      // Call handler
      sCallbacks[pitIrqNum]();
   
      // If a one-shot then stop channel
      if (clearOnEvent&(1<<pitIrqNum)) {
         channel.TCTRL = channel.TCTRL & ~PIT_TCTRL_TEN_MASK;
         sCallbacks[pitIrqNum] = unhandledCallback;
         clearOnEvent &= ~(1<<pitIrqNum);
      }
   }
   
   
   /**
    * Configure PIT from values specified in init
    * The peripheral is enabled.
    * Only shared hardware is initialised. Channel hardware is unchanged.
    * Channel reservations are cleared.
    *
    * @param init Class containing initialisation values
    */
   static void configure(const Init &init) {
   
      // Enable peripheral
      enable();
      (void)pit->MCR; // Dummy read to ensure clock enable completed (errata e7914)
   
      // Configure common settings
      pit->MCR    = init.mcr;
   
      // Clear channel reservations
      allocatedChannels = -1;
   }
   
   /**
    * Configure PIT with default settings.
    * Shared hardware is initialised.
    * All channel hardware is configured with their default settings.
    * The configuration is determined from Configure.usbdmProject
    */
   static inline void defaultConfigure() {
   
      // Update shared hardware
      configure(DefaultInitValue);
   
   }
   
   /**
    * Enables and configures the PIT if not already done.
    * If required:
    *  - Shared hardware is initialised.
    *  - All channel hardware is configured with their default settings.
    *  - The configuration is determined from Configure.usbdmProject
    */
   static void defaultConfigureIfNeeded() {
   
       enable();
   
      // Check if disabled and configure if so
      if ((pit->MCR & PIT_MCR_MDIS_MASK) != 0) {
         // Update shared hardware
         configure(DefaultInitValue);
      }
   }
   
   /**
    * Default initialisation value for Pit
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      PitDebugMode_StopInDebug,    // (pit_mcr_frz)              Freeze in Debug - Timers stop in Debug
   };

   
   /**
    * Configure PIT channel from values specified in init
    * The PIT shared hardware will be default initialised if necessary.
    * This version allows the channel number to be explicitly given to allow
    * sharing of an init class for channels requiring the same configuration.
    *
    * @param channelNum Number of channel to initialise
    * @param init       Class containing initialisation values (channel number is ignored)
    */
   static void configure(PitChannelNum channelNum, const ChannelInit &init) {
   
      if (channelNum>=NumChannels) {
         // Illegal PIT channel number
         __BKPT();
         return;
      }
      // Enable peripheral if needed using default settings
      defaultConfigureIfNeeded();
   
      // Disable channel
      pit->CHANNEL[channelNum].TCTRL = 0;
   
      Ticks ldval = init.ldval;
   
   
      pit->CHANNEL[channelNum].LDVAL = ldval;
   
      setCallback(IrqNum(channelNum), init.callbackFunction);
   
      enableNvicInterrupts(IrqNum(channelNum), init.irqlevel);
   
      // Configure channel
      pit->CHANNEL[channelNum].TCTRL = init.tctrl;
   }
   
   /**
    * Configure multiple PIT channels
    *
    * @tparam N   Number of channels (deduced)
    *
    * @param ar   Array of channel-init structures
    */
   template<int N>
   static void configure(const ChannelInit (&ar)[N]) {
      for (int i=0; i<N; i++) {
         configure(ar[i]);
      }
   }
   
   /**
    * Configure PIT channel from values specified in init.
    * The PIT shared hardware will be default initialised if necessary
    *
    * @param init Class containing initialisation values
    */
   static void configure(const ChannelInit &init) {
      configure(init.channelnumber, init);
   }
   
   /**
    * Default initialisation values for PIT channels
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr ChannelInit DefaultChannelInitValues[] = {
   }; // DefaultChannelInitValues

   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static __attribute__((always_inline)) uint32_t getClockFrequency() {
      return SystemBusClock;
   }

}; // class PitInfo



/**
 * Calculate a PIT channel number using an offset from an existing number
 *
 * @param pitChannelNum Base channel to use
 * @param offset  Offset from base channel
 *
 * @return  PIT channel number calculated from channel+offset
 */
constexpr PitChannelNum inline operator+(PitChannelNum pitChannelNum, unsigned offset) {
   return PitChannelNum(unsigned(pitChannelNum) + offset);
}

/**
 * Calculate a PIT channel number using an offset from an existing number
 *
 * @param pitChannelNum Base channel to use
 * @param offset  Offset from base channel
 *
 * @return  PIT channel number calculated from channel+offset
 */
constexpr PitChannelNum inline operator+(PitChannelNum pitChannelNum, int offset) {
   return PitChannelNum(unsigned(pitChannelNum) + unsigned(offset));
}

/**
 * @brief Class representing a Programmable Interrupt  Timer
 *
 * <b>Example</b>
 * @code
 *
 * @endcode
 */
template<class Info>
class PitBase_T : public Info {

private:
   /**
    * This class is not intended to be instantiated
    */
   PitBase_T(const PitBase_T&) = delete;
   PitBase_T(PitBase_T&&) = delete;

protected:

   /** Default TCTRL value for timer channel */
   static constexpr uint32_t PIT_TCTRL_DEFAULT_VALUE = (PIT_TCTRL_TEN_MASK);

   // Reduce clutter
   using Info::allocatedChannels;
   using Info::NumChannels;

// /PIT/protectedMethods not found
public:

   using IrqNum = PitInfo::IrqNum;

   /// Defaulted constructor
   constexpr PitBase_T() = default;

// /PIT/publicMethods not found
   /**
    * Allocate PIT channel.
    *
    * @return PitChannelNum_None - No suitable channel available.  Error code set.
    * @return Channel number     - Number of allocated channel
    */
   static PitChannelNum allocateChannel() {
      CriticalSection cs;
      unsigned channelNum = __builtin_ffs(allocatedChannels);
      if ((channelNum == 0)||(--channelNum>=NumChannels)) {
         setErrorCode(E_NO_RESOURCE);
         return PitChannelNum_None;
      }
      allocatedChannels &= ~(1<<channelNum);
      return (PitChannelNum) channelNum;
   }

#if false // (/DMA/_BasicInfoGuard)
   /**
    * Allocate PIT channel associated with DMA channel.
    * This is a channel that may be used to throttle the associated DMA channel.
    *
    * @param dmaChannelNum DMA channel being used.
    *
    * @return PitChannelNum_None - No suitable channel available.  Error code set.
    * @return Channel number     - Number of allocated channel
    */
   static PitChannelNum allocateDmaAssociatedChannel(DmaChannelNum dmaChannelNum) {
      const uint32_t channelMask = (1<<dmaChannelNum);
      usbdm_assert(dmaChannelNum<NumChannels, "No PIT channel associated with DMA channel");
      CriticalSection cs;
      usbdm_assert((allocatedChannels & channelMask) != 0, "PIT channel already allocated");
      if ((allocatedChannels & channelMask) == 0) {
         setErrorCode(E_NO_RESOURCE);
         return PitChannelNum_None;
      }
      allocatedChannels &= ~channelMask;
      return (PitChannelNum) dmaChannelNum;
   }
#endif // (/DMA/_BasicInfoGuard)

   /**
    * Free PIT channel.
    * Disables the channel.
    *
    * @param pitChannelNum Channel to release
    */
   static void freeChannel(PitChannelNum pitChannelNum) {
      if (pitChannelNum == PitChannelNum_None) {
         return;
      }
      const uint32_t channelMask = (1<<pitChannelNum);
      usbdm_assert(pitChannelNum<NumChannels, "Illegal PIT channel");
      usbdm_assert((allocatedChannels & channelMask) == 0, "Freeing unallocated PIT channel");

      disableChannel(pitChannelNum);
      CriticalSection cs;
      allocatedChannels |= channelMask;
   }

   /**
    * Enable/disable channel interrupts
    *
    * @param[in]  pitChannelNum    Channel being modified
    * @param[in]  pitChannelAction Action to take on event
    */
   static void setChannelAction(PitChannelNum pitChannelNum, PitChannelAction pitChannelAction) {
      pit->CHANNEL[pitChannelNum].TCTRL = pit->CHANNEL[pitChannelNum].TCTRL | pitChannelAction;
   }

protected:
   /** Pointer to hardware */
   static constexpr HardwarePtr<PIT_Type> pit = Info::baseAddress;

public:
   /**
    * Basic enable of PIT
    */
   static void enable() {
      // Enable clock
      Info::enableClock();
      __DMB();
   }

   /**
    *   Disable the PIT (all channels)
    */
   static void disable() {
      pit->MCR = PIT_MCR_MDIS(1);
      Info::disableClock();
   }

   /**
    *  Enable the PIT channel
    *
    *  @param[in]  pitChannelNum   Channel to enable
    */
   static void enableChannel(const PitChannelNum pitChannelNum) {
      pit->CHANNEL[pitChannelNum].TCTRL = pit->CHANNEL[pitChannelNum].TCTRL | PIT_TCTRL_TEN_MASK;
   }

   /**
    *   Disable the PIT channel
    *
    *   @param[in]  pitChannelNum Channel to disable
    */
   static void disableChannel(PitChannelNum pitChannelNum) {

      // Disable timer channel
      pit->CHANNEL[pitChannelNum].TCTRL = pit->CHANNEL[pitChannelNum].TCTRL & ~PIT_TCTRL_TEN_MASK;
   }

   /**
    * Clear channel interrupt flag
    */
   static void clearInterruptFlag(PitChannelNum pitChannelNum)  {
      pit->CHANNEL[pitChannelNum].TFLG = PIT_TFLG_TIF_MASK;
   }

   /**
    *  Configure the PIT channel
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
    *  @param[in]  pitChannelAction  Action to take on timer event
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannel(
         PitChannelNum     pitChannelNum,
         Ticks             tickInterval,
         PitChannelAction  pitChannelAction=PitChannelAction_None) {

      usbdm_assert((unsigned)tickInterval>0, "Interval too short");

      pit->CHANNEL[pitChannelNum].TCTRL = 0;
      pit->CHANNEL[pitChannelNum].LDVAL = (unsigned)tickInterval-1;
      pit->CHANNEL[pitChannelNum].TFLG  = PIT_TFLG_TIF_MASK;
      pit->CHANNEL[pitChannelNum].TCTRL = pitChannelAction|PIT_TCTRL_TEN(1);
   }

#if false // /PIT/secondsSupport
   /**
    *  Configure the PIT channel in seconds
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  intervalInSeconds Interval in seconds
    *  @param[in]  pitChannelAction  Action to take on timer event
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannel(
         PitChannelNum     pitChannelNum,
         Seconds           intervalInSeconds,
         PitChannelAction  pitChannelAction=PitChannelAction_None) {

      configureChannel(pitChannelNum, Info::convertSecondsToTicks(intervalInSeconds), pitChannelAction);
   }
#endif // /PIT/secondsSupport

   /**
    *  Configure the PIT channel in milliseconds
    *
    *  @param[in]  pitChannelNum    Channel to configure
    *  @param[in]  milliseconds     Interval in seconds
    *  @param[in]  pitChannelAction Action to take on timer event
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannelInMilliseconds(
         PitChannelNum     pitChannelNum,
         unsigned          milliseconds,
         PitChannelAction  pitChannelAction=PitChannelAction_None) {

      configureChannel(pitChannelNum, convertMillisecondsToTicks(milliseconds), pitChannelAction);
   }

   /**
    *  Configure the PIT channel in microseconds
    *
    *  @param[in]  pitChannelNum    Channel to configure
    *  @param[in]  microseconds     Interval in microseconds
    *  @param[in]  pitChannelAction Action to take on timer event
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannelInMicroseconds(
         PitChannelNum     pitChannelNum,
         unsigned          microseconds,
         PitChannelAction     pitChannelAction=PitChannelAction_None) {

      configureChannel(pitChannelNum, convertMicrosecondsToTicks(microseconds), pitChannelAction);
   }

   /**
    * Convert time in ticks to time in microseconds
    *
    * @param[in] ticks Time interval in ticks
    *
    * @return Time interval in microseconds
    */
   static unsigned convertTicksToMilliseconds(Ticks ticks) {
      return (unsigned)((1000UL * (unsigned)ticks)/Info::getClockFrequency());
   }

   /**
    * Convert time in ticks to time in milliseconds
    *
    * @param[in] ticks Time interval in ticks
    *
    * @return Time interval in milliseconds
    */
   static unsigned convertTicksToMicroseconds(Ticks ticks) {
      return (unsigned)((1000000UL * (unsigned)ticks)/Info::getClockFrequency());
   }

   /**
    * Converts time in milliseconds to time in ticks
    *
    * @param[in] milliseconds Time interval in milliseconds
    *
    * @return Time interval in ticks
    *
    * @note Will set error code if calculated value is unsuitable
    */
   static Ticks convertMillisecondsToTicks(unsigned milliseconds) {
      unsigned long intervalInTicks = milliseconds*(Info::getClockFrequency()/1000);
      usbdm_assert(intervalInTicks <= 0xFFFFFFFFUL, "Interval is too long");
      usbdm_assert(intervalInTicks > 0, "Interval is too short");
      if (intervalInTicks > 0xFFFFFFFFUL) {
         setErrorCode(E_TOO_LARGE);
      }
      if (intervalInTicks <= 0) {
         setErrorCode(E_TOO_SMALL);
      }
      return Ticks((unsigned)intervalInTicks);
   }

   /**
    * Converts time in microseconds to time in ticks
    *
    * @param[in] microseconds Time interval in microseconds
    *
    * @return Time interval in ticks
    *
    * @note Will set error code if calculated value is unsuitable
    */
   static Ticks convertMicrosecondsToTicks(unsigned microseconds) {
      unsigned long intervalInTicks = microseconds*(Info::getClockFrequency()/1000000);
      usbdm_assert(intervalInTicks <= 0xFFFFFFFFUL, "Interval is too long");
      usbdm_assert(intervalInTicks > 0, "Interval is too short");
      if (intervalInTicks > 0xFFFFFFFFUL) {
         setErrorCode(E_TOO_LARGE);
      }
      if (intervalInTicks <= 0) {
         setErrorCode(E_TOO_SMALL);
      }
      return Ticks((unsigned)intervalInTicks);
   }

   /**
    * Set period in Ticks
    *
    * @param[in]  pitChannelNum Channel being modified
    * @param[in]  ticks         Interval in ticks
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriod(PitChannelNum pitChannelNum, Ticks ticks) {
      pit->CHANNEL[pitChannelNum].LDVAL = (unsigned)ticks-1;
   }

   /**
    * Set period in microseconds
    *
    * @param[in]  pitChannelNum Channel being modified
    * @param[in]  microseconds  Interval in microseconds
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriodInMicroseconds(PitChannelNum pitChannelNum, uint32_t microseconds) {
      setPeriod(pitChannelNum, convertMicrosecondsToTicks(microseconds));
   }

   /**
    * Set period in milliseconds
    *
    * @param[in]  pitChannelNum Channel being modified
    * @param[in]  milliseconds  Interval in milliseconds
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriodInMilliseconds(PitChannelNum pitChannelNum, uint32_t milliseconds) {
      setPeriod(pitChannelNum, convertMillisecondsToTicks(milliseconds));
   }

#if false // /PIT/secondsSupport
   /**
    * Set period in seconds
    *
    * @param[in]  pitChannelNum Channel being modified
    * @param[in]  interval Interval in seconds
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriod(PitChannelNum pitChannelNum, Seconds interval) {
      setPeriod(pitChannelNum, Ticks((float)interval*Info::getClockFrequency()));
   }
#endif // /PIT/secondsSupport

   /**
    *  Use a PIT channel to implement a busy-wait delay
    *
    *  @param[in]  pitChannelNum   Channel to use
    *  @param[in]  interval        Interval to wait in timer ticks (usually bus clock period)
    *
    *  @note Function doesn't return until interval has expired
    */
   static void delay(PitChannelNum pitChannelNum, Ticks interval) {
      configureChannel(pitChannelNum, interval);
      while (pit->CHANNEL[pitChannelNum].TFLG == 0) {
         __NOP();
      }
      disableChannel(pitChannelNum);
   }

#if false // /PIT/secondsSupport
   /**
    *  Use a PIT channel to implement a busy-wait delay
    *
    *  @param[in]  pitChannelNum   Channel to use
    *  @param[in]  interval        Interval to wait in seconds
    *
    *  @note Function doesn't return until interval has expired
    */
   static void delay(PitChannelNum pitChannelNum, Seconds interval) {
      configureChannel(pitChannelNum, interval);
      while (pit->CHANNEL[pitChannelNum].TFLG == 0) {
         __NOP();
      }
      disableChannel(pitChannelNum);
   }
#endif // /PIT/secondsSupport

#if true // /PIT/_CommonInfoIrqGuard

   using CallbackFunction = typename Info::CallbackFunction;
   
   /**
    * Set interrupt callback function.
    *
    *  @param pitChannelNum   Channel to configure
    *  @param callback        Callback function to execute on interrupt
    *                         Use nullptr to remove callback.
    */
   static void setCallback(PitChannelNum pitChannelNum, CallbackFunction callback) {
      Info::setCallback(IrqNum(pitChannelNum), callback);
   }

   /**
    * Set interrupt callback function.
    *
    * @param pitIrqNum Used to identify peripheral interrupt
    * @param callback  Callback function to execute on interrupt
    *                  Use nullptr to remove callback.
    */
   static void setCallback(IrqNum pitIrqNum, CallbackFunction callback) {
      Info::setCallback(pitIrqNum, callback);
   }

   /**
    * Set one-shot timer callback in microseconds
    *
    *  @note It is necessary to enable NVIC interrupts beforehand
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  callback          Callback function to be executed on timeout
    *  @param[in]  microseconds      Interval in milliseconds
    */
   static void oneShotInMicroseconds(PitChannelNum pitChannelNum, CallbackFunction callback, uint32_t microseconds) {
      Info::setCallback(IrqNum(pitChannelNum), callback);
      configureChannelInMicroseconds(pitChannelNum, microseconds, PitChannelAction_Interrupt);
      CriticalSection cs;
      Info::clearOnEvent |= (1<<pitChannelNum);
   }

   /**
    * Set one-shot timer callback in milliseconds
    *
    *  @note It is necessary to enable NVIC interrupts beforehand
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  callback          Callback function to be executed on timeout
    *  @param[in]  milliseconds      Interval in milliseconds
    */
   static void oneShotInMilliseconds(PitChannelNum pitChannelNum, CallbackFunction callback, uint32_t milliseconds) {
      Info::setCallback(IrqNum(pitChannelNum), callback);
      configureChannelInMilliseconds(pitChannelNum, milliseconds, PitChannelAction_Interrupt);
      CriticalSection cs;
      Info::clearOnEvent |= (1<<pitChannelNum);
   }

   /**
    * Set one-shot timer callback in Ticks
    *
    *  @note It is necessary to enable NVIC interrupts beforehand
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  callback          Callback function to be executed on timeout
    *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
    */
   static void oneShot(PitChannelNum pitChannelNum, CallbackFunction callback, Ticks tickInterval) {
      Info::setCallback(IrqNum(pitChannelNum), callback);
      CriticalSection cs;
      configureChannel(pitChannelNum, tickInterval, PitChannelAction_Interrupt);
      Info::clearOnEvent |= (1<<pitChannelNum);
   }
   
#if false // /PIT/secondsSupport
   /**
    * Set one-shot timer callback.
    *
    *  @note It is necessary to enable NVIC interrupts beforehand
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  callback          Callback function to be executed on timeout
    *  @param[in]  interval          Interval in seconds until callback is executed
    */
   static void oneShot(PitChannelNum pitChannelNum, CallbackFunction callback, Seconds interval) {
      oneShot(pitChannelNum, callback, Info::convertSecondsToTicks(interval));
   }
#endif // /PIT/secondsSupport
#endif // /PIT/_CommonInfoIrqGuard

   /**
    * Class representing a PIT channel.
    * This version may be instantiated and passed as a reference
    */
   class PitChannel {

   public:

      // PIT Owning this channel
      using Owner = PitBase_T<Info>;
      using ChannelInit = typename Info::ChannelInit;

      constexpr PitChannel(PitChannelNum channel) : chan(channel) {}

      /** Timer channel number */
      const PitChannelNum chan;

      /**
       * Configure PIT channel from values specified in init.
       * The PIT shared hardware will be default initialised if necessary
       *
       * @param init Class containing initialisation values (channel number is ignored)
       */
       void configure(const ChannelInit &init) const {
         PitBase_T<Info>::configure(chan, init);
      }
   
      /**
       *  Enables and configures the PIT if not already done.
       *  This also disables all channel interrupts and channel reservations if newly configured.
       */
       void defaultConfigureIfNeeded() const {
         PitBase_T<Info>::defaultConfigureIfNeeded();
      }
   
      /**
       *  Configure the PIT channel
       *
       *  @param[in]  interval          Interval in timer ticks (usually bus clock)
       *  @param[in]  pitChannelAction     Whether to enable interrupts
       *
       *  @note The timer channel is disabled before configuring so that period changes
       *        have immediate effect.
       */
       void configure(
            Ticks             interval,
            PitChannelAction  pitChannelAction=PitChannelAction_None) const {
   
         PitBase_T<Info>::configureChannel(chan, interval, pitChannelAction);
      }
   
      /**
       * Clear channel interrupt flag
       */
       void clearInterruptFlag() const {
         PitBase_T<Info>::clearInterruptFlag(chan);
      }
   
#if false // /PIT/secondsSupport
      /**
       *  Configure the PIT channel
       *
       *  @param[in]  interval          Interval in seconds
       *  @param[in]  pitChannelAction     Whether to enable interrupts
       *
       *  @note The timer channel is disabled before configuring so that period changes
       *        have immediate effect.
       */
       void configure(
            Seconds           interval,
            PitChannelAction  pitChannelAction=PitChannelAction_None) const {
   
         PitBase_T<Info>::configureChannel(chan, interval, pitChannelAction);
      }
#endif
   
      /**
       *   Enable the PIT channel
       */
       void enable() const {
         PitBase_T<Info>::enableChannel(chan);
      }
   
      /**
       *   Disable the PIT channel
       */
       void disable() const {
         PitBase_T<Info>::disableChannel(chan);
      }
   
      /**
       * Set period in ticks
       *
       * @param[in]  interval Interval in ticks
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
       void setPeriod(Ticks interval) const {
         PitBase_T<Info>::setPeriod(chan, interval);
      }
   
      /**
       * Read channel counter
       *
       * @return Current down-counter value
       */
       uint32_t readCounter() const {
         return pit->CHANNEL[chan].CVAL;
      }
   
#if false // /PIT/secondsSupport
      /**
       * Set period in seconds
       *
       * @param[in]  interval Interval in seconds
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
       void setPeriod(Seconds interval) const {
         PitBase_T<Info>::setPeriod(chan, interval);
      }
#endif
      /**
       * Set period in microseconds
       *
       * @param[in]  microseconds Interval in microseconds
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
       void setPeriodInMicroseconds(uint32_t microseconds) const {
         uint64_t interval = ((uint64_t)microseconds*Info::getClockFrequency())/1000000;
         usbdm_assert(interval<0xFFFFFFFFUL,"Interval too long");
         PitBase_T<Info>::setPeriod(chan, Ticks(uint32_t(interval)));
      }
   
      /**
       *  Use a PIT channel to implement a busy-wait delay
       *
       *  @param[in]  interval  Interval to wait in timer ticks (usually bus clock period)
       *
       *  @note Function does not return until interval has expired
       */
       void delay(Ticks interval) const {
         PitBase_T<Info>::delay(chan, interval);
      }
   
#if false // /PIT/secondsSupport
      /**
       *  Use a PIT channel to implement a busy-wait delay
       *
       *  @param[in]  interval  Interval to wait in seconds
       *
       *  @note Function does not return until interval has expired
       */
       void delay(Seconds interval) const {
         PitBase_T<Info>::delay(chan, interval);
      }
#endif
   
      /**
       * Set action to take on event
       *
       * @param[in]  pitChannelAction Action to take on event
       */
       void setChannelAction(PitChannelAction pitChannelAction) const {
         PitBase_T<Info>::setChannelAction(chan, pitChannelAction);
      }
   
      /**
       * Enable interrupts in NVIC
       */
       void enableNvicInterrupts() const {
         Info::enableNvicInterrupts(IrqNum(chan));
      }
   
      /**
       * Enable and set priority of interrupts in NVIC
       * Any pending NVIC interrupts are first cleared.
       *
       * @param[in]  nvicPriority   Interrupt priority
       */
       void enableNvicInterrupts(NvicPriority nvicPriority) const {
         Info::enableNvicInterrupts(IrqNum(chan), nvicPriority);
      }
   
      /**
       * Disable interrupts in NVIC
       */
       void disableNvicInterrupts() const {
         Info::disableNvicInterrupts(IrqNum(chan));
      }
   
      /**
       * Set one-shot timer callback
       *
       *  @note It is necessary to enable NVIC interrupts beforehand
       *
       *  @param[in]  callback          Callback function to be executed on timeout.
       *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
       */
       void oneShot(CallbackFunction callback, Ticks tickInterval) const {
         PitBase_T<Info>::oneShot(chan, callback, tickInterval);
      }
   
#if false // /PIT/secondsSupport
      /**
       * Set one-shot timer callback.
       *
       *  @note It is necessary to enable NVIC interrupts beforehand
       *
       *  @param[in]  callback          Callback function to be executed on timeout.
       *  @param[in]  interval          Interval in seconds until callback is executed
       */
       void  oneShot(CallbackFunction callback, Seconds interval) const {
         PitBase_T<Info>::oneShot(chan, callback, interval);
      }
#endif
   
      /**
       * Set one-shot timer callback in microseconds
       *
       *  @note It is necessary to enable NVIC interrupts beforehand
       *
       *  @param[in]  callback          Callback function to be executed on timeout.
       *  @param[in]  microseconds      Interval in milliseconds
       */
       void oneShotInMicroseconds(CallbackFunction callback, uint32_t microseconds) const {
         PitBase_T<Info>::oneShotInMicroseconds(chan, callback, microseconds);
      }
   
      /**
       * Set one-shot timer callback in milliseconds
       *
       *  @note It is necessary to enable NVIC interrupts beforehand
       *
       *  @param[in]  callback          Callback function to be executed on timeout.
       *  @param[in]  milliseconds      Interval in milliseconds
       */
       void oneShotInMilliseconds(CallbackFunction callback, uint32_t milliseconds) const {
         PitBase_T<Info>::oneShotInMilliseconds(chan, callback, milliseconds);
      }
   
      /**
       * Set interrupt callback function.
       *
       * @param pitIrqNum Used to identify peripheral interrupt
       * @param callback  Callback function to execute on interrupt
       *                  Use nullptr to remove callback.
       */
       void setCallback(CallbackFunction callback) const {
         PitBase_T<Info>::setCallback(chan, callback);
      }
   

   };

   /**
    * Class representing a PIT channel
    * This version is a template and may not be instantiated.
    * It is a type only with static member methodes.
    *
    * @tparam channel Timer channel number
    */
   template <int channel>
   class Channel : public PitChannel, private Info {

   private:
      Channel(const Channel&) = delete;
      Channel(Channel&&) = delete;

   public:
      // Allow access to channel initialisation type
      using typename Info::ChannelInit;

      constexpr Channel() : PitChannel(CHANNEL) {};

      /** Timer channel number */
      static constexpr PitChannelNum CHANNEL = (PitChannelNum)channel;
      
      /**
       * Configure PIT channel from values specified in init.
       * The PIT shared hardware will be default initialised if necessary
       *
       * @param init Class containing initialisation values (channel number is ignored)
       */
      static void configure(const ChannelInit &init)  {
         PitBase_T<Info>::configure(CHANNEL, init);
      }
   
      /**
       *  Enables and configures the PIT if not already done.
       *  This also disables all channel interrupts and channel reservations if newly configured.
       */
      static void defaultConfigureIfNeeded()  {
         PitBase_T<Info>::defaultConfigureIfNeeded();
      }
   
      /**
       *  Configure the PIT channel
       *
       *  @param[in]  interval          Interval in timer ticks (usually bus clock)
       *  @param[in]  pitChannelAction     Whether to enable interrupts
       *
       *  @note The timer channel is disabled before configuring so that period changes
       *        have immediate effect.
       */
      static void configure(
            Ticks             interval,
            PitChannelAction  pitChannelAction=PitChannelAction_None)  {
   
         PitBase_T<Info>::configureChannel(CHANNEL, interval, pitChannelAction);
      }
   
      /**
       * Clear channel interrupt flag
       */
      static void clearInterruptFlag()  {
         PitBase_T<Info>::clearInterruptFlag(CHANNEL);
      }
   
#if false // /PIT/secondsSupport
      /**
       *  Configure the PIT channel
       *
       *  @param[in]  interval          Interval in seconds
       *  @param[in]  pitChannelAction     Whether to enable interrupts
       *
       *  @note The timer channel is disabled before configuring so that period changes
       *        have immediate effect.
       */
      static void configure(
            Seconds           interval,
            PitChannelAction  pitChannelAction=PitChannelAction_None)  {
   
         PitBase_T<Info>::configureChannel(CHANNEL, interval, pitChannelAction);
      }
#endif
   
      /**
       *   Enable the PIT channel
       */
      static void enable()  {
         PitBase_T<Info>::enableChannel(CHANNEL);
      }
   
      /**
       *   Disable the PIT channel
       */
      static void disable()  {
         PitBase_T<Info>::disableChannel(CHANNEL);
      }
   
      /**
       * Set period in ticks
       *
       * @param[in]  interval Interval in ticks
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
      static void setPeriod(Ticks interval)  {
         PitBase_T<Info>::setPeriod(CHANNEL, interval);
      }
   
      /**
       * Read channel counter
       *
       * @return Current down-counter value
       */
      static uint32_t readCounter()  {
         return pit->CHANNEL[CHANNEL].CVAL;
      }
   
#if false // /PIT/secondsSupport
      /**
       * Set period in seconds
       *
       * @param[in]  interval Interval in seconds
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
      static void setPeriod(Seconds interval)  {
         PitBase_T<Info>::setPeriod(CHANNEL, interval);
      }
#endif
      /**
       * Set period in microseconds
       *
       * @param[in]  microseconds Interval in microseconds
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
      static void setPeriodInMicroseconds(uint32_t microseconds)  {
         uint64_t interval = ((uint64_t)microseconds*Info::getClockFrequency())/1000000;
         usbdm_assert(interval<0xFFFFFFFFUL,"Interval too long");
         PitBase_T<Info>::setPeriod(CHANNEL, Ticks(uint32_t(interval)));
      }
   
      /**
       *  Use a PIT channel to implement a busy-wait delay
       *
       *  @param[in]  interval  Interval to wait in timer ticks (usually bus clock period)
       *
       *  @note Function does not return until interval has expired
       */
      static void delay(Ticks interval)  {
         PitBase_T<Info>::delay(CHANNEL, interval);
      }
   
#if false // /PIT/secondsSupport
      /**
       *  Use a PIT channel to implement a busy-wait delay
       *
       *  @param[in]  interval  Interval to wait in seconds
       *
       *  @note Function does not return until interval has expired
       */
      static void delay(Seconds interval)  {
         PitBase_T<Info>::delay(CHANNEL, interval);
      }
#endif
   
      /**
       * Set action to take on event
       *
       * @param[in]  pitChannelAction Action to take on event
       */
      static void setChannelAction(PitChannelAction pitChannelAction)  {
         PitBase_T<Info>::setChannelAction(CHANNEL, pitChannelAction);
      }
   
      /**
       * Enable interrupts in NVIC
       */
      static void enableNvicInterrupts()  {
         Info::enableNvicInterrupts(IrqNum(CHANNEL));
      }
   
      /**
       * Enable and set priority of interrupts in NVIC
       * Any pending NVIC interrupts are first cleared.
       *
       * @param[in]  nvicPriority   Interrupt priority
       */
      static void enableNvicInterrupts(NvicPriority nvicPriority)  {
         Info::enableNvicInterrupts(IrqNum(CHANNEL), nvicPriority);
      }
   
      /**
       * Disable interrupts in NVIC
       */
      static void disableNvicInterrupts()  {
         Info::disableNvicInterrupts(IrqNum(CHANNEL));
      }
   
      /**
       * Set one-shot timer callback
       *
       *  @note It is necessary to enable NVIC interrupts beforehand
       *
       *  @param[in]  callback          Callback function to be executed on timeout.
       *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
       */
      static void oneShot(CallbackFunction callback, Ticks tickInterval)  {
         PitBase_T<Info>::oneShot(CHANNEL, callback, tickInterval);
      }
   
#if false // /PIT/secondsSupport
      /**
       * Set one-shot timer callback.
       *
       *  @note It is necessary to enable NVIC interrupts beforehand
       *
       *  @param[in]  callback          Callback function to be executed on timeout.
       *  @param[in]  interval          Interval in seconds until callback is executed
       */
      static void  oneShot(CallbackFunction callback, Seconds interval)  {
         PitBase_T<Info>::oneShot(CHANNEL, callback, interval);
      }
#endif
   
      /**
       * Set one-shot timer callback in microseconds
       *
       *  @note It is necessary to enable NVIC interrupts beforehand
       *
       *  @param[in]  callback          Callback function to be executed on timeout.
       *  @param[in]  microseconds      Interval in milliseconds
       */
      static void oneShotInMicroseconds(CallbackFunction callback, uint32_t microseconds)  {
         PitBase_T<Info>::oneShotInMicroseconds(CHANNEL, callback, microseconds);
      }
   
      /**
       * Set one-shot timer callback in milliseconds
       *
       *  @note It is necessary to enable NVIC interrupts beforehand
       *
       *  @param[in]  callback          Callback function to be executed on timeout.
       *  @param[in]  milliseconds      Interval in milliseconds
       */
      static void oneShotInMilliseconds(CallbackFunction callback, uint32_t milliseconds)  {
         PitBase_T<Info>::oneShotInMilliseconds(CHANNEL, callback, milliseconds);
      }
   
      /**
       * Set interrupt callback function.
       *
       * @param pitIrqNum Used to identify peripheral interrupt
       * @param callback  Callback function to execute on interrupt
       *                  Use nullptr to remove callback.
       */
      static void setCallback(CallbackFunction callback)  {
         PitBase_T<Info>::setCallback(CHANNEL, callback);
      }
   

   };
   
// /PIT/InitMethod Not found
}; // class PitBase_T

/**
* Class representing PIT
*/
class Pit : public PitBase_T<PitInfo> {};

   /**
    * @brief class representing a PIT channel
    */
   using PitChannel = Pit::PitChannel;
   
/**
* MACRO defining the start of a interrupt handler for a PIT channel
* This will override the handler incorporated within the PIT class.
*
* @param channel Channel being used.
*
* @example
* PIT_CHANNEL0_HANDLER() {
*    console.writeln("PIT Channel 0 Handler");
*    // Clear interrupt flag
*    pit->CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK;
* }
*/

#define PIT_CHANNEL0_HANDLER() template<>template<> void Pit::Channel<0>::irqHandler()
#define PIT_CHANNEL1_HANDLER() template<>template<> void Pit::Channel<1>::irqHandler()
#define PIT_CHANNEL2_HANDLER() template<>template<> void Pit::Channel<2>::irqHandler()
#define PIT_CHANNEL3_HANDLER() template<>template<> void Pit::Channel<3>::irqHandler()

/**
 * @}
 */

} // End namespace USBDM

#endif // /PIT/_BasicInfoGuard

#endif /* INCLUDE_USBDM_PIT_H_ */
