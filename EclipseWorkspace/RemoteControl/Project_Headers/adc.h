/**
 * @file     adc.h (180.ARM_Peripherals/Project_Headers/adc.h)
 * @brief    ADC routines
 */

#ifndef HEADER_ADC_H
#define HEADER_ADC_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"
#include "gpio.h"

#if true // /ADC/_BasicInfoGuard

namespace USBDM {
   // Forward declaration
   enum class AdcChannelNum : uint8_t;
}; // namespace USBDM

// No handler defined for ADC0

namespace USBDM {

/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
/**
 * Peripheral information for ADC, Analogue Input.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */

   /**
    * ADC Channel number
    * (adc_sc1_channel)
    *
    * Selects an ADC channel
    */
   enum class AdcChannelNum : uint8_t {
      AdcChannelNum_Se0         = 0,   ///< Channel SE0
      AdcChannelNum_Se1         = 1,   ///< Channel SE1
      AdcChannelNum_Se2         = 2,   ///< Channel SE2
      AdcChannelNum_Se3         = 3,   ///< Channel SE3
      AdcChannelNum_AFirst      = 4,   ///< AFirst
      AdcChannelNum_Se4a        = 4,   ///< Channel SE4a
      AdcChannelNum_Se5a        = 5,   ///< Channel SE5a
      AdcChannelNum_Se6a        = 6,   ///< Channel SE6a
      AdcChannelNum_Se7a        = 7,   ///< Channel SE7a
      AdcChannelNum_ALast       = 7,   ///< ALast
      AdcChannelNum_Se8         = 8,   ///< Channel SE8
      AdcChannelNum_Se9         = 9,   ///< Channel SE9
      AdcChannelNum_Se10        = 10,  ///< Channel SE10
      AdcChannelNum_Se11        = 11,  ///< Channel SE11
      AdcChannelNum_Se12        = 12,  ///< Channel SE12
      AdcChannelNum_Se13        = 13,  ///< Channel SE13
      AdcChannelNum_Se14        = 14,  ///< Channel SE14
      AdcChannelNum_Se15        = 15,  ///< Channel SE15
      AdcChannelNum_Se16        = 16,  ///< Channel SE16
      AdcChannelNum_Se17        = 17,  ///< Channel SE17
      AdcChannelNum_Se18        = 18,  ///< Channel SE18
      AdcChannelNum_Se19        = 19,  ///< Channel SE19
      AdcChannelNum_Se20        = 20,  ///< Channel SE20
      AdcChannelNum_Se21        = 21,  ///< Channel SE21
      AdcChannelNum_Se22        = 22,  ///< Channel SE22
      AdcChannelNum_Se23        = 23,  ///< Channel SE23
      AdcChannelNum_Se24        = 24,  ///< Channel SE24
      AdcChannelNum_Se25        = 25,  ///< Channel SE25
      AdcChannelNum_Se26        = 26,  ///< Channel SE26
      AdcChannelNum_Se27        = 27,  ///< Channel SE27
      AdcChannelNum_Se28        = 28,  ///< Channel SE28
      AdcChannelNum_Se29        = 29,  ///< Channel SE29
      AdcChannelNum_Se30        = 30,  ///< Channel SE30
      AdcChannelNum_Disabled    = 31,  ///< Disabled
      AdcChannelNum_DiffFirst   = 32,  ///< DiffFirst
      AdcChannelNum_Diff0       = 32,  ///< Diff Channel 0
      AdcChannelNum_Diff1       = 33,  ///< Diff Channel 1
      AdcChannelNum_Diff2       = 34,  ///< Diff Channel 2
      AdcChannelNum_Diff3       = 35,  ///< Diff Channel 3
      AdcChannelNum_DiffLast    = 35,  ///< DiffLast
      AdcChannelNum_BFirst      = 36,  ///< BFirst
      AdcChannelNum_Se4b        = 36,  ///< Channel SE4b
      AdcChannelNum_Se5b        = 37,  ///< Channel SE5b
      AdcChannelNum_Se6b        = 38,  ///< Channel SE6b
      AdcChannelNum_Se7b        = 39,  ///< Channel SE7b
      AdcChannelNum_BLast       = 39,  ///< BLast
   };

   /**
    * ADC0 Channel number
    * (adc0_sc1_channel)
    *
    * Selects an ADC0 channel
    */
   inline constexpr AdcChannelNum Adc0ChannelNum_Se0              = AdcChannelNum::AdcChannelNum_Se0; ///< ADC0_SE0 [ADC0_DP0(p7)]
   inline constexpr AdcChannelNum Adc0ChannelNum_Adc0_dp0         = AdcChannelNum::AdcChannelNum_Se0; ///< Pin ADC0_DP0
   inline constexpr AdcChannelNum Adc0ChannelNum_Se3              = AdcChannelNum::AdcChannelNum_Se3; ///< ADC0_SE3 [ADC0_DP3]
   inline constexpr AdcChannelNum Adc0ChannelNum_Adc0_dp3         = AdcChannelNum::AdcChannelNum_Se3; ///< Pin ADC0_DP3
   inline constexpr AdcChannelNum Adc0ChannelNum_Se8              = AdcChannelNum::AdcChannelNum_Se8; ///< ADC0_SE8 [-]
   inline constexpr AdcChannelNum Adc0ChannelNum_Se9              = AdcChannelNum::AdcChannelNum_Se9; ///< ADC0_SE9 [-]
   inline constexpr AdcChannelNum Adc0ChannelNum_Se12             = AdcChannelNum::AdcChannelNum_Se12; ///< ADC0_SE12 [-]
   inline constexpr AdcChannelNum Adc0ChannelNum_Se13             = AdcChannelNum::AdcChannelNum_Se13; ///< Battery Level [PTB3(p30)]
   inline constexpr AdcChannelNum Adc0ChannelNum_BatteryLevel     = AdcChannelNum::AdcChannelNum_Se13; ///< Battery Level
   inline constexpr AdcChannelNum Adc0ChannelNum_Ptb3             = AdcChannelNum::AdcChannelNum_Se13; ///< Pin PTB3
   inline constexpr AdcChannelNum Adc0ChannelNum_Se14             = AdcChannelNum::AdcChannelNum_Se14; ///< ADC0_SE14 [-]
   inline constexpr AdcChannelNum Adc0ChannelNum_Se15             = AdcChannelNum::AdcChannelNum_Se15; ///< ADC0_SE15 [-]
   inline constexpr AdcChannelNum Adc0ChannelNum_Se19             = AdcChannelNum::AdcChannelNum_Se19; ///< ADC0_SE19 [ADC0_DM0(p8)]
   inline constexpr AdcChannelNum Adc0ChannelNum_Adc0_dm0         = AdcChannelNum::AdcChannelNum_Se19; ///< Pin ADC0_DM0
   inline constexpr AdcChannelNum Adc0ChannelNum_Se21             = AdcChannelNum::AdcChannelNum_Se21; ///< ADC0_SE21 [ADC0_DM3]
   inline constexpr AdcChannelNum Adc0ChannelNum_Adc0_dm3         = AdcChannelNum::AdcChannelNum_Se21; ///< Pin ADC0_DM3
   inline constexpr AdcChannelNum Adc0ChannelNum_Se23             = AdcChannelNum::AdcChannelNum_Se23; ///< ADC0_SE23 [ADC0_SE23]
   inline constexpr AdcChannelNum Adc0ChannelNum_Adc0_se23        = AdcChannelNum::AdcChannelNum_Se23; ///< Pin ADC0_SE23
   inline constexpr AdcChannelNum Adc0ChannelNum_Se26             = AdcChannelNum::AdcChannelNum_Se26; ///< ADC0_SE26 [TEMP_SENSOR(Internal)]
   inline constexpr AdcChannelNum Adc0ChannelNum_Temp_sensor      = AdcChannelNum::AdcChannelNum_Se26; ///< Pin TEMP_SENSOR
   inline constexpr AdcChannelNum Adc0ChannelNum_Se27             = AdcChannelNum::AdcChannelNum_Se27; ///< ADC0_SE27 [BANDGAP(Internal)]
   inline constexpr AdcChannelNum Adc0ChannelNum_Bandgap          = AdcChannelNum::AdcChannelNum_Se27; ///< Pin BANDGAP
   inline constexpr AdcChannelNum Adc0ChannelNum_Se4b             = AdcChannelNum::AdcChannelNum_Se4b; ///< ADC0_SE4b [-]
   inline constexpr AdcChannelNum Adc0ChannelNum_Se5b             = AdcChannelNum::AdcChannelNum_Se5b; ///< ADC0_SE5b [-]
   inline constexpr AdcChannelNum Adc0ChannelNum_Se6b             = AdcChannelNum::AdcChannelNum_Se6b; ///< ADC0_SE6b [-]
   inline constexpr AdcChannelNum Adc0ChannelNum_Se7b             = AdcChannelNum::AdcChannelNum_Se7b; ///< ADC0_SE7b [-]
   inline constexpr AdcChannelNum Adc0ChannelNum_Diff0            = AdcChannelNum::AdcChannelNum_Diff0; ///< ADC0_DP0 [ADC0_DP0(p7)]
   inline constexpr AdcChannelNum Adc0ChannelNum_Diff3            = AdcChannelNum::AdcChannelNum_Diff3; ///< ADC0_DP3 [ADC0_DP3]


   /**
    * Action on conversion completion
    * (adc_sc1_aien)
    *
    * Controls whether an interrupt is triggered at the end of each conversion
    */
   enum AdcAction : uint8_t {
      AdcAction_None        = ADC_SC1_AIEN(0),  ///< None
      AdcAction_Interrupt   = ADC_SC1_AIEN(1),  ///< Interrupt
   };

   /**
    * Conversion Complete Flag
    * (adc_sc1_coco)
    *
    * 
    */
   enum AdcCompleteFlag : uint8_t {
      AdcCompleteFlag_NotComplete   = ADC_SC1_COCO(0),  ///< Not complete
      AdcCompleteFlag_Complete      = ADC_SC1_COCO(1),  ///< Complete
   };

   /**
    * Differential Mode Enable
    * (adc_sc1_diff)
    *
    * Enable differential conversion
    */
   enum AdcDifferential : uint8_t {
      AdcDifferential_SingleEnded    = ADC_SC1_DIFF(0),  ///< Single-ended
      AdcDifferential_Differential   = ADC_SC1_DIFF(1),  ///< Differential
   };

   /**
    * ADC Input Clock
    * (adc_cfg1_adiclk)
    *
    * Clock source for the ADC module
    */
   enum AdcClockSource : uint8_t {
      AdcClockSource_BusClock       = ADC_CFG1_ADICLK(0),  ///< Bus clock
      AdcClockSource_BusClockDiv2   = ADC_CFG1_ADICLK(1),  ///< Bus clock/2
      AdcClockSource_OscerClk       = ADC_CFG1_ADICLK(2),  ///< Alternate clock (OSCERCLK)
      AdcClockSource_Asynch         = ADC_CFG1_ADICLK(3),  ///< Asynchronous clock (ADACK)
   };

   /**
    * Clock Divide Select
    * (adc_cfg1_adiv)
    *
    * Sets the division of the available clock for use by the ADC
    */
   enum AdcClockDivider : uint8_t {
      AdcClockDivider_DivBy1   = ADC_CFG1_ADIV(0),  ///< Divide by 1
      AdcClockDivider_DivBy2   = ADC_CFG1_ADIV(1),  ///< Divide by 2
      AdcClockDivider_DivBy4   = ADC_CFG1_ADIV(2),  ///< Divide by 4
      AdcClockDivider_DivBy8   = ADC_CFG1_ADIV(3),  ///< Divide by 8
   };

   /**
    * ADC Resolution
    * (adc_cfg1_mode)
    *
    * The resolutions available vary with single-ended/differential modes
    * Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff
    */
   enum AdcResolution : uint8_t {
      AdcResolution_8bit_se      = ADC_CFG1_MODE(0),  ///< 8-bit unsigned (single-ended mode)
      AdcResolution_10bit_se     = ADC_CFG1_MODE(2),  ///< 10-bit unsigned (single-ended mode)
      AdcResolution_12bit_se     = ADC_CFG1_MODE(1),  ///< 12-bit unsigned (single-ended mode)
      AdcResolution_16bit_se     = ADC_CFG1_MODE(3),  ///< 16-bit unsigned (single-ended mode)
      AdcResolution_9bit_diff    = ADC_CFG1_MODE(0),  ///< 9-bit signed (differential mode)
      AdcResolution_11bit_diff   = ADC_CFG1_MODE(2),  ///< 11-bit signed (differential mode)
      AdcResolution_13bit_diff   = ADC_CFG1_MODE(1),  ///< 13-bit signed (differential mode)
      AdcResolution_16bit_diff   = ADC_CFG1_MODE(3),  ///< 16-bit signed (differential mode)
   };

   /**
    * Low-Power Configuration
    * (adc_cfg1_adlpc)
    *
    * Controls trade-off between speed and power consumption
    * It also affects the speed of the asynchronous clock
    */
   enum AdcPower : uint8_t {
      AdcPower_Normal   = ADC_CFG1_ADLPC(0),  ///< Normal power configuration
      AdcPower_Low      = ADC_CFG1_ADLPC(1),  ///< Low-power configuration (reduced speed)
   };

   /**
    * High-Speed Configuration
    * (adc_cfg2_adhsc)
    *
    * Configures the ADC for high-speed clock operation
    * This actually extends the number of conversion clock cycles
    * but is offset by allowing a faster input clock
    */
   enum AdcClockRange : uint8_t {
      AdcClockRange_Normal   = ADC_CFG2_ADHSC(0),  ///< Normal conversion sequence selected
      AdcClockRange_High     = ADC_CFG2_ADHSC(1),  ///< High-speed conversion sequence selected
   };

   /**
    * Sample Time Configuration
    * (adc_sample)
    *
    * Selects sample times 
    * Longer sample times allow higher impedance inputs to be accurately sampled or
    * shorter sample times maximizes the conversion speed for lower impedance inputs.
    * Longer sample times can also be used to lower overall power consumption when
    * continuous conversions are enabled.
    */
   enum AdcSample : uint8_t {
      AdcSample_4cycles    = (ADC_CFG1_ADLSMP(0)),                     ///< 4 ADCK total
      AdcSample_6cycles    = (ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(3)),  ///< +2 ADCK cycles; 6 ADCK total
      AdcSample_10cycles   = (ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(2)),  ///< +6 ADCK cycles; 10 ADCK total
      AdcSample_16cycles   = (ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(1)),  ///< +12 ADCK cycles; 16 ADCK total
      AdcSample_24cycles   = (ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(0)),  ///< +20 ADCK cycles; 24 ADCK total
   };

   /**
    * Sample Time Configuration
    * (adc_cfg1_adlsmp)
    *
    * Selects between long and short sample times.
    * Longer sample times allow higher impedance inputs to be accurately sampled or
    * shorter sample times maximizes the conversion speed for lower impedance inputs.
    * Longer sample times can also be used to lower overall power consumption when
    * continuous conversions are enabled.
    */
   enum AdcSampleMode : uint32_t {
      AdcSampleMode_ShortSampleTime   = ADC_CFG1_ADLSMP(0),  ///< Short sample time
      AdcSampleMode_LongSampleTime    = ADC_CFG1_ADLSMP(1),  ///< Long sample time
   };

   /**
    * Long Sample Time Select
    * (adc_cfg2_adlsts)
    *
    * 
    */
   enum AdcSampleLength : uint32_t {
      AdcSampleLength_20ExtraCycles   = ADC_CFG2_ADLSTS(0),  ///< 20 extra cycles
      AdcSampleLength_12ExtraCycles   = ADC_CFG2_ADLSTS(1),  ///< 12 extra cycles
      AdcSampleLength_6ExtraCycles    = ADC_CFG2_ADLSTS(2),  ///< 6 extra cycles
      AdcSampleLength_2ExtraCycles    = ADC_CFG2_ADLSTS(3),  ///< 2 extra cycles
   };

   /**
    * Hardware Average Select
    * (adc_sc3_avg)
    *
    * Determines how many ADC conversions will be averaged
    * by the hardware to create the ADC result
    */
   enum AdcAveraging : uint8_t {
      AdcAveraging_off   = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(0)|ADC_SC3_AVGS(0),  ///< 1 sample
      AdcAveraging_4     = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(0),  ///< 4 samples
      AdcAveraging_8     = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(1),  ///< 8 samples
      AdcAveraging_16    = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(2),  ///< 16 samples
      AdcAveraging_32    = ADC_SC3_CAL(0)|ADC_SC3_CALF(0)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(3),  ///< 32 samples
      AdcAveraging_Cal   = ADC_SC3_CAL(1)|ADC_SC3_CALF(1)|ADC_SC3_AVGE(1)|ADC_SC3_AVGS(3),  ///< 32 samples + clear flag + start calibration
   };

   /**
    * Asynchronous Clock Output Enable
    * (adc_cfg2_adacken)
    *
    * Enables the ADC internal asynchronous clock source irrespective of ADC need.
    * This reduces the initial delay at the start of a sequence of conversions.
    * It also allows use of the ADC internal clock as a clock source for other peripherals
    */
   enum AdcAsyncClock : uint8_t {
      AdcAsyncClock_Disabled   = ADC_CFG2_ADACKEN(0),  ///< Asynchronous clock output disabled
      AdcAsyncClock_Enabled    = ADC_CFG2_ADACKEN(1),  ///< Asynchronous clock output enabled
   };

   /**
    * Voltage Reference Selection
    * (adc_sc2_refsel)
    *
    * Selects the voltage reference source used for conversions
    */
   enum AdcReferenceSel : uint8_t {
      AdcReferenceSel_VrefhAndVrefl   = ADC_SC2_REFSEL(0),  ///< VRefH and VRefl
      AdcReferenceSel_ValthAndValtl   = ADC_SC2_REFSEL(0),  ///< VAltH and VAltl
      AdcReferenceSel_Default         = ADC_SC2_REFSEL(0),  ///< Default
   };

   /**
    * DMA Enable
    * (adc_sc2_dmaen)
    *
    * Enables use of DMA with ADC
    */
   enum AdcDma : uint8_t {
      AdcDma_Disabled   = ADC_SC2_DMAEN(0),  ///< Disabled
      AdcDma_Enabled    = ADC_SC2_DMAEN(1),  ///< Enabled
   };

   /**
    * A/B multiplexor selection
    * (adc_cfg2_muxsel)
    *
    * Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b
    */
   enum AdcMuxsel : uint8_t {
      AdcMuxsel_A   = ADC_CFG2_MUXSEL(0),  ///< The multiplexor selects A channels
      AdcMuxsel_B   = ADC_CFG2_MUXSEL(1),  ///< The multiplexor selects B channels
   };

   /**
    * Single or continuous conversion
    * (adc_sc3_adco)
    *
    * Selects between single and multiple conversions.
    * Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,
    * or following assertion of ADHWT when hardware triggered operation is selected.
    */
   enum AdcOperation : uint8_t {
      AdcOperation_Single       = ADC_SC3_ADCO(0),  ///< Single conversion on each trigger
      AdcOperation_Continuous   = ADC_SC3_ADCO(1),  ///< Continuous conversions after 1st trigger
   };

   /**
    * Start Calibration
    * (adc_sc3_cal)
    *
    * Begins the calibration sequence when set.
    * This field stays set while the calibration is in progress and is cleared when 
    * the calibration sequence is completed.
    * CALF must be checked to determine the result of the calibration sequence.
    * Once started, the calibration routine cannot be interrupted by writes to the ADC
    * registers or the results will be invalid and CALF will set.
    * Setting CAL will abort any current conversion.
    */
   enum AdcCalibrate : uint8_t {
      AdcCalibrate_NoAction   = ADC_SC3_CAL(0),  ///< No Action
      AdcCalibrate_Start      = ADC_SC3_CAL(1),  ///< Starts calibration or indicates calibration in progress
   };

   /**
    * Calibration Failed Flag
    * (adc_sc3_calf)
    *
    * Displays the result of the calibration sequence.
    * The calibration sequence will fail if SC2[ADTRG] = 1,
    * any ADC register is written, or any stop mode is entered
    * before the calibration sequence completes.
    * Writing 1 to CALF clears it.
    */
   enum AdcCalibrateResult : uint8_t {
      AdcCalibrateResult_Completed   = ADC_SC3_CALF(0),  ///< Calibration successfully completed
      AdcCalibrateResult_Failed      = ADC_SC3_CALF(1),  ///< Calibration failed
   };

   /**
    * Compare function
    * (adc_sc2_compare)
    *
    * Enables comparison of ADC result with CV1 and CV2
    */
   enum AdcCompare : uint8_t {
      AdcCompare_Disabled                = ADC_SC2_ACFE(0)|ADC_SC2_ACREN(0)|ADC_SC2_ACFGT(0)|(0),     ///< No comparison done
      AdcCompare_LessThan                = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(0)|ADC_SC2_ACFGT(0)|(0),     ///< ADC value < low
      AdcCompare_GreaterThanOrEqual      = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(0)|ADC_SC2_ACFGT(1)|(0),     ///< ADC value >= low
      AdcCompare_OutsideRangeExclusive   = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(1)|ADC_SC2_ACFGT(0)|(0),     ///< (ADC value < low) or (ADC value > high)
      AdcCompare_OutsideRangeInclusive   = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(1)|ADC_SC2_ACFGT(1)|(0x80),  ///< (ADC value <= low) or (ADC value >= high)
      AdcCompare_InsideRangeExclusive    = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(1)|ADC_SC2_ACFGT(0)|(0x80),  ///< (low < ADC value < high)
      AdcCompare_InsideRangeInclusive    = ADC_SC2_ACFE(1)|ADC_SC2_ACREN(1)|ADC_SC2_ACFGT(1)|(0),     ///< (low <= ADC value <= high)
   };

   /**
    * Conversion Trigger Select
    * (adc_sc2_adtrg)
    *
    * Controls whether conversions are triggered by writes to ADC_SC1 (software)
    * or assertion of ADHWT input (hardware)
    */
   enum AdcTrigger : uint8_t {
      AdcTrigger_Software   = ADC_SC2_ADTRG(0),  ///< Software trigger (write to SC1[0])
      AdcTrigger_Hardware   = ADC_SC2_ADTRG(1),  ///< Hardware trigger (ADHWT source)
   };

   /**
    * Selects the pretrigger
    * (adc_pretrigger)
    *
    * Selects which SC1[x]/R[x] register pair to use
    */
   enum AdcPretrigger : uint8_t {
      AdcPretrigger_0   = (0),  ///< Use pretrigger 0 = SC1[0]/R[0]
      AdcPretrigger_1   = (1),  ///< Use pretrigger 1 = SC1[1]/R[1]
   };

   /**
    * Conversion Status
    * (adc_sc2_adact)
    *
    * Indicates that a conversion or sequence of conversions is in progress.
    * Set when a conversion is initiated and cleared when a conversion is completed or aborted
    */
   enum AdcStatus : uint8_t {
      AdcStatus_Idle   = ADC_SC2_ADACT(0),  ///< Conversion not in progress.
      AdcStatus_Busy   = ADC_SC2_ADACT(1),  ///< Conversion in progress.
   };

   /**
    * Combine two ADC register bit-fields
    * (Just to quieten warnings in C++20)
    *
    * @param adcPower
    * @param adcClockRange
    *
    * @return Combined fields
    */
   constexpr uint8_t  operator|(AdcPower adcPower, AdcClockRange adcClockRange) {
      return uint8_t(adcPower)|uint8_t(adcClockRange);
   }
   
class AdcBasicInfo {

public:

   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   // Channel number used for PGA
   static constexpr uint32_t PGA_CHANNEL = 2;
   
   // Pointer to ADC hardware instance
   volatile ADC_Type * const adc;
   
   /**
    * Constructor
    *
    * @param adc ADC hardware instance
    */
   constexpr AdcBasicInfo(volatile ADC_Type * adc) : adc(adc) {
   }
   
   /**
    * Get ADC Input Clock
    *
    * @param adcClockSource Clock source for the ADC module
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getInputClockFrequency(AdcClockSource adcClockSource) {
   
      switch(adcClockSource) {
         default: return 0;
         case AdcClockSource_BusClock     : return SystemBusClock;            ///< Bus clock
         case AdcClockSource_BusClockDiv2 : return SystemBusClock/2;          ///< Bus clock/2
         case AdcClockSource_OscerClk     : return Osc0Info::getOscerClock(); ///< Alternate clock (OSCERCLK)
         case AdcClockSource_Asynch       : return 5200000;       ///< Asynchronous clock (ADACK)

      }
   }
   
   /**
    * Calculate ADC clock divider (ADC_CFG1_ADIV) and confirm clock source (ADC_CFG1_ADICLK)
    *
    * @param cfg1 ADC CFG1 register value
    * @param cfg2 ADC CFG2 register value
    *
    * @return modified cfg1 value (ADC_CFG1_ADIV|ADC_CFG1_ADICLK fields may be changed)
    */
   static unsigned calculateClockDivider(uint8_t cfg1, uint8_t cfg2) {
   
      AdcClockSource adcClockSource = AdcClockSource(ADC_CFG1_ADICLK_MASK&cfg1);
      AdcClockRange  adcClockRange  = AdcClockRange(ADC_CFG2_ADHSC_MASK&cfg2);
      AdcPower       adcPower       = AdcPower(ADC_CFG1_ADLPC_MASK&cfg1);
   
      // Clear existing fields
      cfg1 &= ~(ADC_CFG1_ADICLK_MASK|ADC_CFG1_ADIV_MASK);
   
      if (adcClockSource == AdcClockSource_Asynch) {
         // Internal clock is always OK with /1
         return cfg1|AdcClockSource_Asynch|AdcClockDivider_DivBy1;
      }
      static constexpr unsigned MinClock =  2000000;
      unsigned maxClock = 0;
      switch(adcPower|adcClockRange) {
         case AdcPower_Low|AdcClockRange_Normal :
         maxClock =  4000000;
         break;
         case AdcPower_Low|AdcClockRange_High :
         maxClock =  6000000; // Guess
         break;
         case AdcPower_Normal|AdcClockRange_Normal :
         maxClock =  8000000;
         break;
         case AdcPower_Normal|AdcClockRange_High :
         maxClock = 12000000;
         break;
      }
      unsigned adiv;
      for(;;) {
         unsigned clockFrequency = getInputClockFrequency(adcClockSource);
         for (adiv=0; adiv<=3; adiv++) {
            if ((clockFrequency <= maxClock) && (clockFrequency >= MinClock)) {
               break;
            }
            clockFrequency /= 2;
         }
#if true
         if ((adiv>3) && (adcClockSource == AdcClockSource_BusClock)) {
            // Automatically switch from  AdcClockSource_Bus -> AdcClockSource_Busdiv2
            adcClockSource = AdcClockSource_BusClockDiv2;
            continue;
         }
#endif
         break;
      }
      usbdm_assert(adiv<4, "Unable to find suitable ADC clock");
      return cfg1|adcClockSource|ADC_CFG1_ADIV(adiv);
   }
   
   /**
    * Get ADC maximum conversion value for an single-ended range
    *
    * @param adcResolution
    *
    * @return range e.g. AdcResolution_8bit_se => (2^8)-1
    */
   static constexpr int getSingleEndedMaximum(AdcResolution adcResolution) {
      switch(adcResolution) {
         case AdcResolution_8bit_se:  return (1<<8)-1;
         case AdcResolution_10bit_se: return (1<<10)-1;
         case AdcResolution_12bit_se: return (1<<12)-1;
         case AdcResolution_16bit_se: return (1<<16)-1;
         default:                     return 0;
      }
   }

   /**
    * Get ADC maximum conversion value for an differential range
    *
    * @param adcResolution
    *
    * @return range e.g. AdcResolution_9bit_diff => (2^8)-1
    */
   static constexpr int getDifferentialMaximum(AdcResolution adcResolution) {
      switch(adcResolution) {
         case AdcResolution_9bit_diff:   return (1<<8)-1;
         case AdcResolution_11bit_diff:  return (1<<10)-1;
         case AdcResolution_13bit_diff:  return (1<<12)-1;
         case AdcResolution_16bit_diff:  return (1<<15)-1;
         default:                        return 0;
      }
   }
   /**
    * Map ADC Channel number to physical channel index
    *
    * @param adcChannelNum Channel number (index into Info table)
    *
    * @return  Physical channel number i.e. hardware value
    */
   static constexpr int mapChannelNumToPhysicalChannelNum(AdcChannelNum adcChannelNum) {
   
#if true // adc_sc1_diff_present
      if (adcChannelNum<=AdcChannelNum::AdcChannelNum_DiffLast) {
         // channels SE0-SE4,SE4a-SE7a,SE8-SE31,DIFF0-DIFF4
         return int(adcChannelNum);
      }
#else
      if (adcChannelNum<=AdcChannelNum::AdcChannelNum_Disabled) {
         // channels SE0-SE4,SE4a-SE7a,SE8-SE31
         return int(adcChannelNum);
      }
#endif
      if (adcChannelNum<=AdcChannelNum::AdcChannelNum_BLast) {
         // channels SE4b-SE7b
         return int(adcChannelNum)&ADC_SC1_ADCH_MASK;
      }
      return -1;
   }  
   /**
    * ADC calibrate.
    * Calibrates the ADC before first use.
    *
    * @note Set up the ADC clock and resolution before calibration
    *
    * @return E_NO_ERROR       Calibration successful
    * @return E_CALIBRATE_FAIL Failed calibration
    */
   static ErrorCode calibrate(volatile ADC_Type *adc) {
   
      // Save modified registers
      uint8_t sc2 = adc->SC2;
      uint8_t sc3 = adc->SC3;
   
#ifndef ADC_SC2_DMAEN_MASK
      static constexpr uint32_t mask = ADC_SC2_ADTRG_MASK|ADC_SC2_ACFE_MASK;
#else
      static constexpr uint32_t mask = ADC_SC2_ADTRG_MASK|ADC_SC2_ACFE_MASK|ADC_SC2_DMAEN_MASK;
#endif
   
      // Disable hardware trigger
      adc->SC2 = sc2 & ~mask;
   
      // Start calibration
      adc->SC3 = AdcAveraging_Cal;
   
      // Wait for calibration to complete
      while ((adc->SC1[0] & ADC_SC1_COCO_MASK) == 0) {
         __asm__("nop");
      }
   
      // Clear COCO
      (void)adc->R[0];
   
      // Check if calibration failed
      bool failed = adc->SC3 & ADC_SC3_CALF_MASK;
   
      // Restore original register values
      adc->SC2 = sc2;
      adc->SC3 = sc3;
   
      // Check calibration outcome
      if(failed) {
         // Failed calibration
         return setErrorCode(E_CALIBRATE_FAIL);
      }
   
      // Calibration factor
      uint16_t calib;
      calib = adc->CLPS + adc->CLP4 + adc->CLP3 + adc->CLP2 + adc->CLP1 + adc->CLP0;
      calib /= 2;
      calib |= (1<<15);  // Set MSB
      adc->PG = calib;
   
#ifdef ADC_MG_MG_MASK
      calib = adc->CLMS + adc->CLM4 + adc->CLM3 + adc->CLM2 + adc->CLM1 + adc->CLM0;
      calib /= 2;
      calib |= (1<<15);  // Set MSB
      adc->MG = calib;
#endif
   
      return E_NO_ERROR;
   }
   
   /**
    * Limit channel to permitted range.
    * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
    *
    * @param channel   Channel number to limit
    *
    * @return Index limited to permitted range
    */
   template<class Info>
   static inline constexpr int limitIndex(AdcChannelNum channel) {
      if (int(channel)>(Info::numSignals-1)) {
         return Info::numSignals-1;
      }
      return int(channel);
   }
   
   /** Class to static check channel exists and is mapped to an input pin */
   CreatePeripheralPinChecker("ADC");
   
protected:
   /**
    * Initiates a conversion at the current resolution but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    */
   void startConversion(int sc1Value) const {
   
      // Select A/B Mux
      if (AdcChannelNum(sc1Value&~ADC_SC1_AIEN_MASK)>=AdcChannelNum::AdcChannelNum_BFirst) {
         adc->CFG2 = adc->CFG2|ADC_CFG2_MUXSEL_MASK;
         sc1Value -= uint8_t(AdcChannelNum::AdcChannelNum_BFirst)-4;
      }
      else {
         adc->CFG2 = adc->CFG2&~ADC_CFG2_MUXSEL_MASK;
      }
      // Trigger conversion
      adc->SC1[0] = sc1Value;
      (void)adc->SC1[0];
   };
   
   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    * @param adcResolution      New Resolution to use (persistent)
    */
   void startConversion(const int sc1Value, AdcResolution adcResolution) const {
   
      // Set resolution
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
      startConversion(sc1Value);
   };
   
   /**
    * Initiates a conversion at the current resolution and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   int readAnalogue(uint32_t sc1Value) const {
   
      startConversion(sc1Value);
      while ((adc->SC1[0]&ADC_SC1_COCO_MASK) == 0) {
         __asm__("nop");
      }
      return getConversionResult();
   };
   
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used affects all future conversion on all channels on the ADC
    */
   int readAnalogue(uint32_t sc1Value, AdcResolution adcResolution) const {
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
      return readAnalogue(sc1Value);
   };
   
public:
   /**
    * ADC calibrate.
    * Calibrates the ADC before first use.
    *
    * @note Set up the ADC clock and resolution before calibration
    *
    * @return E_NO_ERROR       Calibration successful
    * @return E_CALIBRATE_FAIL Failed calibration
    */
   ErrorCode calibrate() const {
      return AdcBasicInfo::calibrate(adc);
   }
   
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param adcChannelNum Number of channel to convert
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   int readAnalogue(AdcChannelNum adcChannelNum) const {
   
      return readAnalogue((uint32_t)adcChannelNum);
   }
   
   /**
    * Enables hardware trigger mode of operation and configures the channel.
    * Note this does not configure the MUX which should be done beforehand
    *
    * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
    * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel
    *                            This corresponds to pre-triggers in the PDB channels and SC1[n] register setups
    */
   void enableHardwareConversion(int sc1Value, AdcPretrigger adcPretrigger) const {
   
      // Enable hardware triggers
      adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG_MASK;
   
      // Configure channel to use for hardware trigger input
      if (AdcChannelNum(sc1Value&~ADC_SC1_AIEN_MASK)>=AdcChannelNum::AdcChannelNum_BFirst) {
         sc1Value -= uint8_t(AdcChannelNum::AdcChannelNum_BFirst)-4;
      }
      adc->SC1[adcPretrigger] = sc1Value;
   }
   
   /**
    * Configure comparison mode.
    *
    * @param[in] adcCompare   Comparison operation to enable
    * @param[in] low          Lower threshold
    * @param[in] high         Higher threshold (if needed)
    */
   void enableComparison(AdcCompare adcCompare, int low=INT_MIN, int high=INT_MAX) const {
   
      usbdm_assert (low<=high, "ADC Low level > high level");
   
      // Juggle CV1, CV2 values to satisfy comparison rules
      switch (adcCompare) {
         case AdcCompare_Disabled:
            break;
         case AdcCompare_LessThan:
         case AdcCompare_GreaterThanOrEqual:
            adc->CV1 = low;
            break;
         case AdcCompare_OutsideRangeExclusive:
         case AdcCompare_InsideRangeInclusive:
            adc->CV1 = low;
            adc->CV2 = high;
            break;
         case AdcCompare_InsideRangeExclusive:
         case AdcCompare_OutsideRangeInclusive:
            adc->CV1 = high;
            adc->CV2 = low;
            break;
      }
      // The mask for valid bits (note adcCompare value may contain out-of-bound bits)
      static constexpr uint32_t mask = ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(1)|ADC_SC2_ACREN(1);
   
      // Set comparison fields
      adc->SC2 = (adc->SC2&~mask)|(adcCompare&mask);
   }
   
   /**
    * Gets result of last software initiated conversion
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value
    *         For single-ended conversions this will be zero extended
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   int getConversionResult() const {
   
      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[0]);
   
#if defined(ADC_SC1_DIFF_MASK)
      if (adc->SC1[0] & ADC_SC1_DIFF_MASK) {
         // Differential conversion - convert to signed
         value = static_cast<int16_t>(value);
      }
#endif
      return value;
   };
   
   /**
    * Gets result of hardware initiated conversion
    *
    * @param preTrigger Pretrigger to use (identifies which SC1 register to access)
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value
    *         For single-ended conversions this will be zero extended
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   int getHardwareConversionResult(AdcPretrigger preTrigger) const {
   
      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[preTrigger]);
   
#if defined(ADC_SC1_DIFF_MASK)
      if (adc->SC1[preTrigger] & ADC_SC1_DIFF_MASK) {
         // Differential conversion - convert to signed
         value = static_cast<int16_t>(value);
      }
#endif
   
      return value;
   };
   
   /**
    * Set clock source
    *
    * @param[in] adcClockSource  Clock source e.g. AdcClockSource_Asynch
    * @param[in] adcClockDivider Clock divider e.g. AdcClockDivider_4
    *
    * @note This affects all channels on the ADC.

    * The resulting ADC clock rate should be restricted to the following ranges:

    *  [2..12MHz] for 16-bit conversion modes  

    *  [1..18MHz] for other conversion modes
    */
   void setClockSource(
                          AdcClockSource adcClockSource,
                          AdcClockDivider adcClockDivider=AdcClockDivider_DivBy1) const {
      adc->CFG1 = (adc->CFG1&~(ADC_CFG1_ADIV_MASK|ADC_CFG1_ADICLK_MASK))|adcClockSource|adcClockDivider;
   }
   
   
   /**
    * Set ADC Resolution
    * (adc_cfg1_mode)
    *
    * @param adcResolution The resolutions available vary with single-ended/differential modes
    *        Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff
    */
   void setResolution(AdcResolution adcResolution) const {
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK) | uint32_t(adcResolution);
   }
   
   /**
    * Get ADC Resolution
    * (adc_cfg1_mode)
    *
    * @return The resolutions available vary with single-ended/differential modes
    *        Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff
    */
   AdcResolution getResolution() const {
      return AdcResolution(adc->CFG1&ADC_CFG1_MODE_MASK);
   }
   
   /**
    * Set A/B multiplexor selection
    * (adc_cfg2_muxsel)
    *
    * @param adcMuxsel Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b
    */
   void setMuxsel(AdcMuxsel adcMuxsel) const {
      adc->CFG2 = (adc->CFG2&~ADC_CFG2_MUXSEL_MASK) | uint32_t(adcMuxsel);
   }
   
   /**
    * Get A/B multiplexor selection
    * (adc_cfg2_muxsel)
    *
    * @return Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b
    */
   AdcMuxsel getMuxsel() const {
      return AdcMuxsel(adc->CFG2&ADC_CFG2_MUXSEL_MASK);
   }
   
   /**
    * Set Asynchronous Clock Output Enable
    * (adc_cfg2_adacken)
    *
    * @param adcAsyncClock Enables the ADC internal asynchronous clock source irrespective of ADC need.
    *        This reduces the initial delay at the start of a sequence of conversions.
    *        It also allows use of the ADC internal clock as a clock source for other peripherals
    */
   void setAsynchronousClock(AdcAsyncClock adcAsyncClock) const {
      adc->CFG2 = (adc->CFG2&~ADC_CFG2_ADACKEN_MASK) | uint32_t(adcAsyncClock);
   }
   
   /**
    * Get Asynchronous Clock Output Enable
    * (adc_cfg2_adacken)
    *
    * @return Enables the ADC internal asynchronous clock source irrespective of ADC need.
    *        This reduces the initial delay at the start of a sequence of conversions.
    *        It also allows use of the ADC internal clock as a clock source for other peripherals
    */
   AdcAsyncClock getAsynchronousClock() const {
      return AdcAsyncClock(adc->CFG2&ADC_CFG2_ADACKEN_MASK);
   }
   
   /**
    * Get Conversion Status
    * (adc_sc2_adact)
    *
    * @return Indicates that a conversion or sequence of conversions is in progress.
    *        Set when a conversion is initiated and cleared when a conversion is completed or aborted
    */
   AdcStatus getConversionActive() const {
      return AdcStatus(adc->SC2&ADC_SC2_ADACT_MASK);
   }
   
   /**
    * Set DMA Enable
    * (adc_sc2_dmaen)
    *
    * @param adcDma Enables use of DMA with ADC
    */
   void setDma(AdcDma adcDma) const {
      adc->SC2 = (adc->SC2&~ADC_SC2_DMAEN_MASK) | uint32_t(adcDma);
   }
   
   /**
    * Get DMA Enable
    * (adc_sc2_dmaen)
    *
    * @return Enables use of DMA with ADC
    */
   AdcDma getDma() const {
      return AdcDma(adc->SC2&ADC_SC2_DMAEN_MASK);
   }
   
   /**
    * Set Single or continuous conversion
    * (adc_sc3_adco)
    *
    * @param adcOperation Selects between single and multiple conversions.
    *        Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,
    *        or following assertion of ADHWT when hardware triggered operation is selected.
    */
   void setContinuousConversions(AdcOperation adcOperation) const {
      adc->SC3 = (adc->SC3&~ADC_SC3_ADCO_MASK) | uint32_t(adcOperation);
   }
   
   /**
    * Get Single or continuous conversion
    * (adc_sc3_adco)
    *
    * @return Selects between single and multiple conversions.
    *        Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,
    *        or following assertion of ADHWT when hardware triggered operation is selected.
    */
   AdcOperation getContinuousConversions() const {
      return AdcOperation(adc->SC3&ADC_SC3_ADCO_MASK);
   }
   
   /**
    * Set Hardware Average Select
    * (adc_sc3_avg)
    *
    * @param adcAveraging Determines how many ADC conversions will be averaged
    *        by the hardware to create the ADC result
    */
   void setAveraging(AdcAveraging adcAveraging) const {
      adc->SC3 = (adc->SC3&~(ADC_SC3_CAL_MASK|ADC_SC3_CALF_MASK|ADC_SC3_AVGE_MASK|ADC_SC3_AVGS_MASK)) | uint32_t(adcAveraging);
   }
   
   /**
    * Get Hardware Average Select
    * (adc_sc3_avg)
    *
    * @return Determines how many ADC conversions will be averaged
    *        by the hardware to create the ADC result
    */
   AdcAveraging getAveraging() const {
      return AdcAveraging(adc->SC3&(ADC_SC3_CAL_MASK|ADC_SC3_CALF_MASK|ADC_SC3_AVGE_MASK|ADC_SC3_AVGS_MASK));
   }
   
   /**
    * Class used to do initialisation of the Adc
    *
    * This class has a templated constructor that accepts various values.
    * Parameters available may vary with device - see Adc0::DefaultInitValue for relevant example.
    * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Adc0::Init adc0Init {
    *
    *   // Setup values
    *   // Omitted parameters are take to be zero unless a base value is given
    *   AdcClockSource_Asynch ,  // ADC Clock Source
    *   AdcClockDivider_1 ,      // Clock Divide Select
    *   AdcResolution_8bit_se ,  // ADC Resolution
    *   AdcPower_Normal ,        // Low-Power Configuration
    *   AdcClockRange_Normal ,   // High-Speed Configuration
    *   AdcAsyncClock_Disabled , // Asynchronous Clock Output Enable
    *   AdcRefSel_VrefHL ,       // Voltage Reference Selection
    *   AdcDma_Disabled ,        // DMA Enable
    *   AdcMuxsel_B ,            // Selects between A/B multiplexor inputs on some ADC channels
    *   AdcInterrupt_Disabled ,  // Enables conversion interrupts
    *   AdcDma_Disabled ,        // DMA Enable
    *   AdcTrigger_Software ,    // Conversion Trigger Select
    *   AdcAveraging_off ,       // Hardware Average Select
    *   AdcContinuous_Disabled , // Selects between single and continuous conversion
    *
    *   // These 2/3 parameters must appear in this order
    *   AdcCompare_LessThan ,    // Compare function
    *   5000 ,                   // ADC CV low value
    *   6000 ,                   // ADC CV high value (May be omitted)
    *
    *   AdcPretrigger_0, AdcChannelNum_11,    AdcAction_None,         // Settings for ADC hardware trigger #0
    *   AdcPretrigger_1, AdcChannelNum_Diff0, AdcAction_Interrupt,    // Settings for ADC hardware trigger #1
    *
    *   // Optional base value to start with (must be last parameter)
    *   Adc0::DefaultInitValue   // Used as base value modified by above
    * };
    *
    * // Initialise Adc0 from values specified above
    * Adc0::configure(adc0Init)
    * @endcode
    */
   class Init {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr Init(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      // ADC CV low value (adc_cv1)
      uint16_t cv1 = 0;

      // ADC CV high value (adc_cv2)
      uint16_t cv2 = 0;

      // ADC Input Clock (adc_cfg1_adiclk)
      // ADC Resolution (adc_cfg1_mode)
      // Low-Power Configuration (adc_cfg1_adlpc)
      // Sample Time Configuration (adc_sample)
      uint8_t cfg1 = 0;

      // High-Speed Configuration (adc_cfg2_adhsc)
      // Asynchronous Clock Output Enable (adc_cfg2_adacken)
      // A/B multiplexor selection (adc_cfg2_muxsel)
      // Sample Time Configuration (adc_sample)
      uint8_t cfg2 = 0;

      // Voltage Reference Selection (adc_sc2_refsel)
      // DMA Enable (adc_sc2_dmaen)
      // Compare function (adc_sc2_compare)
      // Conversion Trigger Select (adc_sc2_adtrg)
      uint8_t sc2 = 0;

      // Hardware Average Select (adc_sc3_avg)
      // Single or continuous conversion (adc_sc3_adco)
      uint8_t sc3 = 0;

      // ADC Channel number (adc_sc1_adch)
      // Action on conversion completion (adc_sc1_aien)
      uint8_t sc1[ADC_SC1_COUNT] = {
         uint8_t(AdcChannelNum::AdcChannelNum_Disabled),
         uint8_t(AdcChannelNum::AdcChannelNum_Disabled),
      };

      /**
       * Constructor for hardware pretrigger
       * (adc_pretrigger,adc_sc1_adch,adc_sc1_aien)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcPretrigger Selects which SC1[x]/R[x] register pair to use
       * @param adcChannelNum Selects an ADC channel
       * @param adcAction     Controls whether an interrupt is triggered at the end of each conversion
       */
      template <typename... Types>
      constexpr Init(
            AdcPretrigger adcPretrigger,
            AdcChannelNum adcChannelNum,
            AdcAction     adcAction, Types... rest) : Init(rest...) {
   
         if ((adcChannelNum>=AdcChannelNum::AdcChannelNum_AFirst)&&(adcChannelNum<=AdcChannelNum::AdcChannelNum_ALast)) {
            cfg2 &= ~ADC_CFG2_MUXSEL_MASK;
         }
         else if ((adcChannelNum>=AdcChannelNum::AdcChannelNum_BFirst)&&(adcChannelNum<=AdcChannelNum::AdcChannelNum_BLast)) {
            cfg2 |= ADC_CFG2_MUXSEL_MASK;
         }
         sc1[adcPretrigger] = mapChannelNumToPhysicalChannelNum(adcChannelNum)|adcAction;
      }
   
      /**
       * Constructor for ADC Input Clock
       * (adc_cfg1_adiclk)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcClockSource Clock source for the ADC module
       */
      template <typename... Types>
      constexpr Init(AdcClockSource adcClockSource, Types... rest) : Init(rest...) {
   
         cfg1 = (cfg1&~ADC_CFG1_ADICLK_MASK) | uint32_t(adcClockSource);
      }
   
      /**
       * Constructor for ADC Resolution
       * (adc_cfg1_mode)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcResolution The resolutions available vary with single-ended/differential modes
       *        Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff
       */
      template <typename... Types>
      constexpr Init(AdcResolution adcResolution, Types... rest) : Init(rest...) {
   
         cfg1 = (cfg1&~ADC_CFG1_MODE_MASK) | uint32_t(adcResolution);
      }
   
      /**
       * Constructor for Low-Power Configuration
       * (adc_cfg1_adlpc)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcPower Controls trade-off between speed and power consumption
       *        It also affects the speed of the asynchronous clock
       */
      template <typename... Types>
      constexpr Init(AdcPower adcPower, Types... rest) : Init(rest...) {
   
         cfg1 = (cfg1&~ADC_CFG1_ADLPC_MASK) | uint32_t(adcPower);
      }
   
      /**
       * Constructor for High-Speed Configuration
       * (adc_cfg2_adhsc)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcClockRange Configures the ADC for high-speed clock operation
       *        This actually extends the number of conversion clock cycles
       *        but is offset by allowing a faster input clock
       */
      template <typename... Types>
      constexpr Init(AdcClockRange adcClockRange, Types... rest) : Init(rest...) {
   
         cfg2 = (cfg2&~ADC_CFG2_ADHSC_MASK) | uint32_t(adcClockRange);
      }
   
      /**
       * Constructor for Asynchronous Clock Output Enable
       * (adc_cfg2_adacken)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcAsyncClock Enables the ADC internal asynchronous clock source irrespective of ADC need.
       *        This reduces the initial delay at the start of a sequence of conversions.
       *        It also allows use of the ADC internal clock as a clock source for other peripherals
       */
      template <typename... Types>
      constexpr Init(AdcAsyncClock adcAsyncClock, Types... rest) : Init(rest...) {
   
         cfg2 = (cfg2&~ADC_CFG2_ADACKEN_MASK) | uint32_t(adcAsyncClock);
      }
   
      /**
       * Constructor for A/B multiplexor selection
       * (adc_cfg2_muxsel)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcMuxsel Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b
       */
      template <typename... Types>
      constexpr Init(AdcMuxsel adcMuxsel, Types... rest) : Init(rest...) {
   
         cfg2 = (cfg2&~ADC_CFG2_MUXSEL_MASK) | uint32_t(adcMuxsel);
      }
   
      /**
       * Constructor for Voltage Reference Selection
       * (adc_sc2_refsel)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcReferenceSel Selects the voltage reference source used for conversions
       */
      template <typename... Types>
      constexpr Init(AdcReferenceSel adcReferenceSel, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~ADC_SC2_REFSEL_MASK) | uint32_t(adcReferenceSel);
      }
   
      /**
       * Constructor for DMA Enable
       * (adc_sc2_dmaen)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcDma Enables use of DMA with ADC
       */
      template <typename... Types>
      constexpr Init(AdcDma adcDma, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~ADC_SC2_DMAEN_MASK) | uint32_t(adcDma);
      }
   
      /**
       * Constructor for Conversion Trigger Select
       * (adc_sc2_adtrg)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcTrigger Controls whether conversions are triggered by writes to ADC_SC1 (software)
       *        or assertion of ADHWT input (hardware)
       */
      template <typename... Types>
      constexpr Init(AdcTrigger adcTrigger, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~ADC_SC2_ADTRG_MASK) | uint32_t(adcTrigger);
      }
   
      /**
       * Constructor for Hardware Average Select
       * (adc_sc3_avg)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcAveraging Determines how many ADC conversions will be averaged
       *        by the hardware to create the ADC result
       */
      template <typename... Types>
      constexpr Init(AdcAveraging adcAveraging, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~(ADC_SC3_CAL_MASK|ADC_SC3_CALF_MASK|ADC_SC3_AVGE_MASK|ADC_SC3_AVGS_MASK)) | uint32_t(adcAveraging);
      }
   
      /**
       * Constructor for Single or continuous conversion
       * (adc_sc3_adco)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcOperation Selects between single and multiple conversions.
       *        Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,
       *        or following assertion of ADHWT when hardware triggered operation is selected.
       */
      template <typename... Types>
      constexpr Init(AdcOperation adcOperation, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADCO_MASK) | uint32_t(adcOperation);
      }
   
      /**
       * Constructor for Sample Time Configuration
       * (adc_sample)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSample Selects sample times 
       *        Longer sample times allow higher impedance inputs to be accurately sampled or
       *        shorter sample times maximizes the conversion speed for lower impedance inputs.
       *        Longer sample times can also be used to lower overall power consumption when
       *        continuous conversions are enabled.
       */
      template <typename... Types>
      constexpr Init(AdcSample adcSample, Types... rest) : Init(rest...) {
   
         cfg1 = (cfg1&~ADC_CFG1_ADLSMP_MASK) | (adcSample&ADC_CFG1_ADLSMP_MASK);
         cfg2 = (cfg2&~ADC_CFG2_ADLSTS_MASK) | (adcSample&ADC_CFG2_ADLSTS_MASK);
      }
   
      /**
       * Configure Compare function, ADC CV low value and ADC CV high value
       * (adc_sc2_compare,adc_cv1,adc_cv2)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param[in] adcCompare   Comparison operation to enable
       * @param[in] low          Lower threshold
       * @param[in] high         Higher threshold (if needed)
       */
      template <typename... Types>
      constexpr Init(AdcCompare adcCompare, int low, int high=0, Types... rest) : Init(rest...) {
   
         // Juggle CV1, CV2 values to satisfy comparison rules
         switch (adcCompare) {
            default:
               cv1 = low;
               cv2 = high;
               break;
            case AdcCompare_InsideRangeExclusive:
            case AdcCompare_OutsideRangeInclusive:
               cv1 = high;
               cv2 = low;
               break;
         }
         // Mask for valid bits (note adcCompare value may contain out-of-bound bits)
         constexpr uint32_t mask = (ADC_SC2_ACFE_MASK|ADC_SC2_ACREN_MASK|ADC_SC2_ACFGT_MASK);
   
         // Set comparison fields
         sc2 = (sc2&~mask)|(adcCompare&mask);
      }
   
   }; // class AdcBasicInfo::Init
   
   /**
    * Configure ADC from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param adc            Hardware instance pointer
    * @param init            Class containing initialisation values
    */
   static void configure(
                  volatile ADC_Type *adc,
                  const Init    &init) {
   
      // Calculate clock dividers and update cfg1
      uint8_t cfg1 = calculateClockDivider(init.cfg1, init.cfg2);
   
   
      // Low-Power Configuration (adc_cfg1_adlpc)
      // Clock Divide Select (adc_cfg1_adiv)
      // ADC Resolution (adc_cfg1_mode)
      // ADC Input Clock (adc_cfg1_adiclk)
      adc->CFG1=cfg1;
   
      // A/B multiplexor selection (adc_cfg2_muxsel)
      // Asynchronous Clock Output Enable (adc_cfg2_adacken)
      // High-Speed Configuration (adc_cfg2_adhsc)
      adc->CFG2 = init.cfg2;
   
      // ADC CV low value (adc_cv1)
      adc->CV1 = init.cv1;
   
      // ADC CV high value (adc_cv2)
      adc->CV2 = init.cv2;
   
      // Conversion Trigger Select (adc_sc2_adtrg)
      // DMA Enable (adc_sc2_dmaen)
      // Voltage Reference Selection (adc_sc2_refsel)
      adc->SC2 = init.sc2;
   
      // Single or continuous conversion (adc_sc3_adco)
      // Hardware Average Select (adc_sc3_avg)
      adc->SC3 = init.sc3;
      calibrate(adc);
   
      // Set up channel information
      for (size_t index=0; index<ADC_SC1_COUNT; index++) {
         adc->SC1[index] = init.sc1[index];
      }
   
   }
   
   /**
    * Configure ADC from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param init Class containing initialisation values
    */
   void configure(const Init &init) const {
   
      configure(adc, init);
   }
   
}; // class AdcBasicInfo 

class Adc0Info : public AdcBasicInfo {

public:

   //! Number of signals available in info table
   static constexpr int numSignals  = 44;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: ADC0_SE0             = ADC0_DP0(p7)                   */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   1: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   2: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   3: ADC0_SE3             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   5: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   6: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   7: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   8: ADC0_SE8             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   9: ADC0_SE9             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  10: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  11: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  12: ADC0_SE12            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  13: ADC0_SE13            = PTB3(p30)                      */  { PinIndex::PTB3,         PcrValue(0x00000UL) },
         /*  14: ADC0_SE14            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  15: ADC0_SE15            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  16: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  17: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  18: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  19: ADC0_SE19            = ADC0_DM0(p8)                   */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*  20: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  21: ADC0_SE21            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  22: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  23: ADC0_SE23            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  24: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  25: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  26: ADC0_SE26            = TEMP_SENSOR(Internal)          */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*  27: ADC0_SE27            = BANDGAP(Internal)              */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*  28: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  29: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  30: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  31: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  32: ADC0_DP0             = ADC0_DP0(p7)                   */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*  33: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  34: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  35: ADC0_DP3             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  36: ADC0_SE4b            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  37: ADC0_SE5b            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  38: ADC0_SE6b            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  39: ADC0_SE7b            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  40: ADC0_DM0             = ADC0_DM0(p8)                   */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*  41: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  42: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  43: ADC0_DM3             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTB_CLOCK_MASK);
      PORTB->GPCLR = (0x0000UL|PORT_GPCLR_GPWE(0x0008UL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTB_CLOCK_MASK);
      PORTB->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0008UL);
   }

   /*
    * Template:adc0_diff_a
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with ADC0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with ADC0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = ADC0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Adc0
    */
   static void enableClock() {
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_ADC0_MASK;
   }
   
   /**
    *  Disable clock to Adc0
    */
   static void disableClock() {
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_ADC0_MASK;
   }
   
   /**
    * Basic enable of Adc0
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      enableClock();
      configureAllPins();
   }
   
   /**
    * Disables Adc0
    */
   static void disable() {
   
      adc->SC1[0] = ADC_SC1_ADCH(-1);
      disableNvicInterrupts();
      disableAllPins();
      disableClock();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = ADC0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<ADC_Type> adc = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
protected:
   /**
    * Initiates a conversion at the current resolution but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    */
   static void startConversion(int sc1Value) {
   
      // Select A/B Mux
      if (AdcChannelNum(sc1Value&~ADC_SC1_AIEN_MASK)>=AdcChannelNum::AdcChannelNum_BFirst) {
         adc->CFG2 = adc->CFG2|ADC_CFG2_MUXSEL_MASK;
         sc1Value -= uint8_t(AdcChannelNum::AdcChannelNum_BFirst)-4;
      }
      else {
         adc->CFG2 = adc->CFG2&~ADC_CFG2_MUXSEL_MASK;
      }
      // Trigger conversion
      adc->SC1[0] = sc1Value;
      (void)adc->SC1[0];
   };
   
   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    * @param adcResolution      New Resolution to use (persistent)
    */
   static void startConversion(const int sc1Value, AdcResolution adcResolution) {
   
      // Set resolution
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
      startConversion(sc1Value);
   };
   
   /**
    * Initiates a conversion at the current resolution and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   static int readAnalogue(uint32_t sc1Value) {
   
      startConversion(sc1Value);
      while ((adc->SC1[0]&ADC_SC1_COCO_MASK) == 0) {
         __asm__("nop");
      }
      return getConversionResult();
   };
   
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used affects all future conversion on all channels on the ADC
    */
   static int readAnalogue(uint32_t sc1Value, AdcResolution adcResolution) {
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
      return readAnalogue(sc1Value);
   };
   
public:
   /**
    * ADC calibrate.
    * Calibrates the ADC before first use.
    *
    * @note Set up the ADC clock and resolution before calibration
    *
    * @return E_NO_ERROR       Calibration successful
    * @return E_CALIBRATE_FAIL Failed calibration
    */
   static ErrorCode calibrate() {
      return AdcBasicInfo::calibrate(adc);
   }
   
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param adcChannelNum Number of channel to convert
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   static int readAnalogue(AdcChannelNum adcChannelNum) {
   
      return readAnalogue((uint32_t)adcChannelNum);
   }
   
   /**
    * Enables hardware trigger mode of operation and configures the channel.
    * Note this does not configure the MUX which should be done beforehand
    *
    * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
    * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel
    *                            This corresponds to pre-triggers in the PDB channels and SC1[n] register setups
    */
   static void enableHardwareConversion(int sc1Value, AdcPretrigger adcPretrigger) {
   
      // Enable hardware triggers
      adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG_MASK;
   
      // Configure channel to use for hardware trigger input
      if (AdcChannelNum(sc1Value&~ADC_SC1_AIEN_MASK)>=AdcChannelNum::AdcChannelNum_BFirst) {
         sc1Value -= uint8_t(AdcChannelNum::AdcChannelNum_BFirst)-4;
      }
      adc->SC1[adcPretrigger] = sc1Value;
   }
   
   /**
    * Configure comparison mode.
    *
    * @param[in] adcCompare   Comparison operation to enable
    * @param[in] low          Lower threshold
    * @param[in] high         Higher threshold (if needed)
    */
   static void enableComparison(AdcCompare adcCompare, int low=INT_MIN, int high=INT_MAX) {
   
      usbdm_assert (low<=high, "ADC Low level > high level");
   
      // Juggle CV1, CV2 values to satisfy comparison rules
      switch (adcCompare) {
         case AdcCompare_Disabled:
            break;
         case AdcCompare_LessThan:
         case AdcCompare_GreaterThanOrEqual:
            adc->CV1 = low;
            break;
         case AdcCompare_OutsideRangeExclusive:
         case AdcCompare_InsideRangeInclusive:
            adc->CV1 = low;
            adc->CV2 = high;
            break;
         case AdcCompare_InsideRangeExclusive:
         case AdcCompare_OutsideRangeInclusive:
            adc->CV1 = high;
            adc->CV2 = low;
            break;
      }
      // The mask for valid bits (note adcCompare value may contain out-of-bound bits)
      static constexpr uint32_t mask = ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(1)|ADC_SC2_ACREN(1);
   
      // Set comparison fields
      adc->SC2 = (adc->SC2&~mask)|(adcCompare&mask);
   }
   
   /**
    * Gets result of last software initiated conversion
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value
    *         For single-ended conversions this will be zero extended
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   static int getConversionResult() {
   
      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[0]);
   
#if defined(ADC_SC1_DIFF_MASK)
      if (adc->SC1[0] & ADC_SC1_DIFF_MASK) {
         // Differential conversion - convert to signed
         value = static_cast<int16_t>(value);
      }
#endif
      return value;
   };
   
   /**
    * Gets result of hardware initiated conversion
    *
    * @param preTrigger Pretrigger to use (identifies which SC1 register to access)
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value
    *         For single-ended conversions this will be zero extended
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   static int getHardwareConversionResult(AdcPretrigger preTrigger) {
   
      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[preTrigger]);
   
#if defined(ADC_SC1_DIFF_MASK)
      if (adc->SC1[preTrigger] & ADC_SC1_DIFF_MASK) {
         // Differential conversion - convert to signed
         value = static_cast<int16_t>(value);
      }
#endif
   
      return value;
   };
   
   /**
    * Set clock source
    *
    * @param[in] adcClockSource  Clock source e.g. AdcClockSource_Asynch
    * @param[in] adcClockDivider Clock divider e.g. AdcClockDivider_4
    *
    * @note This affects all channels on the ADC.

    * The resulting ADC clock rate should be restricted to the following ranges:

    *  [2..12MHz] for 16-bit conversion modes  

    *  [1..18MHz] for other conversion modes
    */
   static void setClockSource(
                          AdcClockSource adcClockSource,
                          AdcClockDivider adcClockDivider=AdcClockDivider_DivBy1) {
      adc->CFG1 = (adc->CFG1&~(ADC_CFG1_ADIV_MASK|ADC_CFG1_ADICLK_MASK))|adcClockSource|adcClockDivider;
   }
   
   
   /**
    * Set ADC Resolution
    * (adc_cfg1_mode)
    *
    * @param adcResolution The resolutions available vary with single-ended/differential modes
    *        Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff
    */
   static void setResolution(AdcResolution adcResolution) {
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK) | uint32_t(adcResolution);
   }
   
   /**
    * Get ADC Resolution
    * (adc_cfg1_mode)
    *
    * @return The resolutions available vary with single-ended/differential modes
    *        Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff
    */
   static AdcResolution getResolution() {
      return AdcResolution(adc->CFG1&ADC_CFG1_MODE_MASK);
   }
   
   /**
    * Set A/B multiplexor selection
    * (adc_cfg2_muxsel)
    *
    * @param adcMuxsel Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b
    */
   static void setMuxsel(AdcMuxsel adcMuxsel) {
      adc->CFG2 = (adc->CFG2&~ADC_CFG2_MUXSEL_MASK) | uint32_t(adcMuxsel);
   }
   
   /**
    * Get A/B multiplexor selection
    * (adc_cfg2_muxsel)
    *
    * @return Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b
    */
   static AdcMuxsel getMuxsel() {
      return AdcMuxsel(adc->CFG2&ADC_CFG2_MUXSEL_MASK);
   }
   
   /**
    * Set Asynchronous Clock Output Enable
    * (adc_cfg2_adacken)
    *
    * @param adcAsyncClock Enables the ADC internal asynchronous clock source irrespective of ADC need.
    *        This reduces the initial delay at the start of a sequence of conversions.
    *        It also allows use of the ADC internal clock as a clock source for other peripherals
    */
   static void setAsynchronousClock(AdcAsyncClock adcAsyncClock) {
      adc->CFG2 = (adc->CFG2&~ADC_CFG2_ADACKEN_MASK) | uint32_t(adcAsyncClock);
   }
   
   /**
    * Get Asynchronous Clock Output Enable
    * (adc_cfg2_adacken)
    *
    * @return Enables the ADC internal asynchronous clock source irrespective of ADC need.
    *        This reduces the initial delay at the start of a sequence of conversions.
    *        It also allows use of the ADC internal clock as a clock source for other peripherals
    */
   static AdcAsyncClock getAsynchronousClock() {
      return AdcAsyncClock(adc->CFG2&ADC_CFG2_ADACKEN_MASK);
   }
   
   /**
    * Get Conversion Status
    * (adc_sc2_adact)
    *
    * @return Indicates that a conversion or sequence of conversions is in progress.
    *        Set when a conversion is initiated and cleared when a conversion is completed or aborted
    */
   static AdcStatus getConversionActive() {
      return AdcStatus(adc->SC2&ADC_SC2_ADACT_MASK);
   }
   
   /**
    * Set DMA Enable
    * (adc_sc2_dmaen)
    *
    * @param adcDma Enables use of DMA with ADC
    */
   static void setDma(AdcDma adcDma) {
      adc->SC2 = (adc->SC2&~ADC_SC2_DMAEN_MASK) | uint32_t(adcDma);
   }
   
   /**
    * Get DMA Enable
    * (adc_sc2_dmaen)
    *
    * @return Enables use of DMA with ADC
    */
   static AdcDma getDma() {
      return AdcDma(adc->SC2&ADC_SC2_DMAEN_MASK);
   }
   
   /**
    * Set Single or continuous conversion
    * (adc_sc3_adco)
    *
    * @param adcOperation Selects between single and multiple conversions.
    *        Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,
    *        or following assertion of ADHWT when hardware triggered operation is selected.
    */
   static void setContinuousConversions(AdcOperation adcOperation) {
      adc->SC3 = (adc->SC3&~ADC_SC3_ADCO_MASK) | uint32_t(adcOperation);
   }
   
   /**
    * Get Single or continuous conversion
    * (adc_sc3_adco)
    *
    * @return Selects between single and multiple conversions.
    *        Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,
    *        or following assertion of ADHWT when hardware triggered operation is selected.
    */
   static AdcOperation getContinuousConversions() {
      return AdcOperation(adc->SC3&ADC_SC3_ADCO_MASK);
   }
   
   /**
    * Set Hardware Average Select
    * (adc_sc3_avg)
    *
    * @param adcAveraging Determines how many ADC conversions will be averaged
    *        by the hardware to create the ADC result
    */
   static void setAveraging(AdcAveraging adcAveraging) {
      adc->SC3 = (adc->SC3&~(ADC_SC3_CAL_MASK|ADC_SC3_CALF_MASK|ADC_SC3_AVGE_MASK|ADC_SC3_AVGS_MASK)) | uint32_t(adcAveraging);
   }
   
   /**
    * Get Hardware Average Select
    * (adc_sc3_avg)
    *
    * @return Determines how many ADC conversions will be averaged
    *        by the hardware to create the ADC result
    */
   static AdcAveraging getAveraging() {
      return AdcAveraging(adc->SC3&(ADC_SC3_CAL_MASK|ADC_SC3_CALF_MASK|ADC_SC3_AVGE_MASK|ADC_SC3_AVGS_MASK));
   }
   
   /** Get reference to ADC hardware as struct */
   static volatile ADC_Type &adcPtr() { return *adc; }
   
   /** @return Base address of ADC hardware as uint32_t */
   static constexpr uint32_t adcBase() { return baseAddress; }
   /** @return Base address of ADC.SC1[index] registers as uint32_t */
   static constexpr uint32_t adcSC(unsigned index) { return adcBase() + offsetof(ADC_Type, SC1) + index*sizeof(ADC_Type::SC1[0]); }
   /** @return Base address of ADC.R[index] registers as uint32_t */
   static constexpr uint32_t adcR(unsigned index) { return adcBase() + offsetof(ADC_Type, R) + index*sizeof(ADC_Type::R[0]); }
   
   /**
    *   Default Constructor
    */
   Adc0Info() : AdcBasicInfo(adc) {
      defaultConfigure();
   }
   
   /**
    *   Constructor
    */
   Adc0Info(const Init &init) : AdcBasicInfo(adc) {
      configure(init);
   }
   
   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   static void defaultConfigure() {
   
      configure(DefaultInitValue);
   }
   
   /**
    * Configure ADC from values specified in init
    *
    * @param init Class containing initialisation values
    */
   static void configure(const Init &init) {
   
      // Enable peripheral
      enable();
   
      AdcBasicInfo::configure(adc, init);
   }
   
   /**
    * Default initialisation value for Adc0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
   
      AdcClockSource_Asynch ,           // (adc_cfg1_adiclk)          ADC Input Clock - Asynchronous clock (ADACK)
      AdcMuxsel_B ,                     // (adc_cfg2_muxsel)          A/B multiplexor selection - The multiplexor selects B channels
      AdcAveraging_off ,                // (adc_sc3_avg)              Hardware Average Select - 1 sample
      AdcSample_4cycles,                // (adc_sample)               Sample Time Configuration - 4 ADCK total
   
      // The following values must be in order
      AdcPretrigger_0,             // sc1[0]/r[0] ,
      Adc0ChannelNum_Se0 ,         // (adc_sc1[0]_adch)          ADC0 Channel number - ADC0_SE0 [ADC0_DP0(p7)]
      AdcAction_None,              // (adc_sc1[0]_aien)          Action on conversion completion - None
   };
   
}; // class Adc0Info



/**
 * Class representing a minimal ADC channel
 *
 * This class is not intended to be instantiated directly.
 */
class AdcChannel : public AdcBasicInfo {

private:
   AdcChannel() = delete;
   AdcChannel(const AdcChannel&) = delete;
   AdcChannel(AdcChannel&&) = delete;

protected:
   /// ADC channel (including ADC_SC1_DIFF_MASK mask)
   const uint32_t sc1Value;

   /**
    * Constructor
    *
    * @param adcAddress  ADC address
    * @param channel     ADC channel to use
    */
   constexpr AdcChannel(volatile ADC_Type *adcAddress, uint8_t channel) : AdcBasicInfo(adcAddress), sc1Value(channel) {}

public:
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   int readAnalogue() const {
      return AdcBasicInfo::readAnalogue(sc1Value);
   };

   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used here affects all future conversion on all channels on the ADC
    */
   int readAnalogue(AdcResolution adcResolution) const {
      return AdcBasicInfo::readAnalogue(sc1Value, adcResolution);
   };

   /**
    * Enables hardware trigger mode of operation and configures a channel.
    *
    * @param[in] adcPretrigger Hardware pre-trigger to use for this channel.\n
    *                          This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
    * @param[in] adcAction     Whether to generate an interrupt when each conversion completes
    */
   void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcAction=AdcAction_None) const {
      AdcBasicInfo::enableHardwareConversion(adcAction|sc1Value, adcPretrigger);
   }

   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] adcAction   Determines if an interrupt is generated when conversions are complete
    */
   void startConversion(AdcAction adcAction=AdcAction_None) const {
      AdcBasicInfo::startConversion(sc1Value|adcAction);
   };

}; // class AdcChannel

/**
 * Template class representing an ADC.
 * This class is not intended to be instantiated.
 *
 * Example
 * @code
 *  // Access to ADC0
 *  using Adc0 = AdcBase_T<Adc0Info>;
 *
 *  // Initialise ADC
 *  Adc0::setMode(AdcResolution_16bit_se);
 *  @endcode
 *
 * @tparam info Table of information describing ADC
 */
template<class Info>
class AdcBase_T : public Info {

private:
   using Info::mapChannelNumToPhysicalChannelNum;

public:
   /** Hardware instance pointer */
   static constexpr HardwarePtr<ADC_Type> adc = Info::baseAddress;

   /** Get reference to ADC hardware as struct */
   static volatile ADC_Type &adcPtr() { return Info::adc(); }

   /** @return Base address of SPI hardware as uint32_t */
   static constexpr uint32_t adcBase() { return Info::baseAddress; }
   /** @return Base address of ADC.SC1[index] registers as uint32_t */
   static constexpr uint32_t adcSC(unsigned index) { return adcBase() + offsetof(ADC_Type, SC1) + index*sizeof(ADC_Type::SC1[0]); }
   /** @return Base address of ADC.R[index] registers as uint32_t */
   static constexpr uint32_t adcR(unsigned index) { return adcBase() + offsetof(ADC_Type, R) + index*sizeof(ADC_Type::R[0]); }

   using Info::configure;

public:

   AdcBase_T() = default;

   /**
    * Template class representing an ADC channel.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::Channel<6>;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    *
    * @tparam channel ADC channel
    */
   template<AdcChannelNum channel>
   class ChannelCommon : public AdcChannel {
   private:
      /**
       * This class is not intended to be instantiated
       */
      ChannelCommon(const ChannelCommon&) = delete;
      ChannelCommon(ChannelCommon&&) = delete;

   public:
      constexpr ChannelCommon() : AdcChannel(AdcInfo::baseAddress, channel) {}

      /** The ADC that owns this channel */
      using Owner = AdcBase_T;

      /** Information about this ADC */
      using AdcInfo = Info;

      /** Channel number */
      static constexpr AdcChannelNum CHANNEL=channel;

      /**
       * Initiates a conversion but does not wait for it to complete.
       * Intended for use with interrupts or DMA.
       *
       * @param[in] adcAction   Determines if an interrupt is generated when conversions are complete
       */
      static void startConversion(AdcAction adcAction=AdcAction_None) {
         if constexpr(!Info::irqHandlerInstalled) {
            usbdm_assert((adcAction == AdcAction_None),
                  "ADC not configured for interrupts. Modify Configure.usbdmProject");
         }
         AdcBase_T::startConversion(mapChannelNumToPhysicalChannelNum(channel)|adcAction);
      };

      /**
       * Initiates a conversion but does not wait for it to complete.
       * Intended for use with interrupts or DMA.
       *
       * @param adcResolution      New Resolution to use (persistent)
       * @param[in] adcAction   Determines if an interrupt is generated when conversions are complete
       */
      static void startConversion(AdcResolution adcResolution, AdcAction adcAction=AdcAction_None) {
         if constexpr(!Info::irqHandlerInstalled) {
            usbdm_assert((adcAction == AdcAction_None),
                  "ADC not configured for interrupts. Modify Configure.usbdmProject");
         }
         AdcBase_T::startConversion(mapChannelNumToPhysicalChannelNum(channel)|adcAction, adcResolution);
      };

      /**
       * Initiates a conversion and waits for it to complete.
       *
       * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
       *           For single-ended conversions this will be zero extended\n
       *           For differential conversions this will be sign-extended
       *
       * @note Result is signed but will always be positive for single-ended conversions.
       */
      static int readAnalogue() {
         return AdcBase_T::readAnalogue(mapChannelNumToPhysicalChannelNum(channel));
      };
      /**
       * Initiates a conversion and waits for it to complete.
       *
       * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
       *
       * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
       *           For single-ended conversions this will be zero extended\n
       *           For differential conversions this will be sign-extended
       *
       * @note Result is signed but will always be positive for single-ended conversions.
       * @note The resolution used here affects all further conversion on all channels on the ADC
       */
      static int readAnalogue(AdcResolution adcResolution) {
         return AdcBase_T::readAnalogue(mapChannelNumToPhysicalChannelNum(channel), adcResolution);
      };

      /**
       * Enables hardware trigger mode of operation and configures a channel.
       *
       * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel.\n
       *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
       * @param[in] adcAction    Whether to generate an interrupt when each conversion completes
       */
      static void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcAction=AdcAction_None) {
         AdcBase_T::enableHardwareConversion(mapChannelNumToPhysicalChannelNum(channel)|adcAction, adcPretrigger);
      }

#ifdef ADC_SC2_DMAEN
      /**
       * Enables hardware trigger mode of operation and configures a channel.
       *
       * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel\n
       *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
       * @param[in] adcAction    Whether to generate an interrupt when each conversion completes
       * @param[in] adcDma          Whether to generate a DMA request when each conversion completes
       */
      static void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcAction, AdcDma adcDma) {
         AdcBase_T::enableHardwareConversion(mapChannelNumToPhysicalChannelNum(channel)|adcAction, adcPretrigger, adcDma);
      }
#endif
   };

   template<AdcChannelNum channel>
   class Channel : public ChannelCommon<channel>  {
   private:
      static constexpr AdcBasicInfo::CheckPinExistsAndIsMapped<Info, int(channel)> check{};
#if true // adc_sc1_diff_present
      static_assert(((channel<AdcChannelNum::AdcChannelNum_DiffFirst)||(channel>AdcChannelNum::AdcChannelNum_DiffLast)), "Illegal channel number");
#endif
   public:
      /** The PCR associated with this channel (Not all channels have an associated PCR!) */
      using Pcr = PcrTable_T<Info, AdcBasicInfo::limitIndex<Info>(channel)>;

      /** GPIO pin associated with this channel (Not all channels have an associated GPIO!) */
      template<Polarity polarity=ActiveHigh>
      class GpioPin : public GpioTable_T<Info, int(channel), polarity> {
         static_assert((Info::info[channel].pinIndex >= PinIndex::MIN_PIN_INDEX),
               "ADC channel does not have corresponding GPIO pin");
      };

      /**
       * Configure the pin associated with this ADC channel.
       * The pin is in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pin to ADC
         Pcr::setPCR();
      }

      /**
       *  Disable Pin
       *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
       *
       *  @note The clock is left enabled as shared with other pins.
       *  @note Mux(0) is also the Analogue MUX setting
       */
      static void disablePin() {
         // Map pin to ADC
         if constexpr (Info::info[channel].pinIndex >= PinIndex::MIN_PIN_INDEX) {
            Pcr::disablePin();
         }
      }
   };

#if defined(ADC_PGA_PGAEN_MASK)
   /**
    * Template class representing an ADC channel with programmable gain amplifier.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::PgaChannel;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    */
   class PgaChannel : public ChannelCommon<AdcChannelNum_Diff2> {
   private:
      /**
       * This class is not intended to be instantiated
       */
      PgaChannel(const PgaChannel&) = delete;
      PgaChannel(PgaChannel&&) = delete;

   public:
      constexpr PgaChannel(){}
   };
#endif

#ifdef ADC_SC1_DIFF_MASK
   /**
    * Template class representing an ADC differential channel
    *
    * Example
    * @code
    * // Instantiate the ADC and the differential channel (for ADC_DM0, ADC_DP0)
    * using Adc0 = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::DiffChannel<AdcChannelNum_Diff1>;
    *
    * // Set ADC resolution
    * Adc0.setMode(AdcResolution_11bit_diff );
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch0.readAnalogue();
    * @endcode
    *
    * @tparam channel ADC channel
    */
   template<AdcChannelNum channel>
   class DiffChannel : public ChannelCommon<channel> {

      static_assert((channel>=AdcChannelNum::AdcChannelNum_DiffFirst)&&(channel<=AdcChannelNum::AdcChannelNum_DiffLast), "Illegal differential channel number");

   private:
      /**
       * This class is not intended to be instantiated
       */
      DiffChannel(const DiffChannel&) = delete;
      DiffChannel(DiffChannel&&) = delete;

      static constexpr AdcBasicInfo::CheckPinExistsAndIsMapped<Info, int(channel)>   checkPos{};
      static constexpr AdcBasicInfo::CheckPinExistsAndIsMapped<Info, int(channel)+8> checkNeg{};

   public:
      constexpr DiffChannel() : ChannelCommon<AdcChannelNum(channel)>() {}

      /** PCR associated with plus channel */
      using PcrP = PcrTable_T<Info, int(channel)>;

      /** PCR associated with minus channel */
      using PcrM = PcrTable_T<Info, int(channel)>;

      /** The ADC that owns this channel */
      using Owner = AdcBase_T;

      /** Information about this ADC */
      using AdcInfo = Info;

      /** Channel number */
      static constexpr int CHANNEL=int(channel);

      /**
       * Configure the pins associated with this ADC channel.
       * The pins are in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pins to ADC
         PcrP::setPCR(Info::info[channel].pcrValue);
         PcrM::setPCR(Info::info[channel].pcrValue);
      }

      /**
       *  Disable Pin
       *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
       *
       *  @note The clock is left enabled as shared with other pins.
       *  @note Mux(0) is also the Analogue MUX setting
       */
      static void disablePin() {
         // Map pin to ADC
         if constexpr (AdcInfo::InfoDP::info[0x1f&mapChannelNumToPhysicalChannelNum(channel)].portAddress != 0) {
            PcrP::disablePin();
            PcrM::disablePin();
         }
      }
   };

#if defined(ADC_PGA_PGAEN_MASK)
   /**
    * Template class representing an ADC channel with programmable gain amplifier.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::PgaChannel;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    */
   class PgaDiffChannel : public DiffChannel<AdcChannelNum_Diff2> {

   private:
      /**
       * This class is not intended to be instantiated
       */
      PgaDiffChannel(const PgaDiffChannel&) = delete;
      PgaDiffChannel(PgaDiffChannel&&) = delete;

   public:
      constexpr PgaDiffChannel(){}
   };
#endif

#endif

};

   /**
    * Class representing ADC instance
    */
   typedef AdcBasicInfo Adc;
   /**
    * Class representing ADC0
    */
   typedef AdcBase_T<Adc0Info> Adc0;
   

/**
 * End ADC_Group
 * @}
 */

} // End namespace USBDM

#endif // /ADC/_BasicInfoGuard

#endif /* HEADER_ADC_H */

