/**
 * @file     usbdcd.h (180.ARM_Peripherals/Project_Headers/usbdcd.h)
 * @brief    USB Device Charger Detection
 */

#ifndef HEADER_USBDCD_H_
#define HEADER_USBDCD_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup USBDCD_Group USBDCD, USB Device Charger Detection
 * @brief Abstraction for USB Device Charger Detection
 * @{
 */
/**
 * Peripheral information for USBDCD, USB Device Charger Detection.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */

   /**
    * Software Reset
    * (usbdcd_control_sr)
    *
    * Determines whether a software reset is performed
    */
   enum UsbdcdSoftwareReset {
      UsbdcdSoftwareReset_NoAction   = USBDCD_CONTROL_SR(0),  ///< No effect
      UsbdcdSoftwareReset_Reset      = USBDCD_CONTROL_SR(1),  ///< Software reset
   };

   /**
    * Start Change Detection Sequence
    * (usbdcd_control_start)
    *
    * Determines whether the charger detection sequence is initiated
    */
   enum UsbdcdStart {
      UsbdcdStart_NoAction        = USBDCD_CONTROL_START(0),  ///< No effect
      UsbdcdStart_StartSequence   = USBDCD_CONTROL_START(1),  ///< Start sequence
   };

   /**
    * Interrupt Handling
    * (usbdcd_control_ie)
    *
    * Enables/disables interrupts to the system.
    */
   enum UsbdcdEventAction {
      UsbdcdEventAction_None        = USBDCD_CONTROL_IE(0),  ///< Interrupts disabled
      UsbdcdEventAction_Interrupt   = USBDCD_CONTROL_IE(1),  ///< Interrupts enabled
   };

   /**
    * Interrupt Flag
    * (usbdcd_control_if)
    *
    * Indicates whether an interrupt is pending.
    */
   enum UsbdcdEvent {
      UsbdcdEvent_None               = USBDCD_CONTROL_IF(0),  ///< No interrupt
      UsbdcdEvent_InterruptPending   = USBDCD_CONTROL_IF(1),  ///< Interrupt Pending
   };

   /**
    * Interrupt Acknowledge
    * (usbdcd_control_iack)
    *
    * Used to clear pending interrupt
    */
   enum UsbdcdEventAcknowledge {
      UsbdcdEventAcknowledge_ClearFlag   = USBDCD_CONTROL_IACK(0),  ///< Write 1 to clear IF
   };

   /**
    * Unit of measurement encoding for Clock Speed
    * (usbdcd_clock_clock_unit)
    *
    * Specifies the unit of measure for the clock speed.
    */
   enum UsbdcdClockUnit {
      UsbdcdClockUnit_Khz   = USBDCD_CLOCK_CLOCK_UNIT(0),  ///< kHz
      UsbdcdClockUnit_Mhz   = USBDCD_CLOCK_CLOCK_UNIT(1),  ///< MHz
   };

   /**
    * Numerical Value of Clock Speed
    * (usbdcd_clock_clock_speed)
    *
    * This value allows the USBDCD to accurately determine time intervals
    * The unit of measure can be kHz or MHz as controlled by usbdcd_clock_clock_unit
    */
   enum UsbdcdClockSpeed : uint16_t {
   };

   /**
    * Active Status Indicator
Indicates whether the sequence is running
    * (usbdcd_status_active)
    *
    * Indicates whether the sequence is running.
    */
   enum UsbdcdActiveStatus {
      UsbdcdActiveStatus_Idle              = USBDCD_STATUS_ACTIVE(0),  ///< Sequence not running
      UsbdcdActiveStatus_SequenceRunning   = USBDCD_STATUS_ACTIVE(1),  ///< Sequence running
   };

   /**
    * Timeout Flag
    * (usbdcd_status_to)
    *
    * Indicates whether the detection sequence has passed the 1s timeout threshhold.
    */
   enum UsbdcdTimeoutStatus {
      UsbdcdTimeoutStatus_NoTimeout         = USBDCD_STATUS_TO(0),  ///< <= 1 second
      UsbdcdTimeoutStatus_TimeoutOccurred   = USBDCD_STATUS_TO(1),  ///< >= 1 second since contact
   };

   /**
    * Error Flag
Indicates whether there is an error in the detection sequence
    * (usbdcd_status_err)
    *
    * Indicates whether there is an error in the detection sequence.
    */
   enum UsbdcdErrorStatus {
      UsbdcdErrorStatus_NoError         = USBDCD_STATUS_ERR(0),  ///< No sequence errors
      UsbdcdErrorStatus_SequenceError   = USBDCD_STATUS_ERR(1),  ///< Sequence errors
   };

   /**
    * Charger Detection Sequence Status
    * (usbdcd_status_seq_stat)
    *
    * Indicates the status of the charger detection sequence.
    */
   enum UsbdcdProgress {
      UsbdcdProgress_NotDetected            = USBDCD_STATUS_SEQ_STAT(0),  ///< Not enabled/detected
      UsbdcdProgress_DataPinComplete        = USBDCD_STATUS_SEQ_STAT(1),  ///< Data pin complete
      UsbdcdProgress_ChargingPortComplete   = USBDCD_STATUS_SEQ_STAT(2),  ///< Charging port complete
      UsbdcdProgress_ChargerTypeComplete    = USBDCD_STATUS_SEQ_STAT(3),  ///< Charger type complete
   };

   /**
    * Charger Detection Sequence Results
Reports how the charger detection is attached
    * (usbdcd_status_seq_res)
    *
    * Indicates how the charger detection is attached.
    */
   enum UsbdcdOutcome {
      UsbdcdOutcome_NoResults          = USBDCD_STATUS_SEQ_RES(0),  ///< No results
      UsbdcdOutcome_StandardHost       = USBDCD_STATUS_SEQ_RES(1),  ///< Standard host
      UsbdcdOutcome_ChargingPort       = USBDCD_STATUS_SEQ_RES(2),  ///< Charging port
      UsbdcdOutcome_DedicatedCharger   = USBDCD_STATUS_SEQ_RES(3),  ///< Dedicated charger
   };

   /**
    * Sequence Initiation Time (in ms)
    * (usbdcd_timer0_tseq_init)
    *
    * This represents the system latency (in ms) measured from the time VBUS goes active to the time
    * system software initiates the charger detection sequence in the USBDCD module. 
    * When software sets the CONTROL[START] bit, the Unit Connection Timer (TUNITCON) is initialized
    * with the value of TSEQ_INIT. 
    * The USB Battery Charging Specification requires the entire sequence, including TSEQ_INIT,
    * to be completed in 1s or less.
    */
   enum UsbdcdInitiationTime : uint8_t {
   };

   /**
    * Time Period to Debounce D+ Signal (in ms)
    * (usbdcd_timer1_tdcd_dbnc)
    *
    * Sets the time period (ms) to debounce the D+ signal during the data pin contact detection phase.
    * The USB Battery Charging Specification requires a minimum value of 10 ms
    */
   enum UsbdcdDataPlusDebounceTime : uint8_t {
   };

   /**
    * Time Period Comparator Enabled (in ms)
    * (usbdcd_timer1_tvdpsrc_on)
    *
    * This timing parameter is used after detection of the data pin.
    * The USB Battery Charging Specification requires a minimum value of 40 ms.
    */
   enum UsbdcdComparatorEnabledTime : uint8_t {
   };

   /**
    * Time Period Before Enabling D+ Pullup (in ms)
    * (usbdcd_timer2_tvdpsrc_con)
    *
    * Sets the time period (ms) that the module waits after charging port detection before system
    * software must enable the D+ pullup to connect to the USB host.
    * Valid values are 1-1023, but the USB Battery Charging Specification requires a minimum
    * value of 40 ms.
    */
   enum UsbdcdDataPlusPullupDelayTime : uint8_t {
   };

   /**
    * Time Before Check of D- Line (in ms)
    * (usbdcd_timer2_check_dm)
    *
    * Sets the amount of time (in ms) that the module waits after the device connects to the USB bus until
    * checking the state of the D- line to determine the type of charging port. See Charger Type Detection.
    * Valid values are 1-15ms.
    */
   enum UsbdcdDataMinusCheckDelayTime : uint8_t {
   };

class UsbdcdBasicInfo {

public:

}; // class UsbdcdBasicInfo 

class Usbdcd0Info : public UsbdcdBasicInfo {

public:

   /*
    * Template:usbdcd0_v1_1
    */
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = USBDCD0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Usbdcd0
    */
   static void enableClock() {
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_USBDCD_MASK;
   }
   
   /**
    *  Disable clock to Usbdcd0
    */
   static void disableClock() {
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_USBDCD_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = USBDCD0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<USBDCD_Type> usbdcd = baseAddress;
   
}; // class Usbdcd0Info




/**
 * Charger Detection Sequence Status.
 * Indicates the status of the charger detection sequence.
 */
enum UsbdcdSeqStatus {
   UsbdcdSeqStatus_Idle         = 0b00, //!< The module is either not enabled, or the module is enabled but the data pins have not yet been detected.
   UsbdcdSeqStatus_PinsDetected = 0b01, //!< Data pin contact detection is complete
   UsbdcdSeqStatus_PortDetected = 0b10, //!< Charging port detection is complete.
   UsbdcdSeqStatus_TypeDetected = 0b11, //!< Charger type detection is complete.
};

/**
 * Charger Detection Sequence Results.
 * Reports how the charger detection is attached.
 */
enum UsbdcdSeqResult {
   UsbdcdSeqResult_Unknown          = 0b00, //!< No results to report.
   UsbdcdSeqResult_StandardHost     = 0b01, //!< Attached to a standard host. Must comply with USB 2.0 by drawing only 2.5 mA (max) until connected.
   UsbdcdSeqResult_ChargingPort     = 0b10, //!< Attached to a charging port. The exact meaning depends on bit 18:
   UsbdcdSeqResult_DedicatedCharger = 0b11, //!< Attached to a dedicated charger.
};

/**
 * USBDCD status
 */
union UsbdcdStatusResults {
   uint32_t mask;
   struct {
      unsigned :16;
      UsbdcdSeqResult usbdcdSeqResult:2;
      UsbdcdSeqStatus usbdcdSeqStatus:2;
      bool            error:1;
      bool            timeout:1;
      bool            active:1;
      unsigned        :9;
   };
};
/**
 * Type definition for USBDCD interrupt call back
 */
typedef void (*USBDCDCallbackFunction)();

/**
 * Template class representing the Watchdog Monitor
 *
 * The USB Device Charger Detection (USBDCD) module works with the USB transceiver to
 * detect whether the USB device is attached to a charging port, either a dedicated
 * charging port or a charging host.
 * System software coordinates the detection activities of the module and controls
 * an off-chip integrated circuit that performs the battery charging.
 *
 * @tparam info      Information class for USBDCD
 */
template<class Info>
class UsbdcdBase_T : public Info {

protected:
   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /** Callback function for ISR */
   static USBDCDCallbackFunction callback;

public:
   /**
    * Hardware instance pointer.
    *
    * @return Reference to USBDCD hardware
    */
   static constexpr HardwarePtr<USBDCD_Type> usbdcd = Info::baseAddress;

   /**
    * Get USBDCD status.
    *
    * @return Status value
    */
   static UsbdcdStatusResults getStatus() {
      union {
         uint32_t              a;
         UsbdcdStatusResults   b;
      } x;
      x.a = usbdcd->STATUS;
      return (x.b);
   }

   /**
    * IRQ handler
    */
   static void irqHandler() {
      // Call handler
      callback();
   }

   /**
    * Set callback function.
    *
    * @param[in]  theCallback Callback function to execute on interrupt
    *
    * @note It is expected that the callback will clear the status flag that triggered the interrupt. See getStatus().
    */
   static void setCallback(USBDCDCallbackFunction theCallback) {
      static_assert(Info::irqHandlerInstalled, "USBDCD not configure for interrupts - Modify Configure.usbdm");
      if (theCallback == nullptr) {
         theCallback = unhandledCallback;
      }
      callback = theCallback;
   }

public:

   /**
    * Basic enable USBDCD.
    */
   static void enable() {

      // Enable clock to interface
      Info::enableClock();
   }


   /**
    * Disable interface to USBDCD
    */
   static void disable() {
      Info::disableClock();
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable/disable interrupts
    *
    * @param[in]  enable        True => enable, False => disable
    *
    * @note This is a protected operation which requires unlock
    */
   static void enableInterrupt(bool enable=true) {
      if (enable) {
         usbdcd->CONTROL = usbdcd->CONTROL | USBDCD_CONTROL_IE_MASK;
      }
      else {
         usbdcd->CONTROL = usbdcd->CONTROL & ~USBDCD_CONTROL_IE_MASK;
      }
   }

   /**
    * Clear interrupt flag
    */
   static void clearInterrupt() {
      usbdcd->CONTROL = usbdcd->CONTROL | USBDCD_CONTROL_IACK_MASK;
   }

   /**
    * Start detection sequence
    */
   static void startDetection() {
      usbdcd->CONTROL = usbdcd->CONTROL | USBDCD_CONTROL_START_MASK;
   }

   /**
    * Software reset
    */
   static void softwareReset() {
      usbdcd->CONTROL = usbdcd->CONTROL | USBDCD_CONTROL_SR_MASK;
   }
};

template<class Info> USBDCDCallbackFunction UsbdcdBase_T<Info>::callback = UsbdcdBase_T<Info>::unhandledCallback;


/**
 * End USBDCD_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_USBDCD_H_ */
