/**
 * @file     fmc.h (180.ARM_Peripherals/Project_Headers/fmc.h)
 * @brief    Miscellaneous Control Module
 */

#ifndef HEADER_FMC_H
#define HEADER_FMC_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

// $/FMC/prototypes not found

namespace USBDM {

/**
 * Peripheral information for FMC, Flash Memory Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Master N Prefetch Disable
    * (fmc_pfapr_mpfd)
    *
    * These bits control whether prefetching is enabled based on the logical number
    * of the requesting crossbar switch master. 
    * This field is further qualified by the PFBnCR[BxDPE,BxIPE] bits.
    */
   enum FmcPrefetch {
      FmcPrefetch_Enabled    = FMC_PFAPR_M0PFD(0),  ///< Prefetching enabled
      FmcPrefetch_Disabled   = FMC_PFAPR_M0PFD(1),  ///< Prefetching is disabled
   };

   /**
    * Master N Access Protection
    * (fmc_pfapr_map)
    *
    * This field controls whether read and write access to the flash are allowed
    * based on the logical master number of the requesting crossbar switch master
    */
   enum FmcAccessProtection {
      FmcAccessProtection_NoAccessAllowed        = FMC_PFAPR_M0AP(0),  ///< No access allowed
      FmcAccessProtection_OnlyReadAccesses       = FMC_PFAPR_M0AP(1),  ///< Only read accesses
      FmcAccessProtection_OnlyWriteAccesses      = FMC_PFAPR_M0AP(2),  ///< Only write accesses
      FmcAccessProtection_ReadAndWriteAccesses   = FMC_PFAPR_M0AP(3),  ///< Read and write accesses
   };

   /**
    * Cache Lock Way N
    * (fmc_pfb0cr_clck_way)
    *
    * Determine if the given cache way is locked such that its contents will not be displaced by future misses
    */
   enum FmcCacheWayLock {
      FmcCacheWayLock_CacheWayIsUnlocked   = FMC_PFB0CR_CLCK_WAY(0),  ///< Cache way is unlocked
      FmcCacheWayLock_CacheWayIsLocked     = FMC_PFB0CR_CLCK_WAY(1),  ///< Cache way is locked
   };

   /**
    * Cache Invalidate Way N
    * (fmc_pfb0cr_cinv_way)
    *
    * Selects a cache Way to immediately invalidate.
    * The tag, data, and valid contents are cleared.
    */
   enum FmcWayInvalidate {
      FmcWayInvalidate_Way0      = FMC_PFB0CR_CINV_WAY(1<<0),  ///< Invalidate Way 0
      FmcWayInvalidate_Way1      = FMC_PFB0CR_CINV_WAY(1<<1),  ///< Invalidate Way 1
      FmcWayInvalidate_Way2      = FMC_PFB0CR_CINV_WAY(1<<2),  ///< Invalidate Way 2
      FmcWayInvalidate_Way3      = FMC_PFB0CR_CINV_WAY(1<<3),  ///< Invalidate Way 3
      FmcWayInvalidate_AllWays   = FMC_PFB0CR_CINV_WAY(-1),    ///< Invalidate all Ways
   };

   /**
    * Invalidate Prefetch Speculation Buffer
    * (fmc_pfb0cr_s_b_inv)
    *
    * When this bit is written, the prefetch speculation buffer and single entry buffer are immediately cleared
    */
   enum FmcSpeculationBuffer {
      FmcSpeculationBuffer_Invalidate   = FMC_PFB0CR_S_B_INV(1),  ///< Write 1 to invalidate
   };

   /**
    * Cache Replacement Policy
    * (fmc_pfb0cr_crc)
    *
    * This field defines the replacement algorithm for accesses that are cached
    */
   enum FmcReplacementPolicy {
      FmcReplacementPolicy_LruAllWays                     = FMC_PFB0CR_CRC(0),  ///< LRU across all ways
      FmcReplacementPolicy_LruWays_01Instruction_23Data   = FMC_PFB0CR_CRC(2),  ///< Independent LRU ways [0-1] ifetches, [2-3] data
      FmcReplacementPolicy_LruWays_012Instruction_3Data   = FMC_PFB0CR_CRC(3),  ///< Independent LRU ways [0-2] ifetches, [3] data
   };

   /**
    * Bank 0 Flash Controller Speculation Buffer
    * (fmc_pfb0cr_flash_speculation)
    *
    * Controls the operation of the Speculation Buffer for each Flash Controller bank
    */
   enum FmcFlashSpeculation {
      FmcFlashSpeculation_Disabled              = FMC_PFB0CR_B0DPE(0)|FMC_PFB0CR_B0IPE(0),  ///< Disabled
      FmcFlashSpeculation_DataOnly              = FMC_PFB0CR_B0DPE(1)|FMC_PFB0CR_B0IPE(0),  ///< Data Only
      FmcFlashSpeculation_InstructionsOnly      = FMC_PFB0CR_B0DPE(0)|FMC_PFB0CR_B0IPE(1),  ///< Instructions Only
      FmcFlashSpeculation_InstructionsAndData   = FMC_PFB0CR_B0DPE(1)|FMC_PFB0CR_B0IPE(1),  ///< Instructions and Data
   };

   /**
    * Bank 0 Flash Controller Cache
    * (fmc_pfb0cr_flash_cache)
    *
    * Controls the operation of the Cache for each Flash Controller bank
    */
   enum FmcFlashCache {
      FmcFlashCache_Disabled              = FMC_PFB0CR_B0DCE(0)|FMC_PFB0CR_B0ICE(0),  ///< Disabled
      FmcFlashCache_DataOnly              = FMC_PFB0CR_B0DCE(1)|FMC_PFB0CR_B0ICE(0),  ///< Data Only
      FmcFlashCache_InstructionsOnly      = FMC_PFB0CR_B0DCE(0)|FMC_PFB0CR_B0ICE(1),  ///< Instructions Only
      FmcFlashCache_InstructionsAndData   = FMC_PFB0CR_B0DCE(1)|FMC_PFB0CR_B0ICE(1),  ///< Instructions and Data
   };

   /**
    * Bank 0 Single Entry Buffer Enable
    * (fmc_pfb0cr_b0sebe)
    *
    * Controls whether the single entry page buffer is enabled in response to flash read accesses.
    * A disabled-to-enabled transition forces the page buffer to be invalidated
    */
   enum FmcPageBuffer {
      FmcPageBuffer_Disabled   = FMC_PFB0CR_B0SEBE(0),  ///< Buffer is disabled
      FmcPageBuffer_Enabled    = FMC_PFB0CR_B0SEBE(1),  ///< Buffer is enabled
   };

class FmcInfo {

public:
   /*
    * Template:fmc_mk10d5
    */
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = FMC_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<FMC_Type> fmc = baseAddress;
   
   /**
    * Set Bank 0 Flash Controller Speculation Buffer
    *
    * @param fmcFlashSpeculation Controls the operation of the Speculation Buffer for each Flash Controller bank
    */
   static void setFlashBank0Speculation(FmcFlashSpeculation fmcFlashSpeculation) {

      fmc->PFB0CR = (fmc->PFB0CR&~((FMC_PFB0CR_B0DPE_MASK|FMC_PFB0CR_B0IPE_MASK))) | fmcFlashSpeculation;
   }

   /**
    **
    * Class used to do initialisation of Flash bank 0 controller
    * Options not explicitly mentioned are cleared to 0.
    *
    * This class has a templated constructor that accepts a range of options
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example1:
    * @code
    * const Fmc::FlashBank0Init flashInit {
    *    // List of options
    *    FmcFlashCache_Disabled,
    *    FmcFlashSpeculation_InstructionsAndData,
    * };
    *
    * flashInit.configure();  // Configure selected options
    * @endcode
    */
   class FlashBank0Init {
   
   private:
      /// Value for pfb0cr register
      uint32_t pfb0cr = 0;
   
   public:
      /**
       * Empty Constructor
       */
      constexpr FlashBank0Init() = default;
   
      /**
       * Copy Constructor
       */
      constexpr FlashBank0Init(const FlashBank0Init &other) = default;
   
      /**
       * Read the current settings from hardware registers
       */
      void readConfig() {
         pfb0cr = fmc->PFB0CR & (FMC_PFB0CR_B0DPE_MASK|FMC_PFB0CR_B0IPE_MASK|FMC_PFB0CR_B0DCE_MASK|FMC_PFB0CR_B0ICE_MASK|FMC_PFB0CR_B0SEBE_MASK);
      }
   
      /**
       * Configure Flash options as specified in the constructor
       */
      void configure() const {
         fmc->PFB0CR = (fmc->PFB0CR & ~(FMC_PFB0CR_B0DPE_MASK|FMC_PFB0CR_B0IPE_MASK|FMC_PFB0CR_B0DCE_MASK|FMC_PFB0CR_B0ICE_MASK|FMC_PFB0CR_B0SEBE_MASK))|
                      pfb0cr;
      }
   
      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param fmcFlashSpeculation Bank 0 Flash Controller Speculation Buffer
       */
      template <typename... Types>
      constexpr FlashBank0Init(FmcFlashSpeculation fmcFlashSpeculation, Types... rest) : FlashBank0Init(rest...)  {
   
         pfb0cr = (pfb0cr&~(FMC_PFB0CR_B0DPE_MASK|FMC_PFB0CR_B0IPE_MASK)) | fmcFlashSpeculation;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param fmcPageBuffer Bank 0 Single Entry Buffer Enable
       */
      template <typename... Types>
      constexpr FlashBank0Init(FmcPageBuffer fmcPageBuffer, Types... rest) : FlashBank0Init(rest...)  {
   
         pfb0cr = (pfb0cr&~FMC_PFB0CR_B0SEBE_MASK) | fmcPageBuffer;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       *
       * @param fmcFlashCache Bank 0 Flash Controller Cache
       */
      template <typename... Types>
      constexpr FlashBank0Init(FmcFlashCache fmcFlashCache, Types... rest) : FlashBank0Init(rest...)  {
   
         pfb0cr = (pfb0cr&~(FMC_PFB0CR_B0DCE_MASK|FMC_PFB0CR_B0ICE_MASK)) | fmcFlashCache;
      }

   }; // FlashBank0Init

}; // class FmcInfo


/**
 * @addtogroup FMC_Group FMC, Flash Memory Controller
 * @brief Abstraction for Miscellaneous Control Module
 * @{
 */
#if false // /FMC/_BasicInfoGuard

/**
 * Template class providing a base for Miscellaneous Control Module
 */
class FmcBase : public FmcInfo {

public:
   /**
    * Default value for FMC::FlashBank0Init
    * This value is created from Configure.usbdmProject settings (Peripheral Parameters->FMC)
    */
   static constexpr FmcInfo::FlashBank0Init DefaultFlashBank0InitValue {
      FmcPageBuffer_Enabled,  // (fmc_pfb0cr_b0sebe)        Bank 0 Single Entry Buffer Enable - Buffer is enabled
   };
   

};

#if false
/**
 * Type definition for FMC interrupt call back
 */
typedef void (*FmcCallbackFunction)();

/**
 * Template class providing interface to Miscellaneous Control Module
 *
 * @tparam info      Information class for FMC
 *
 * @code
 * using fmc = FmcInterrupt_T<FmcInfo>;
 *
 *  fmc::configure();
 *
 * @endcode
 */
template <class Info>
class FmcInterrupt_T {

protected:
   /** Callback function for ISR */
   static FmcCallbackFunction sCallback;

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   /**
    * IRQ handler
    */
   static void irqHandler(void) {
      sCallback();
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match FmcCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Fmc::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Fmc::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static FmcCallbackFunction wrapCallback() {
      static FmcCallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match FmcCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Fmc::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Fmc::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static FmcCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static FmcCallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }

   /**
    * Set Callback function
    *
    *   @param[in]  callback Callback function to be executed on interrupt\n
    *                        Use nullptr to remove callback.
    */
   static void setCallback(FmcCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "FMC not configured for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

public:

   /**
    * Basic enable of FMC\n
    * Includes configuring all pins
    */
   static void enable() {
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }
   
};

template<class Info> FmcCallbackFunction FmcInterrupt_T<Info>::sCallback = FmcInterrupt_T<Info>::unhandledCallback;
#endif

   class Fmc : public FmcBase {};

#endif // /FMC/_BasicInfoGuard
/**
 * End FMC_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_FMC_H */
