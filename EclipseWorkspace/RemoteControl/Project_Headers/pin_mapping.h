/**
 * @file      pin_mapping.h (generated from MK20D5.usbdmHardware)
 * @version   1.3.0
 * @brief     Peripheral declarations for MK20DX128VLF5
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stdint.h>
#include <stddef.h>
#include <array>

#include "derivative.h"
#include "pcr.h"
#include "error.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/* Template:common_settings.xml */
   /**
    * Shared callback to catch unhandled interrupt
    * Only used for callbacks with no parameters
    */
   extern void unhandledCallback();
   
   /**
    * Class used to do vector initialisation
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    */
   template <typename Init, typename CallbackFunction, typename EnumType, size_t NumVectors>
   class InitVectors : public Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr InitVectors(const InitVectors &other) = default;
   
     /**
      * Copy constructor
      *
      * @tparam Types
      * @param rest         Remaining parameters
   
      * @param other   Object to use as default value
      */
     template <typename... Types>
     constexpr InitVectors(const InitVectors &other, Types... rest) : InitVectors(rest...) {
        priorities = other.priorities;
        callbacks  = other.callbacks;
     }
   
      /**
       * Other constructors are inherited
       *
       * @tparam Types
       * @param rest
       */
      template <typename... Types>
      constexpr InitVectors(Types... rest) : Init(rest...) {
      }
   
      /**
       * Initialise Interrupt callbacks
       * (Used when only a single vector)
       *
       * @tparam Types
       * @param rest         Remaining parameters
   
       * @param nvicPriority Priority for the handler
       * @param callback     Callback function to use
       */
      template <typename... Types>
      constexpr InitVectors(CallbackFunction callback, NvicPriority nvicPriority, Types... rest) : InitVectors(rest...) {
         priorities[0]  = nvicPriority;
         callbacks[0]   = callback;
      }
   
      /**
       * Initialise Interrupt callbacks
       * (Used when only a single vector)
       *
       * @tparam Types
       * @param rest         Remaining parameters
   
       * @param nvicPriority Priority for the handler
       * @param callback     Callback function to use
       */
      template <typename... Types>
      constexpr InitVectors(NvicPriority nvicPriority, CallbackFunction callback, Types... rest) : InitVectors(rest...) {
         priorities[0]  = nvicPriority;
         callbacks[0]   = callback;
      }
   
      /**
       * Initialise Interrupt callbacks
       * (Multiple vectors)
       *
       * @tparam Types
       * @param rest         Remaining parameters
   
       * @param irqNum       Interrupt number
       * @param nvicPriority Priority for the handler
       * @param callback     Callback function to use
       */
      template <typename... Types>
      constexpr InitVectors(EnumType irqNum, NvicPriority nvicPriority, CallbackFunction callback, Types... rest) : InitVectors(rest...) {
         priorities[irqNum]  = nvicPriority;
         callbacks[irqNum]   = callback;
      }
   
      /**
       * Information describing the priority and callback function for each interrupt
       */
       std::array<CallbackFunction, NumVectors> callbacks = {};
       std::array<NvicPriority,     NumVectors> priorities = {};
   
   }; // class InitVectors
   
/* Template:common_settings.xml */
   
   /**
    *  Enables mapping of all allocated pins during startup using mapAllPins()
    */
   static constexpr bool MapAllPinsOnStartup = false;
   
   /**
    * Controls forcing all pins to be locked in mapAllPins()
    */
   static constexpr PinLock ForceLockedPins = PinLock_Unlocked;
   
   /**
    *  Enables forcing unbonded pins to analogue function in mapAllPins()
    */
   static constexpr bool ForceLockoutUnbondedPins = false;
   
// Use when in-lining makes the release build smaller
#ifdef DEBUG_BUILD
#define INLINE_RELEASE __attribute__((noinline))
#else
#define INLINE_RELEASE __attribute__((always_inline))
#endif

#ifdef DEBUG_BUILD
#define NOINLINE_DEBUG __attribute__((noinline))
#else
#define NOINLINE_DEBUG
#endif

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, unsigned offset) {
      return static_cast<IRQn_Type>(static_cast<unsigned>(vector) + offset);
   }

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, int offset) {
      return vector + static_cast<unsigned>(offset);
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Smaller of a or b
    */
   template<class T>
   constexpr T min(const T a, const T b) {
      return (b < a) ? b : a;
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Larger of a or b
    */
   template<class T>
   constexpr T max(const T a, const T b) {
      return (b > a) ? b : a;
   }

   constexpr IRQn_Type IRQn_None = static_cast<IRQn_Type>(-20);

   /**
    * Determine the number of elements in an array
    *
    * @tparam T      Deduced array type
    * @tparam N      Deduced array size
    *
    * @return  Size of array in elements
    */
   template<typename T, size_t N>
      constexpr size_t sizeofArray(T (&)[N]) {
         return N;
      }

   /**
    * Enter critical section
    *
    * Disables interrupts for a critical section
    *
    * @param cpuSR Variable to hold interrupt state so it can be restored
    *
    * @code
    * uint8_t cpuSR;
    * ...
    * enterCriticalSection(cpuSR);
    *  // Critical section
    * exitCriticalSection(cpuSR);
    * @endcode
    */
   static inline void enterCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  MRS   r0, PRIMASK       \n"   // Copy flags
            // It may be possible for a ISR to run here but it
            // would save/restore PRIMASK so this code is OK
            "  CPSID I                 \n"   // Disable interrupts
            "  STRB  r0, %[output]     \n"   // Save flags
            : [output] "=m" (cpuSR) : : "r0");
   }

   /**
    * Exit critical section
    *
    * Restores interrupt state saved by enterCriticalSection()
    *
    * @param cpuSR Variable to holding interrupt state to be restored
    */
   static inline void exitCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  LDRB r0, %[input]    \n"  // Retrieve original flags
            "  MSR  PRIMASK,r0;     \n"  // Restore
            : :[input] "m" (cpuSR) : "r0");
   }

   /**
    * Class to implement simple critical sections by disabling interrupts.
    *
    * Disables interrupts for a critical section.
    * This would be from the declaration of the object until the end of
    * enclosing block. An object of this class should be declared at the
    * start of a block. e.g.
    * @code
    *    {
    *       CriticalSection cs;
    *       ...
    *       Protected code
    *       ...
    *    }
    * @endcode
    *
    * @note uses PRIMASK
    */
   class CriticalSection {
   
   private:
      /** Used to record interrupt state on entry */
      volatile uint32_t cpuSR;
   
   public:
      /**
       * Constructor - Enter critical section
       *
       * Disables interrupts for a critical section
       * This would be from the declaration of the object until end of enclosing block.
       */
      CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  MRS   r0, PRIMASK       \n"   // Copy flags
               // It may be possible for a ISR to run here but it
               // would save/restore PRIMASK so this code is OK
               "  CPSID I                 \n"   // Disable interrupts
               "  STR  r0, %[output]      \n"   // Save flags
               : [output] "=m" (cpuSR) : : "r0");
      }
   
      /**
       * Destructor - Exit critical section
       *
       * Enables interrupts IFF previously disabled by this object
       * This would be done implicitly by exiting the enclosing block.
       */
      inline ~CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  LDR r0, %[input]     \n"  // Retrieve original flags
               "  MSR  PRIMASK,r0;     \n"  // Restore
               : :[input] "m" (cpuSR) : "r0");
      }
   };
/* END Template:common_settings.xml */

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioAInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 20;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: GPIOA_0              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: GPIOA_1              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: GPIOA_2              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   3: GPIOA_3              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: GPIOA_4              = PTA4(p21)                      */  { PinIndex::PTA4,         PcrValue(0x00100UL) },
         /*   5: GPIOA_5              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   6: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   7: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   8: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   9: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  10: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  11: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  12: GPIOA_12             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  13: GPIOA_13             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  14: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  15: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  16: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  17: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  18: GPIOA_18             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  19: GPIOA_19             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK);
      PORTA->GPCLR = (0x0100UL|PORT_GPCLR_GPWE(0x0010UL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK);
      PORTA->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0010UL);
   }

   /*
    * Template:gpioa_0x400ff000
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with GPIOA
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with GPIOA
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   /**
    * Basic enable of GpioA
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      configureAllPins();
   }
   
   /**
    * Disables GpioA
    */
   static void disable() {
   
      
      disableAllPins();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = GPIOA_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<GPIO_Type> gpio = baseAddress;
   
   //! Class based callback handler has been installed in vector table for this instance
   static constexpr bool irqHandlerInstalled = false;
   
}; // class GpioAInfo

/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioBInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 20;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: GPIOB_0              = PTB0(p27)                      */  { PinIndex::PTB0,         PcrValue(0x00100UL) },
         /*   1: GPIOB_1              = PTB1(p28)                      */  { PinIndex::PTB1,         PcrValue(0x00100UL) },
         /*   2: GPIOB_2              = PTB2(p29)                      */  { PinIndex::PTB2,         PcrValue(0x00100UL) },
         /*   3: GPIOB_3              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   5: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   6: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   7: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   8: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   9: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  10: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  11: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  12: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  13: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  14: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  15: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  16: GPIOB_16             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  17: GPIOB_17             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  18: GPIOB_18             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  19: GPIOB_19             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTB_CLOCK_MASK);
      PORTB->GPCLR = (0x0100UL|PORT_GPCLR_GPWE(0x0007UL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTB_CLOCK_MASK);
      PORTB->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0007UL);
   }

   /*
    * Template:gpioa_0x400ff000
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with GPIOB
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with GPIOB
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   /**
    * Basic enable of GpioB
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      configureAllPins();
   }
   
   /**
    * Disables GpioB
    */
   static void disable() {
   
      
      disableAllPins();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = GPIOB_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<GPIO_Type> gpio = baseAddress;
   
   //! Class based callback handler has been installed in vector table for this instance
   static constexpr bool irqHandlerInstalled = false;
   
}; // class GpioBInfo

/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioCInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 12;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: GPIOC_0              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: GPIOC_1              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: GPIOC_2              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   3: GPIOC_3              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: GPIOC_4              = PTC4(p37)                      */  { PinIndex::PTC4,         PcrValue(0x00100UL) },
         /*   5: GPIOC_5              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   6: GPIOC_6              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   7: GPIOC_7              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   8: GPIOC_8              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   9: GPIOC_9              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  10: GPIOC_10             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  11: GPIOC_11             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTC_CLOCK_MASK);
      PORTC->GPCLR = (0x0100UL|PORT_GPCLR_GPWE(0x0010UL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTC_CLOCK_MASK);
      PORTC->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0010UL);
   }

   /*
    * Template:gpioa_0x400ff000
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with GPIOC
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with GPIOC
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   /**
    * Basic enable of GpioC
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      configureAllPins();
   }
   
   /**
    * Disables GpioC
    */
   static void disable() {
   
      
      disableAllPins();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = GPIOC_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<GPIO_Type> gpio = baseAddress;
   
   //! Class based callback handler has been installed in vector table for this instance
   static constexpr bool irqHandlerInstalled = false;
   
}; // class GpioCInfo

/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioDInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: GPIOD_0              = PTD0(p41)                      */  { PinIndex::PTD0,         PcrValue(0x00100UL) },
         /*   1: GPIOD_1              = PTD1(p42)                      */  { PinIndex::PTD1,         PcrValue(0x00100UL) },
         /*   2: GPIOD_2              = PTD2(p43)                      */  { PinIndex::PTD2,         PcrValue(0x00100UL) },
         /*   3: GPIOD_3              = PTD3(p44)                      */  { PinIndex::PTD3,         PcrValue(0x00100UL) },
         /*   4: GPIOD_4              = PTD4(p45)                      */  { PinIndex::PTD4,         PcrValue(0x00100UL) },
         /*   5: GPIOD_5              = PTD5(p46)                      */  { PinIndex::PTD5,         PcrValue(0x00100UL) },
         /*   6: GPIOD_6              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   7: GPIOD_7              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTD_CLOCK_MASK);
      PORTD->GPCLR = (0x0100UL|PORT_GPCLR_GPWE(0x003FUL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTD_CLOCK_MASK);
      PORTD->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x003FUL);
   }

   /*
    * Template:gpioa_0x400ff000
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with GPIOD
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with GPIOD
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   /**
    * Basic enable of GpioD
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      configureAllPins();
   }
   
   /**
    * Disables GpioD
    */
   static void disable() {
   
      
      disableAllPins();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = GPIOD_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<GPIO_Type> gpio = baseAddress;
   
   //! Class based callback handler has been installed in vector table for this instance
   static constexpr bool irqHandlerInstalled = true;
   
}; // class GpioDInfo

/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioEInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: GPIOE_0              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: GPIOE_1              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:gpioa_0x400ff000
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with GPIOE
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with GPIOE
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   /**
    * Basic enable of GpioE
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      configureAllPins();
   }
   
   /**
    * Disables GpioE
    */
   static void disable() {
   
      
      disableAllPins();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = GPIOE_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<GPIO_Type> gpio = baseAddress;
   
   //! Class based callback handler has been installed in vector table for this instance
   static constexpr bool irqHandlerInstalled = false;
   
}; // class GpioEInfo

/** 
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Abstraction for Crystal Oscillator
 * @{
 */
/**
 * Peripheral information for OSC, Crystal Oscillator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * External Reference Enable
    * (osc_cr_erclken)
    *
    * Enables the OSC clock [OSCERCLK] for use by peripherals
    * The oscillator will also be enabled if used by MCG
    */
   enum OscErClkEn {
      OscErClkEn_Disabled   = OSC_CR_ERCLKEN(0),  ///< Disabled
      OscErClkEn_Enabled    = OSC_CR_ERCLKEN(1),  ///< Enabled
   };

   /**
    * Oscillator load capacitance
    * (osc_cr_scp)
    *
    * Configures the oscillator load capacitance
    */
   enum OscCap {
      OscCap_None   = OSC_CR_SCP(0),   ///< 0 pF
      OscCap_2pf    = OSC_CR_SCP(8),   ///< 2 pF
      OscCap_4pf    = OSC_CR_SCP(4),   ///< 4 pF
      OscCap_6pf    = OSC_CR_SCP(12),  ///< 6 pF
      OscCap_8pf    = OSC_CR_SCP(2),   ///< 8 pF
      OscCap_10pf   = OSC_CR_SCP(10),  ///< 10 pF
      OscCap_12pf   = OSC_CR_SCP(6),   ///< 12 pF
      OscCap_14pf   = OSC_CR_SCP(14),  ///< 14 pF
      OscCap_16pf   = OSC_CR_SCP(1),   ///< 16 pF
      OscCap_18pf   = OSC_CR_SCP(9),   ///< 18 pF
      OscCap_20pf   = OSC_CR_SCP(5),   ///< 20 pF
      OscCap_22pf   = OSC_CR_SCP(13),  ///< 22 pF
      OscCap_24pf   = OSC_CR_SCP(3),   ///< 24 pF
      OscCap_26pf   = OSC_CR_SCP(11),  ///< 26 pF
      OscCap_28pf   = OSC_CR_SCP(7),   ///< 28 pF
      OscCap_30pf   = OSC_CR_SCP(15),  ///< 30 pF
   };

   /**
    * External Reference Stop Enable
    * (osc_cr_erefsten)
    *
    * Determines if external reference clock is enabled in Stop mode
    */
   enum OscExternalRef {
      OscExternalRef_DisabledInStop   = OSC_CR_EREFSTEN(0),  ///< Disabled in Stop mode
      OscExternalRef_EnabledInStop    = OSC_CR_EREFSTEN(1),  ///< Enabled in Stop mode
   };

class OscBasicInfo {

public:
   /**
    * Class used to do initialisation of the Osc
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Osc0::Init osc0Init {
    *
    *   // Setup values
    *   OscErClkEn_Enabled ,            // External Reference Enable - Enabled
    *   OscExternalRef_DisabledInStop , // External Reference Stop Enable - Disabled in Stop mode
    *   OscCap_8pf,                     // Oscillator load capacitance - 8 pF
    * };
    *
    * // Initialise Osc0 from values specified above
    * Osc0::configure(osc0Init)
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /// Control Register
      uint8_t cr = 0;

      /**
       * Constructor for External Reference Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param oscErClkEn Enables the OSC clock [OSCERCLK] for use by peripherals
       *        The oscillator will also be enabled if used by MCG
       */
      template <typename... Types>
      constexpr Init(OscErClkEn oscErClkEn, Types... rest) : Init(rest...) {
   
         cr = (cr&~OSC_CR_ERCLKEN_MASK) | oscErClkEn;
      }
   
      /**
       * Constructor for External Reference Stop Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param oscExternalRef Determines if external reference clock is enabled in Stop mode
       */
      template <typename... Types>
      constexpr Init(OscExternalRef oscExternalRef, Types... rest) : Init(rest...) {
   
         cr = (cr&~OSC_CR_EREFSTEN_MASK) | oscExternalRef;
      }
   
      /**
       * Constructor for Oscillator load capacitance
       *
       * @tparam   Types
       * @param    rest
       *
       * @param oscCap Configures the oscillator load capacitance
       */
      template <typename... Types>
      constexpr Init(OscCap oscCap, Types... rest) : Init(rest...) {
   
         cr = (cr&~OSC_CR_SCP_MASK) | oscCap;
      }
   
   }; // class OscBasicInfo::Init
   
}; // class OscBasicInfo 

class Osc0Info : public OscBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: XTAL0                = PTA19(p25)                     */  { PinIndex::PTA19,        PcrValue(0x00000UL) },
         /*   1: EXTAL0               = PTA18(p24)                     */  { PinIndex::PTA18,        PcrValue(0x00000UL) },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK);
      PORTA->GPCHR = (0x0000UL|PORT_GPCHR_GPWE(0x000CUL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK);
      PORTA->GPCHR = uint32_t(PinMux_Disabled)|PORT_GPCHR_GPWE(0x000CUL);
   }

   /*
    * Template:osc0_mk
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with OSC0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with OSC0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   /**
    * Basic enable of Osc0
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      configureAllPins();
   }
   
   /**
    * Disables Osc0
    */
   static void disable() {
   
      
      disableAllPins();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = OSC0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<OSC_Type> osc = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t osc_clock = 
      8000000_Hz;  // (osc_clock)                Frequency of OSC Clock or Crystal [OSCCLK]
   
   //! Frequency of 32K OSC Clock or Crystal (if applicable)
   static constexpr uint32_t osc32k_clock = 
      0_Hz;  // (osc32k_clock)             Oscillator low range 32K clock [OSC32KCLK]
   
   /**
    * Set External Reference Enable
    *
    * @param oscErClkEn Enables the OSC clock [OSCERCLK] for use by peripherals
    *        The oscillator will also be enabled if used by MCG
    */
   static void setExternalReference(OscErClkEn oscErClkEn) {
      osc->CR = (osc->CR&~OSC_CR_ERCLKEN_MASK) | oscErClkEn;
   }
   
   /**
    * Get External Reference Enable
    *
    * @return Enables the OSC clock [OSCERCLK] for use by peripherals
    *        The oscillator will also be enabled if used by MCG
    */
   static OscErClkEn getExternalReference() {
      return OscErClkEn(osc->CR&OSC_CR_ERCLKEN_MASK);
   }
   
   /**
    * Get OSC clock (internal, assumed available)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static constexpr uint32_t getOscClock() {
      return osc_clock;
   }

   /**
    * Get OSC clock (external, gated by OSC_CR_ERCLKEN)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOscerClock() {
      return (osc->CR&OSC_CR_ERCLKEN_MASK)?osc_clock:0;
   }

   /**
    * Get OSC32KCLK clock
    *
    * @return Clock frequency as uint32_t in Hz
   
    * @note This clock is only available if a 32kHz crystal or external clock is used
    */
   static uint32_t getOsc32kClock() {
      return osc32k_clock;
   }

   /**
    * Default initialisation value for Osc0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      OscErClkEn_Enabled , // (osc_cr_erclken)           External Reference Enable - Enabled
      OscCap_8pf,  // (osc_cr_scp)               Oscillator load capacitance - 8 pF
   };
   
}; // class Osc0Info

/** 
 * End group OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */
/**
 * Peripheral information for RTC, Real Time Clock.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Enable RTC oscillator
    * (rtc_cr_osce)
    *
    * Enable 32kHz RTC oscillator
    */
   enum RtcOscEnable : uint16_t {
      RtcOscEnable_Disabled   = RTC_CR_OSCE(0),  ///< Disabled
      RtcOscEnable_Enabled    = RTC_CR_OSCE(1),  ///< Enabled
   };

   /**
    * Enable RTC 32kHz Clock Output
    * (rtc_cr_clko)
    *
    * Determines if RTC 32kHz Clock is available to peripherals
    */
   enum RtcClockOut : uint16_t {
      RtcClockOut_Disabled   = RTC_CR_CLKO(1),  ///< Clock not output to peripherals
      RtcClockOut_Enabled    = RTC_CR_CLKO(0),  ///< Clock is output to peripherals
   };

   /**
    * Oscillator load capacitance
    * (rtc_cr_scp)
    *
    * Configures the oscillator load capacitance
    */
   enum RtcOscLoadCap : uint16_t {
      RtcOscLoadCap_None   = RTC_CR_SCP(0),   ///< 0 pF
      RtcOscLoadCap_2pf    = RTC_CR_SCP(8),   ///< 2 pF
      RtcOscLoadCap_4pf    = RTC_CR_SCP(4),   ///< 4 pF
      RtcOscLoadCap_6pf    = RTC_CR_SCP(12),  ///< 6 pF
      RtcOscLoadCap_8pf    = RTC_CR_SCP(2),   ///< 8 pF
      RtcOscLoadCap_10pf   = RTC_CR_SCP(10),  ///< 10 pF
      RtcOscLoadCap_12pf   = RTC_CR_SCP(6),   ///< 12 pF
      RtcOscLoadCap_14pf   = RTC_CR_SCP(14),  ///< 14 pF
      RtcOscLoadCap_16pf   = RTC_CR_SCP(1),   ///< 16 pF
      RtcOscLoadCap_18pf   = RTC_CR_SCP(9),   ///< 18 pF
      RtcOscLoadCap_20pf   = RTC_CR_SCP(5),   ///< 20 pF
      RtcOscLoadCap_22pf   = RTC_CR_SCP(13),  ///< 22 pF
      RtcOscLoadCap_24pf   = RTC_CR_SCP(3),   ///< 24 pF
      RtcOscLoadCap_26pf   = RTC_CR_SCP(11),  ///< 26 pF
      RtcOscLoadCap_28pf   = RTC_CR_SCP(7),   ///< 28 pF
      RtcOscLoadCap_30pf   = RTC_CR_SCP(15),  ///< 30 pF
   };

   /**
    * Time Counter Enable Update Mode
    * (rtc_cr_um)
    *
    * Allows the time counter to be enabled even when the Status Register is locked.
    * This allows the timer enable (SR[TCE]) value to be modified if:
    * - Timer not yet enabled (SR[TCE] clear)
    * - Time value is invalid (SR[TIF] set)
    * - Timer has overflowed (SR[TOF] set)
    */
   enum RtcTimeCounterEnableUpdate : uint16_t {
      RtcTimeCounterEnableUpdate_Prevented   = RTC_CR_UM(0),  ///< Timer enable can not be modified when locked
      RtcTimeCounterEnableUpdate_Allowed     = RTC_CR_UM(1),  ///< Timer can be modified under limited conditions
   };

   /**
    * Supervisor access
    * (rtc_cr_sup)
    *
    * Determines if the RTC register access is available in non-supervisor mode 
    * Non supported write accesses generate a bus error
    */
   enum RtcUserWriteAccess : uint16_t {
      RtcUserWriteAccess_Prevented   = RTC_CR_SUP(0),  ///< Non-supervisor write accesses not supported
      RtcUserWriteAccess_Allowed     = RTC_CR_SUP(1),  ///< Non-supervisor write accesses supported
   };

   /**
    * Lock Register Lock
    * (rtc_lr_lrl)
    *
    * Once cleared, this bit can only be set by VBAT POR or software reset
    */
   enum RtcLockRegLock : uint8_t {
      RtcLockRegLock_Locked     = RTC_LR_LRL(0),  ///< Locked
      RtcLockRegLock_Unlocked   = RTC_LR_LRL(1),  ///< Unlocked
   };

   /**
    * Status Register Lock
    * (rtc_lr_srl)
    *
    * Once cleared, this bit can only be set by VBAT POR or software reset
    */
   enum RtcStatusRegLock : uint8_t {
      RtcStatusRegLock_Locked     = RTC_LR_SRL(0),  ///< Locked
      RtcStatusRegLock_Unlocked   = RTC_LR_SRL(1),  ///< Unlocked
   };

   /**
    * Control Register Lock
    * (rtc_lr_crl)
    *
    * Once cleared, this bit can only be set by VBAT POR or software reset
    */
   enum RtcControlRegLock : uint8_t {
      RtcControlRegLock_Locked     = RTC_LR_CRL(0),  ///< Locked
      RtcControlRegLock_Unlocked   = RTC_LR_CRL(1),  ///< Unlocked
   };

   /**
    * Time Compensation Lock
    * (rtc_lr_tcl)
    *
    * Once cleared, this bit can only be set by VBAT POR or software reset
    */
   enum RtcTimeCompensationRegLock : uint8_t {
      RtcTimeCompensationRegLock_Locked     = RTC_LR_TCL(0),  ///< Locked
      RtcTimeCompensationRegLock_Unlocked   = RTC_LR_TCL(1),  ///< Unlocked
   };

   /**
    * Interrupt Enable Register Write
    * (rtc_war_ierw)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcWarIerw : uint8_t {
      RtcWarIerw_WritesIgnored   = RTC_WAR_IERW(0),  ///< Writes ignored
      RtcWarIerw_WritesAllowed   = RTC_WAR_IERW(1),  ///< Writes allowed
   };

   /**
    * Lock Register Write
    * (rtc_war_lrw)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcWarLrw : uint8_t {
      RtcWarLrw_WritesIgnored   = RTC_WAR_LRW(0),  ///< Writes ignored
      RtcWarLrw_WritesAllowed   = RTC_WAR_LRW(1),  ///< Writes allowed
   };

   /**
    * Status Register Write
    * (rtc_war_srw)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcWarSrw : uint8_t {
      RtcWarSrw_WritesIgnored   = RTC_WAR_SRW(0),  ///< Writes ignored
      RtcWarSrw_WritesAllowed   = RTC_WAR_SRW(1),  ///< Writes allowed
   };

   /**
    * Control Register Write
    * (rtc_war_crw)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcWarCrw {
      RtcWarCrw_WritesIgnored   = RTC_WAR_CRW(0),  ///< Writes ignored
      RtcWarCrw_WritesAllowed   = RTC_WAR_CRW(1),  ///< Writes allowed
   };

   /**
    * Time Compensation Register Write
    * (rtc_war_tcrw)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcWarTcrw : uint8_t {
      RtcWarTcrw_WritesIgnored   = RTC_WAR_TCRW(0),  ///< Writes ignored
      RtcWarTcrw_WritesAllowed   = RTC_WAR_TCRW(1),  ///< Writes allowed
   };

   /**
    * Time Alarm Register Write
    * (rtc_war_tarw)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcWarTarw : uint8_t {
      RtcWarTarw_WritesIgnored   = RTC_WAR_TARW(0),  ///< Writes ignored
      RtcWarTarw_WritesAllowed   = RTC_WAR_TARW(1),  ///< Writes allowed
   };

   /**
    * Time Prescaler Register Write
    * (rtc_war_tprw)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcWarTprw : uint8_t {
      RtcWarTprw_WritesIgnored   = RTC_WAR_TPRW(0),  ///< Writes ignored
      RtcWarTprw_WritesAllowed   = RTC_WAR_TPRW(1),  ///< Writes allowed
   };

   /**
    * Time Seconds Register Write
    * (rtc_war_tsrw)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcWarTsrw : uint8_t {
      RtcWarTsrw_WritesIgnored   = RTC_WAR_TSRW(0),  ///< Writes ignored
      RtcWarTsrw_WritesAllowed   = RTC_WAR_TSRW(1),  ///< Writes allowed
   };

   /**
    * Interrupt Enable Register Read
    * (rtc_rar_ierr)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcRarIerr : uint8_t {
      RtcRarIerr_ReadsIgnored   = RTC_RAR_IERR(0),  ///< Reads ignored
      RtcRarIerr_ReadsAllowed   = RTC_RAR_IERR(1),  ///< Reads Allowed
   };

   /**
    * Lock Register Read
    * (rtc_rar_lrr)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcRarLrr : uint8_t {
      RtcRarLrr_ReadsIgnored   = RTC_RAR_LRR(0),  ///< Reads ignored
      RtcRarLrr_ReadsAllowed   = RTC_RAR_LRR(1),  ///< Reads Allowed
   };

   /**
    * Status Register Read
    * (rtc_rar_srr)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcRarSrr : uint8_t {
      RtcRarSrr_ReadsIgnored   = RTC_RAR_SRR(0),  ///< Reads ignored
      RtcRarSrr_ReadsAllowed   = RTC_RAR_SRR(1),  ///< Reads Allowed
   };

   /**
    * Control Register Read
    * (rtc_rar_crr)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcRarCrr : uint8_t {
      RtcRarCrr_ReadsIgnored   = RTC_RAR_CRR(0),  ///< Reads ignored
      RtcRarCrr_ReadsAllowed   = RTC_RAR_CRR(1),  ///< Reads Allowed
   };

   /**
    * Time Compensation Register Read
    * (rtc_rar_tcrr)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcRarTcrr : uint8_t {
      RtcRarTcrr_ReadsIgnored   = RTC_RAR_TCRR(0),  ///< Reads ignored
      RtcRarTcrr_ReadsAllowed   = RTC_RAR_TCRR(1),  ///< Reads Allowed
   };

   /**
    * Time Alarm Register Read
    * (rtc_rar_tarr)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcRarTarr : uint8_t {
      RtcRarTarr_ReadsIgnored   = RTC_RAR_TARR(0),  ///< Reads ignored
      RtcRarTarr_ReadsAllowed   = RTC_RAR_TARR(1),  ///< Reads Allowed
   };

   /**
    * Time Prescaler Register Read
    * (rtc_rar_tprr)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcRarTprr : uint8_t {
      RtcRarTprr_ReadsIgnored   = RTC_RAR_TPRR(0),  ///< Reads ignored
      RtcRarTprr_ReadsAllowed   = RTC_RAR_TPRR(1),  ///< Reads Allowed
   };

   /**
    * Time Seconds Register Read
    * (rtc_rar_tsrr)
    *
    * Once cleared, this bit is only set by system reset.
    * It is not affected by VBAT POR or software reset
    */
   enum RtcRarTsrr : uint8_t {
      RtcRarTsrr_ReadsIgnored   = RTC_RAR_TSRR(0),  ///< Reads ignored
      RtcRarTsrr_ReadsAllowed   = RTC_RAR_TSRR(1),  ///< Reads Allowed
   };

   /**
    * Time in Seconds
    * (rtc_tsr_tsr)
    *
    * When the time counter is enabled, the TSR is read only and increments once a second
    * provided SR[TOF] or SR[TIF] are not set.
    * The time counter will read as zero when SR[TOF] or SR[TIF] are set.
    * When the time counter is disabled, the TSR can be read or written.
    * Writing to the TSR when the time counter is disabled will clear the 
    * SR[TOF] and/or the SR[TIF]. 
    * Writing to TSR with zero is supported, but not recommended because
    * TSR will read as zero when SR[TIF] or SR[TOF] are set (indicates time is invalid).
    */
   enum RtcTime : uint32_t {
   };

   /**
    * Alarm time in seconds
    * (rtc_tar_tar)
    *
    * When the time counter is enabled, the SR[TAF] is set whenever the TAR[TAR]
    * equals the TSR[TSR] and the TSR[TSR] increments. Writing to the TAR clears the SR[TAF].
    */
   enum RtcAlarm : uint32_t {
   };

   /**
    * Time Compensation Value
    * (rtc_tcr_tcr)
    *
    * Adjusts the number of 32.768 kHz clock cycles in each second.
    * This value+32768 determines the number of clock cycles that makes up a second
    */
   enum RtcCompensationValue : int16_t {
   };

   /**
    * Timer Compensation Interval
    * (rtc_tcr_cir)
    *
    * Configures the compensation interval that controls how frequently the Time Compensation value 
    * is applied to alter the number of 32.768 kHz cycles in each second. 
    * This register is double buffered and writes do not take affect until the end of the current compensation 
    * interval
    */
   enum RtcCompensationInterval : uint16_t {
   };

   /**
    * Time Prescaler Register
    * (rtc_tpr_tpr)
    *
    * When the time counter is enabled, the TPR is read only and increments every 32.768 kHz clock cycle.
    * The time counter will read as zero when SR[TOF] or SR[TIF] are set.
    * When the time counter is disabled, the TPR can be read or written.
    * The TSR[TSR] increments when bit 14 of the TPR transitions from a logic one to a logic zero.
    */
   enum RtcPrescale : uint16_t {
   };

   /**
    * Compensation Interval Counter
    * (rtc_tcr_cic)
    *
    * Current value of the compensation interval counter
    */
   enum RtcCompensation : uint32_t {
   };

   /**
    * Software Reset
    * (rtc_cr_swr)
    *
    * Resets all RTC registers except for the SWR bit and the RTC_WAR and RTC_RAR registers.
    * The SWR bit is cleared by VBAT POR and by software explicitly clearing it
    */
   enum RtcSoftwareReset : uint16_t {
      RtcSoftwareReset_NoEffect   = RTC_CR_SWR(0),  ///< No effect
      RtcSoftwareReset_Assert     = RTC_CR_SWR(1),  ///< Reset RTC apart from (SWR, WAR, RAR)
   };

   /**
    * Time Counter Enable
    * (rtc_sr_tce)
    *
    * When disabled the TSR register and TPR register are writeable, but do not increment.
    * When enabled the TSR register and TPR register are not writeable, but increment.
    */
   enum RtcCounterEnable : uint8_t {
      RtcCounterEnable_Disabled   = RTC_SR_TCE(0),  ///< Disabled, TSR and TPR writeable
      RtcCounterEnable_Enabled    = RTC_SR_TCE(1),  ///< Enabled, TSR and TPR increment
   };

   /**
    * Time Alarm Flag
    * (rtc_sr_taf)
    *
    * Set when alarm time reached
    */
   enum RtcTimeAlarmFlag : uint8_t {
      RtcTimeAlarmFlag_NoAlarm         = RTC_SR_TAF(0),  ///< No alarm
      RtcTimeAlarmFlag_AlarmOccurred   = RTC_SR_TAF(1),  ///< Alarm occurred
   };

   /**
    * Time Overflow Flag
    * (rtc_sr_tof)
    *
    * Indicates time overflow has occurred
    */
   enum RtcTimerOverflowFlag : uint8_t {
      RtcTimerOverflowFlag_NoOverflow   = RTC_SR_TOF(0),  ///< No overflow
      RtcTimerOverflowFlag_Overflow     = RTC_SR_TOF(1),  ///< Overflow
   };

   /**
    * Time Invalid Flag
    * (rtc_sr_tif)
    *
    * Indicates if the time is valid
    */
   enum RtcTimeInvalidFlag : uint8_t {
      RtcTimeInvalidFlag_Valid     = RTC_SR_TIF(0),  ///< Valid
      RtcTimeInvalidFlag_Invalid   = RTC_SR_TIF(1),  ///< Invalid
   };

   /**
    * Time Seconds Interrupt Enable
    * (rtc_ier_tsie)
    *
    * The seconds interrupt is an edge-sensitive interrupt with a dedicated interrupt vector.
    * It is generated once a second and requires no software overhead
    * (there is no corresponding status flag to clear).
    */
   enum RtcSecondsAction : uint8_t {
      RtcSecondsAction_None        = RTC_IER_TSIE(0),  ///< Masked
      RtcSecondsAction_Interrupt   = RTC_IER_TSIE(1),  ///< Enabled
   };

   /**
    * Time Alarm Interrupt Enable
    * (rtc_ier_taie)
    *
    * Interrupt enable for Alarm
    */
   enum RtcAlarmAction : uint8_t {
      RtcAlarmAction_None        = RTC_IER_TAIE(0),  ///< Masked
      RtcAlarmAction_Interrupt   = RTC_IER_TAIE(1),  ///< Enabled
   };

   /**
    * Time Overflow Interrupt Enable
    * (rtc_ier_toie)
    *
    * Interrupt enable for overflow
    */
   enum RtcOverflowAction : uint8_t {
      RtcOverflowAction_None        = RTC_IER_TOIE(0),  ///< Masked
      RtcOverflowAction_Interrupt   = RTC_IER_TOIE(1),  ///< Enabled
   };

   /**
    * Time Invalid Interrupt Enable
    * (rtc_ier_tiie)
    *
    * Interrupt enable for time valule invalid
    */
   enum RtcTimeInvalidAction : uint8_t {
      RtcTimeInvalidAction_None        = RTC_IER_TIIE(0),  ///< Masked
      RtcTimeInvalidAction_Interrupt   = RTC_IER_TIIE(1),  ///< Enabled
   };

   /**
    * Wake-up Pin Enable
    * (rtc_cr_wpe)
    *
    * Determines if the wake-up pin is asserted on RTC interrupt when powered down. 
    * The wake-up pin is optional and not available on all devices
    */
   enum RtcWakeupPin : uint16_t {
      RtcWakeupPin_Disabled   = RTC_CR_WPE(0),  ///< Wake-up pin is disabled
      RtcWakeupPin_Enabled    = RTC_CR_WPE(1),  ///< Wake-up pin is enabled
   };

class RtcBasicInfo {

public:
}; // class RtcBasicInfo 

class RtcInfo : public RtcBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: XTAL32               = XTAL32(p14)                    */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   1: EXTAL32              = EXTAL32(p15)                   */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   2: RTC_CLKOUT           = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:rtc_war_rar_tsie
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with RTC
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with RTC
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = RTC_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * IRQ entry
    * (irq_enum)
    *
    * Select amongst interrupts associated with the peripheral
    */
   enum IrqNum {
      IrqNum_Alarm     = 0,  ///< Maps to RTC_Alarm_IRQn
      IrqNum_Seconds   = 1,  ///< Maps to RTC_Seconds_IRQn
   };

   /**
    * Enable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum) {
      NVIC_EnableIRQ(irqNums[irqNum]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum, NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[irqNum], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void disableNvicInterrupts(IrqNum irqNum) {
      NVIC_DisableIRQ(irqNums[irqNum]);
   }
   
   /**
    *  Enable clock to Rtc
    */
   static void enableClock() {
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_RTC_MASK;
   }
   
   /**
    *  Disable clock to Rtc
    */
   static void disableClock() {
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_RTC_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = RTC_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<RTC_Type> rtc = baseAddress;
   
   //! RTC Read Access Register
   static constexpr uint32_t rar = 
      RtcRarIerr_ReadsAllowed |    // (rtc_rar_ierr)             Interrupt Enable Register Read - Reads Allowed
      RtcRarLrr_ReadsAllowed |     // (rtc_rar_lrr)              Lock Register Read - Reads Allowed
      RtcRarSrr_ReadsAllowed |     // (rtc_rar_srr)              Status Register Read - Reads Allowed
      RtcRarCrr_ReadsAllowed |     // (rtc_rar_crr)              Control Register Read - Reads Allowed
      RtcRarTcrr_ReadsAllowed |    // (rtc_rar_tcrr)             Time Compensation Register Read - Reads Allowed
      RtcRarTarr_ReadsAllowed |    // (rtc_rar_tarr)             Time Alarm Register Read - Reads Allowed
      RtcRarTprr_ReadsAllowed |    // (rtc_rar_tprr)             Time Prescaler Register Read - Reads Allowed
      RtcRarTsrr_ReadsAllowed;     // (rtc_rar_tsrr)             Time Seconds Register Read - Reads Allowed
   
   
   //! Frequency of RTC External Clock or Crystal
   static constexpr uint32_t osc_input_freq = 32768UL;
   
   /**
    * Get RTC clock frequency (internal, not masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getInternalClock() {
      return (rtc->CR&RTC_CR_OSCE_MASK)?osc_input_freq:0;
   }

   /**
    * Get RTC clock frequency (external, masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getExternalClock() {
      return (rtc->CR&RTC_CR_CLKO_MASK)?0:getInternalClock();
   }
   
   /**
    * Set Time Counter Enable
    * (rtc_sr_tce)
    *
    * @param rtcCounterEnable When disabled the TSR register and TPR register are writeable, but do not increment.
    *        When enabled the TSR register and TPR register are not writeable, but increment.
    */
   static void setTimeCounterEnable(RtcCounterEnable rtcCounterEnable) {
      rtc->SR = (rtc->SR&~RTC_SR_TCE_MASK) | rtcCounterEnable;
   }
   
   /**
    * Get Time Counter Enable
    * (rtc_sr_tce)
    *
    * @return When disabled the TSR register and TPR register are writeable, but do not increment.
    *        When enabled the TSR register and TPR register are not writeable, but increment.
    */
   static RtcCounterEnable getTimeCounterEnable() {
      return RtcCounterEnable(rtc->SR&RTC_SR_TCE_MASK);
   }
   
   /**
    * Get Time Alarm Flag
    * (rtc_sr_taf)
    *
    * @return Set when alarm time reached
    */
   static RtcTimeAlarmFlag getTimeAlarmFlag() {
      return RtcTimeAlarmFlag(rtc->SR&RTC_SR_TAF_MASK);
   }
   
   /**
    * Get Time Overflow Flag
    * (rtc_sr_tof)
    *
    * @return Indicates time overflow has occurred
    */
   static RtcTimerOverflowFlag getTimeOverflowFlag() {
      return RtcTimerOverflowFlag(rtc->SR&RTC_SR_TOF_MASK);
   }
   
   /**
    * Get Time Invalid Flag
    * (rtc_sr_tif)
    *
    * @return Indicates if the time is valid
    */
   static RtcTimeInvalidFlag getTimeInvalidFlag() {
      return RtcTimeInvalidFlag(rtc->SR&RTC_SR_TIF_MASK);
   }
   
   /**
    * Set Time Seconds Interrupt Enable
    * (rtc_ier_tsie)
    *
    * @param rtcSecondsAction The seconds interrupt is an edge-sensitive interrupt with a dedicated interrupt vector.
    *        It is generated once a second and requires no software overhead
    *        (there is no corresponding status flag to clear).
    */
   static void setSecondsAction(RtcSecondsAction rtcSecondsAction) {
      rtc->IER = (rtc->IER&~RTC_IER_TSIE_MASK) | rtcSecondsAction;
   }
   
   /**
    * Get Time Seconds Interrupt Enable
    * (rtc_ier_tsie)
    *
    * @return The seconds interrupt is an edge-sensitive interrupt with a dedicated interrupt vector.
    *        It is generated once a second and requires no software overhead
    *        (there is no corresponding status flag to clear).
    */
   static RtcSecondsAction getSecondsAction() {
      return RtcSecondsAction(rtc->IER&RTC_IER_TSIE_MASK);
   }
   
   /**
    * Set Time Alarm Interrupt Enable
    * (rtc_ier_taie)
    *
    * @param rtcAlarmAction Interrupt enable for Alarm
    */
   static void setAlarmAction(RtcAlarmAction rtcAlarmAction) {
      rtc->IER = (rtc->IER&~RTC_IER_TAIE_MASK) | rtcAlarmAction;
   }
   
   /**
    * Get Time Alarm Interrupt Enable
    * (rtc_ier_taie)
    *
    * @return Interrupt enable for Alarm
    */
   static RtcAlarmAction getAlarmAction() {
      return RtcAlarmAction(rtc->IER&RTC_IER_TAIE_MASK);
   }
   
   /**
    * Set Time in Seconds
    *
    * @param rtcTime When the time counter is enabled, the TSR is read only and increments once a second
    *        provided SR[TOF] or SR[TIF] are not set.
    *        The time counter will read as zero when SR[TOF] or SR[TIF] are set.
    *        When the time counter is disabled, the TSR can be read or written.
    *        Writing to the TSR when the time counter is disabled will clear the 
    *        SR[TOF] and/or the SR[TIF]. 
    *        Writing to TSR with zero is supported, but not recommended because
    *        TSR will read as zero when SR[TIF] or SR[TOF] are set (indicates time is invalid).
    */
   static void setTime(uint32_t rtcTime) {
      rtc->TSR = rtcTime;
   }
   
   /**
    * Get Time in Seconds
    *
    * @return When the time counter is enabled, the TSR is read only and increments once a second
    *        provided SR[TOF] or SR[TIF] are not set.
    *        The time counter will read as zero when SR[TOF] or SR[TIF] are set.
    *        When the time counter is disabled, the TSR can be read or written.
    *        Writing to the TSR when the time counter is disabled will clear the 
    *        SR[TOF] and/or the SR[TIF]. 
    *        Writing to TSR with zero is supported, but not recommended because
    *        TSR will read as zero when SR[TIF] or SR[TOF] are set (indicates time is invalid).
    */
   static uint32_t getTime() {
      return rtc->TSR;
   }
   
   /**
    * Set Alarm time in seconds
    *
    * @param rtcAlarm When the time counter is enabled, the SR[TAF] is set whenever the TAR[TAR]
    *        equals the TSR[TSR] and the TSR[TSR] increments. Writing to the TAR clears the SR[TAF].
    */
   static void setAlarm(uint32_t rtcAlarm) {
      rtc->TAR = rtcAlarm;
   }
   
   /**
    * Get Alarm time in seconds
    *
    * @return When the time counter is enabled, the SR[TAF] is set whenever the TAR[TAR]
    *        equals the TSR[TSR] and the TSR[TSR] increments. Writing to the TAR clears the SR[TAF].
    */
   static uint32_t getAlarm() {
      return rtc->TAR;
   }
   
}; // class RtcInfo

/** 
 * End group RTC_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Abstraction for Multipurpose Clock Generator
 * @{
 */
/**
 * Peripheral information for MCG, Multipurpose Clock Generator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * OSC0 mode
    * (oscMode)
    *
    * Determines oscillator power mode and
    * whether an external clock or crystal is used.
    */
   enum OscMode {
      OscMode_NotConfigured         = 0,                                ///< OSC0 Not configured
      OscMode_ExternalClock         = MCG_C2_EREFS0(0),                 ///< External clock
      OscMode_LowPowerOscillator    = MCG_C2_EREFS0(1),                 ///< Low Power Oscillator
      OscMode_HighPowerOscillator   = MCG_C2_EREFS0(1)|MCG_C2_HGO0(1),  ///< High Gain Oscillator
   };

   /**
    * External Reference Select
    * (mcg_c2_erefs0)
    *
    * Determines whether an external clock or crystal is used
    */
   enum McgExternalClock {
      McgExternalClock_ExternalClk   = MCG_C2_EREFS0(0),  ///< External clock
      McgExternalClock_Oscillator    = MCG_C2_EREFS0(1),  ///< Oscillator
   };

   /**
    * Oscillator mode
    * (mcg_c2_hgo0)
    *
    * Operation mode for oscillator
    */
   enum McgOscMode {
      McgOscMode_LowPower    = MCG_C2_HGO0(0),  ///< Low Power
      McgOscMode_HighPower   = MCG_C2_HGO0(1),  ///< High Gain
   };

   /**
    * MCG Clock Mode
    * (mcgClockMode[0])
    *
    * Selects the basic clock mode for the Clock generator
    */
   enum McgClockMode : uint8_t {
      McgClockMode_FEI    = 0,  ///< FLL Engaged Internal (FEI)
      McgClockMode_FEE    = 1,  ///< FLL Engaged External (FEE)
      McgClockMode_FBI    = 2,  ///< FLL bypassed internal (FBI)
      McgClockMode_FBE    = 4,  ///< FLL bypassed external (FBE)
      McgClockMode_PBE    = 6,  ///< PLL Bypassed External (PBE)
      McgClockMode_PEE    = 7,  ///< PLL Engaged External (PEE)
      McgClockMode_BLPI   = 3,  ///< Bypassed low power internal (BLPI)
      McgClockMode_BLPE   = 5,  ///< Bypassed low power external (BLPE)
   };

   /**
    * OSC0 Clock Monitor Enable
    * (mcg_c6_cme0[0])
    *
    * Enables the loss of clock monitoring circuit for the OSC0 external reference.
    * C2.LOCRE0 determines if an interrupt or a reset request is generated.
    * The CME0 bit must only be when using an external clock mode (FEE, FBE, PEE, PBE, or BLPE)[0]
    */
   enum McgOsc0ClockMonitor {
      McgOsc0ClockMonitor_Disabled   = MCG_C6_CME0(0),  ///< Clock monitor disabled
      McgOsc0ClockMonitor_Enabled    = MCG_C6_CME0(1),  ///< Clock monitor enabled
   };

   /**
    * OSC0 Action on Loss of Clock
    * (mcg_c2_locre0[0])
    *
    * Determines if an Interrupt or Reset occurs on loss of OSC0 external reference
    * This option only has effect if the clock monitor is first enabled bye C6.CME0
    */
   enum McgOsc0LossOfClockAction {
      McgOsc0LossOfClockAction_Interrupt   = MCG_C2_LOCRE0(0),  ///< Interrupt request
      McgOsc0LossOfClockAction_Reset       = MCG_C2_LOCRE0(1),  ///< Reset request
   };

   /**
    * PLL Loss of Lock Interrupt Enable
    * (mcg_c6_lolie0[0])
    *
    * Determines if an interrupt request is made following a PLL loss of lock indication.
    * This bit has effect when S.LOLS0 is set
    */
   enum McgPllLossOfClockInterrupt {
      McgPllLossOfClockInterrupt_Disabled   = MCG_C6_LOLIE0(0),  ///< No interrupt request
      McgPllLossOfClockInterrupt_Enabled    = MCG_C6_LOLIE0(1),  ///< Interrupt request on LOL
   };

   /**
    * PLL Loss of Lock Reset Enable
    * (mcg_c8_lolre[0])
    *
    * Determines if an interrupt or a reset request is made following a PLL loss of lock.
    * Only has an affect when LOLIE0 is set
    */
   enum McgPllLossOfClockReset {
      McgPllLossOfClockReset_Disabled   = MCG_C8_LOLRE(0),  ///< Interrupt request
      McgPllLossOfClockReset_Enabled    = MCG_C8_LOLRE(1),  ///< Reset request
   };

   /**
    * OSC1 (RTC) Clock Monitor Enable
    * (mcg_c8_cme1[0])
    *
    * Determines if the clock monitor is enabled for the RTC external clock.
    * CME1 bit must be set to a logic 0 before the MCG enters any Stop mode
    */
   enum McgOsc1ClockMonitor {
      McgOsc1ClockMonitor_Disabled   = MCG_C8_CME1(0),  ///< Clock monitor disabled
      McgOsc1ClockMonitor_Enabled    = MCG_C8_CME1(1),  ///< Clock monitor enabled
   };

   /**
    * OSC1 (RTC) Loss of Clock Reset Enable
    * (mcg_c8_locre1[0])
    *
    * Determines if a interrupt or a reset request is made following a loss of RTC external reference clock.
    * Only has an affect when CME1 is set
    */
   enum McgOsc1LossOfClockAction {
      McgOsc1LossOfClockAction_Interrupt   = MCG_C8_LOCRE1(0),  ///< Interrupt request
      McgOsc1LossOfClockAction_Reset       = MCG_C8_LOCRE1(1),  ///< Reset request
   };

   /**
    * Fast Internal Clock [FIRC] Reference Divider
    * (mcg_sc_fcrdiv[0])
    *
    * Selects the amount to divide down the fast internal reference clock
    * The FIR clock is available for use as MCGIRCLK or MCGOUTCLK
    */
   enum McgFastInternalClockDivider {
      McgFastInternalClockDivider_DivBy1     = MCG_SC_FCRDIV(0),  ///< /1
      McgFastInternalClockDivider_DivBy2     = MCG_SC_FCRDIV(1),  ///< /2
      McgFastInternalClockDivider_DivBy4     = MCG_SC_FCRDIV(2),  ///< /4
      McgFastInternalClockDivider_DivBy8     = MCG_SC_FCRDIV(3),  ///< /8
      McgFastInternalClockDivider_DivBy16    = MCG_SC_FCRDIV(4),  ///< /16
      McgFastInternalClockDivider_DivBy32    = MCG_SC_FCRDIV(5),  ///< /32
      McgFastInternalClockDivider_DivBy64    = MCG_SC_FCRDIV(6),  ///< /64
      McgFastInternalClockDivider_DivBy128   = MCG_SC_FCRDIV(7),  ///< /128
   };

   /**
    * Internal Reference Clock [MCGIRCLK] Source
    * (mcg_c2_ircs[0])
    *
    * Clock Source for MCGIRCLK
    */
   enum McgIrClkSrc {
      McgIrClkSrc_Slow   = MCG_C2_IRCS(0),  ///< Slow internal reference clock
      McgIrClkSrc_Fast   = MCG_C2_IRCS(1),  ///< Fast internal reference clock
   };

   /**
    * Internal Reference Clock [MCGIRCLK]
    * (mcg_c1_irclken[0])
    *
    * Enables the internal reference clock for use by peripherals
    */
   enum McgIrClkEn {
      McgIrClkEn_Disabled   = MCG_C1_IRCLKEN(0),  ///< Disabled
      McgIrClkEn_Enabled    = MCG_C1_IRCLKEN(1),  ///< Enabled
   };

   /**
    * Internal Reference [MCGIRCLK] Stop Enable
    * (mcg_c1_irefsten[0])
    *
    * Determines if MCGIRCLK is enabled in Stop mode
    */
   enum McgIrefs {
      McgIrefs_DisabledInStop   = MCG_C1_IREFSTEN(0),  ///< IR disabled in STOP
      McgIrefs_EnabledInStop    = MCG_C1_IREFSTEN(1),  ///< IR enabled in STOP
   };

   /**
    * MCG External reference clock
    * (mcg_c7_oscsel[0])
    *
    * Source for MCG External Reference Clock
    */
   enum McgErcSelect {
      McgErcSelect_OscClk   = MCG_C7_OSCSEL(0),  ///< OSC0 Clock
      McgErcSelect_RtcClk   = MCG_C7_OSCSEL(1),  ///< RTC 32kHz clock
   };

   /**
    * Frequency Range Select
    * (mcg_c2_range0[0])
    *
    * Selects the frequency range for the crystal oscillator if used.
    * It may determine the divider for FLL input clock
    */
   enum McgRange0 {
      McgRange0_Low        = MCG_C2_RANGE0(0),  ///< Low range
      McgRange0_High       = MCG_C2_RANGE0(1),  ///< High range
      McgRange0_VeryHigh   = MCG_C2_RANGE0(2),  ///< Very High range
   };

   /**
    * FLL External Reference Divider
    * (mcg_c1_frdiv[0])
    *
    * Selects the amount to divide down the external reference clock for the FLL.
    * The resulting frequency must be in [31.25 kHz to 39.0625 kHz] to be suitable for the FLL
    * Division factors choices depends on clock Range [MGC_C2_RANGE0] and clock source [MCG_C6_OSCSEL]
    */
   enum McgFllPrescale {
      McgFllPrescale_Disabled        = MCG_C1_FRDIV(0),   ///< Disabled
      McgFllPrescale_LowDivBy1       = MCG_C1_FRDIV(0),   ///< /1 (low)
      McgFllPrescale_LowDivBy2       = MCG_C1_FRDIV(1),   ///< /2 (low)
      McgFllPrescale_LowDivBy3       = MCG_C1_FRDIV(2),   ///< /4 (low)
      McgFllPrescale_LowDivBy8       = MCG_C1_FRDIV(3),   ///< /8 (low)
      McgFllPrescale_LowDivBy16      = MCG_C1_FRDIV(4),   ///< /16 (low)
      McgFllPrescale_LowDivBy32      = MCG_C1_FRDIV(5),   ///< /32 (low)
      McgFllPrescale_LowDivBy64      = MCG_C1_FRDIV(6),   ///< /64 (low)
      McgFllPrescale_LowDivBy128     = MCG_C1_FRDIV(7),   ///< /128 (low)
      McgFllPrescale_HighDivBy32     = MCG_C1_FRDIV(8),   ///< /32 (high)
      McgFllPrescale_HighDivBy64     = MCG_C1_FRDIV(9),   ///< /64 (high)
      McgFllPrescale_HighDivBy128    = MCG_C1_FRDIV(10),  ///< /128 (high)
      McgFllPrescale_HighDivBy256    = MCG_C1_FRDIV(11),  ///< /256 (high)
      McgFllPrescale_HighDivBy512    = MCG_C1_FRDIV(12),  ///< /512 (high)
      McgFllPrescale_HighDivBy1024   = MCG_C1_FRDIV(13),  ///< /1024 (high)
      McgFllPrescale_HighDivBy1280   = MCG_C1_FRDIV(14),  ///< /1280 (high)
      McgFllPrescale_HighDivBy1536   = MCG_C1_FRDIV(15),  ///< /1536 (high)
   };

   /**
    * Internal Reference Select
    * (mcg_c1_irefs[0])
    *
    * Selects the reference clock source for the FLL
    * This option is determined by the Clock Mode selection
    */
   enum McgIref {
      McgIref_External   = MCG_C1_IREFS(0),  ///< External Reference Clock
      McgIref_Internal   = MCG_C1_IREFS(1),  ///< Slow Internal Clock
   };

   /**
    * DMX32 DCO lock range
    * (mcg_c4_dmx32[0])
    *
    * Allows the FLL parameters to be optimised for either:
    * - maximum output frequency with a 32.768 kHz FLL input clock, or
    * - a wider range of inputs frequencies [31.25-39.06] kHz
    */
   enum McgFllLockRangeWidth {
      McgFllLockRangeWidth_Wide     = MCG_C4_DMX32(0),  ///< Wide
      McgFllLockRangeWidth_Narrow   = MCG_C4_DMX32(1),  ///< Narrow
   };

   /**
    * DCO Range Select
    * (mcg_c4_drst_drs[0])
    *
    * Frequency range for the FLL output, DCOOUT
    * This is determined from the FLL input and output clock frequencies
    */
   enum McgFllLockRange {
      McgFllLockRange_Low       = MCG_C4_DRST_DRS(0),  ///< Low (x640/x732, 20-25/24 MHz)
      McgFllLockRange_Mid       = MCG_C4_DRST_DRS(1),  ///< Mid (x1280/x1464, 40-50/48 MHz)
      McgFllLockRange_MidHigh   = MCG_C4_DRST_DRS(2),  ///< Mid-high (x1920/x2197, 60-75/72 MHz)
      McgFllLockRange_High      = MCG_C4_DRST_DRS(3),  ///< High (x2560/x2929, 80-100/96 MHz)
   };

   /**
    * PLL0 Enable
    * (mcg_c5_pllclken0[0])
    *
    * Enables PLL0 independent of PLLS
    */
   enum McgPllEnable {
      McgPllEnable_AsNeeded   = MCG_C5_PLLCLKEN0(0),  ///< PLL active as needed
      McgPllEnable_Forced     = MCG_C5_PLLCLKEN0(1),  ///< PLL forced active
   };

   /**
    * PLL Stop Enable
    * (mcg_c5_pllsten0[0])
    *
    * Enables the PLL0 Clock during Normal Stop
    */
   enum McgPllStopEnable {
      McgPllStopEnable_DisabledInStop   = MCG_C5_PLLSTEN0(0),  ///< PLL0 is disabled in any Stop mode
      McgPllStopEnable_EnabledInStop    = MCG_C5_PLLSTEN0(1),  ///< PLL0 is enabled in Normal Stop mode
   };

   /**
    * FLL/PLL Clock selection for MCGOUTCLK when CLKS=0
    * (mcg_c6_plls[0])
    *
    * Selects PLL or FLL output as clock source when CLKS=0
    * This option is determined by the Clock Mode selection
    */
   enum McgPllFllSelect {
      McgPllFllSelect_FLL   = MCG_C6_PLLS(0),  ///< FLL is selected
      McgPllFllSelect_PLL   = MCG_C6_PLLS(1),  ///< PLL is selected
   };

   /*
    * Global clocks
    */
   
   /**
    *  MCG Fixed Frequency Clock [MCGFFCLK]
    *  Used as input clock to FLL and available to some peripherals
    *  Derived from External Reference Clock or Slow IRC
    *  (Full configuration - declaration)
    */
   extern volatile uint32_t SystemMcgFFClock;
   
   /**
    *  System MCG Output Clock [MCGOUTCLK]
    *  MCG Main clock output
    *  (Full configuration - declaration)
    */
   extern volatile uint32_t SystemMcgOutClock;
   
   /**
    *  FLL Output clock frequency
    *  Output of FLL.
    *  Available as MCGFLLCLK and used for MCGOUTCLK in FEI or FEE clock modes
    *  (Full configuration - declaration)
    */
   extern volatile uint32_t SystemMcgFllClock;
   
   /**
    *  PLL Output clock frequency
    *  Output of PLL
    *  (Full configuration - declaration)
    */
   extern volatile uint32_t SystemMcgPllClock;
   
class McgBasicInfo {

public:
   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
}; // class McgBasicInfo 

class McgInfo : public McgBasicInfo {

public:
   /*
    * Template:mcg_mk
    */
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = MCG_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    * Basic enable of Mcg
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
   }
   
   /**
    * Disables Mcg
    */
   static void disable() {
   
      
      disableNvicInterrupts();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = MCG_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<MCG_Type> mcg = baseAddress;
   
   /**
    * Get MCG External reference clock
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getExternalReferenceClock() {
   
      switch(mcg->C7&MCG_C7_OSCSEL_MASK) {
         default: return 0;
         case McgErcSelect_OscClk : return Osc0Info::getOscClock();     ///< OSC0 Clock
         case McgErcSelect_RtcClk : return RtcInfo::getExternalClock(); ///< RTC 32kHz clock

      }
   }

   /**
    * Get Fast Internal Reference Clock (divided)
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getFastInternalReferenceClock() {
   
      return (system_fast_irc_clock/(1<<((mcg->SC&MCG_SC_FCRDIV_MASK)>>MCG_SC_FCRDIV_SHIFT)));
   }

   /**
    * Set Internal Reference Clock [MCGIRCLK] Source
    *
    * @param mcgIrClkSrc Clock Source for MCGIRCLK
    */
   static void setInternalReferenceClock(McgIrClkSrc mcgIrClkSrc) {
      mcg->C2 = (mcg->C2&~MCG_C2_IRCS_MASK) | mcgIrClkSrc;
   }
   
   /**
    * Get Internal Reference Clock [MCGIRCLK] Source
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getInternalReferenceClock() {
   
      switch(mcg->C2&MCG_C2_IRCS_MASK) {
         default: return 0;
         case McgIrClkSrc_Slow : return system_slow_irc_clock;           ///< Slow internal reference clock
         case McgIrClkSrc_Fast : return getFastInternalReferenceClock(); ///< Fast internal reference clock

      }
   }

   /**
    * Set Internal Reference Clock [MCGIRCLK]
    *
    * @param mcgIrClkEn Enables the internal reference clock for use by peripherals
    */
   static void enableMcgIrClock(McgIrClkEn mcgIrClkEn) {
      mcg->C1 = (mcg->C1&~MCG_C1_IRCLKEN_MASK) | mcgIrClkEn;
   }
   
   /**
    * Get Internal Reference Clock [MCGIRCLK]
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getMcgIrClock() {
   
      switch(mcg->C1&MCG_C1_IRCLKEN_MASK) {
         default: return 0;
         case McgIrClkEn_Disabled : return 0;                           ///< Disabled
         case McgIrClkEn_Enabled  : return getInternalReferenceClock(); ///< Enabled

      }
   }

   /*
      Errata     : e2448
      Issue      : Flash prefetch could result in incorrect read data when CLKDIV1 changed
      Workaround : Use code in RAM that disabled/restores prefetch around changing CLKDIV1
    */
#define USBDM_ERRATA_E2448 1

   /*
      Errata     : e7993
      Issue      : FLL frequency may be incorrect after changing the FLL reference clock
      Workaround : Invert MCG_C4[DMX32] before clock source changes and restore afterwards.
    */
#define USBDM_ERRATA_E7993 0

   /// Frequency of Slow Internal Reference Clock [~32kHz]
   static constexpr uint32_t system_slow_irc_clock = 32768UL;

   /// Frequency of Fast Internal Reference Clock [~4MHz]
   static constexpr uint32_t system_fast_irc_clock = 4000000UL;

   /// PLL VDIV min value
   static constexpr uint32_t pll_vdiv_min = 24;

   /// PLL post divider
   static constexpr uint32_t pll_post_divider = 1;
   
}; // class McgInfo

/** 
 * End group MCG_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Abstraction for System Integration Module
 * @{
 */
/**
 * Peripheral information for SIM, System Integration Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Mapping of DMA slot to DMA channel
    * (dmamux_chcfg_src)
    *
    * Specifies which DMA source (slot) is routed to a particular DMA channel
    */
   enum DmamuxSlot {
      DmamuxSlot_Disabled          = DMAMUX_CHCFG_SOURCE(0),   ///< Disabled
      DmamuxSlot_UART0_Receive     = DMAMUX_CHCFG_SOURCE(2),   ///< UART0 Receive
      DmamuxSlot_UART0_Transmit    = DMAMUX_CHCFG_SOURCE(3),   ///< UART0 Transmit
      DmamuxSlot_UART1_Receive     = DMAMUX_CHCFG_SOURCE(4),   ///< UART1 Receive
      DmamuxSlot_UART1_Transmit    = DMAMUX_CHCFG_SOURCE(5),   ///< UART1 Transmit
      DmamuxSlot_UART2_Receive     = DMAMUX_CHCFG_SOURCE(6),   ///< UART2 Receive
      DmamuxSlot_UART2_Transmit    = DMAMUX_CHCFG_SOURCE(7),   ///< UART2 Transmit
      DmamuxSlot_I2S0_Receive      = DMAMUX_CHCFG_SOURCE(14),  ///< I2S0 Receive
      DmamuxSlot_I2S0_Transmit     = DMAMUX_CHCFG_SOURCE(15),  ///< I2S0 Transmit
      DmamuxSlot_SPI0_Receive      = DMAMUX_CHCFG_SOURCE(16),  ///< SPI0 Receive
      DmamuxSlot_SPI0_Transmit     = DMAMUX_CHCFG_SOURCE(17),  ///< SPI0 Transmit
      DmamuxSlot_I2C0              = DMAMUX_CHCFG_SOURCE(22),  ///< I2C0
      DmamuxSlot_FTM0_Channel0     = DMAMUX_CHCFG_SOURCE(24),  ///< FTM0 Channel 0
      DmamuxSlot_FTM0_Channel1     = DMAMUX_CHCFG_SOURCE(25),  ///< FTM0 Channel 1
      DmamuxSlot_FTM0_Channel2     = DMAMUX_CHCFG_SOURCE(26),  ///< FTM0 Channel 2
      DmamuxSlot_FTM0_Channel3     = DMAMUX_CHCFG_SOURCE(27),  ///< FTM0 Channel 3
      DmamuxSlot_FTM0_Channel4     = DMAMUX_CHCFG_SOURCE(28),  ///< FTM0 Channel 4
      DmamuxSlot_FTM0_Channel5     = DMAMUX_CHCFG_SOURCE(29),  ///< FTM0 Channel 5
      DmamuxSlot_FTM0_Channel6     = DMAMUX_CHCFG_SOURCE(30),  ///< FTM0 Channel 6
      DmamuxSlot_FTM0_Channel7     = DMAMUX_CHCFG_SOURCE(31),  ///< FTM0 Channel 7
      DmamuxSlot_FTM1_Channel0     = DMAMUX_CHCFG_SOURCE(32),  ///< FTM1 Channel 0
      DmamuxSlot_FTM1_Channel1     = DMAMUX_CHCFG_SOURCE(33),  ///< FTM1 Channel 1
      DmamuxSlot_ADC0              = DMAMUX_CHCFG_SOURCE(40),  ///< ADC0
      DmamuxSlot_CMP0              = DMAMUX_CHCFG_SOURCE(42),  ///< CMP0
      DmamuxSlot_CMP1              = DMAMUX_CHCFG_SOURCE(43),  ///< CMP1
      DmamuxSlot_CMT               = DMAMUX_CHCFG_SOURCE(47),  ///< CMT
      DmamuxSlot_PDB               = DMAMUX_CHCFG_SOURCE(48),  ///< PDB
      DmamuxSlot_PortA             = DMAMUX_CHCFG_SOURCE(49),  ///< Port A
      DmamuxSlot_PortB             = DMAMUX_CHCFG_SOURCE(50),  ///< Port B
      DmamuxSlot_PortC             = DMAMUX_CHCFG_SOURCE(51),  ///< Port C
      DmamuxSlot_PortD             = DMAMUX_CHCFG_SOURCE(52),  ///< Port D
      DmamuxSlot_PortE             = DMAMUX_CHCFG_SOURCE(53),  ///< Port E
      DmamuxSlot_AlwaysEnabled54   = DMAMUX_CHCFG_SOURCE(54),  ///< Always Enabled 54
      DmamuxSlot_AlwaysEnabled55   = DMAMUX_CHCFG_SOURCE(55),  ///< Always Enabled 55
      DmamuxSlot_AlwaysEnabled56   = DMAMUX_CHCFG_SOURCE(56),  ///< Always Enabled 56
      DmamuxSlot_AlwaysEnabled57   = DMAMUX_CHCFG_SOURCE(57),  ///< Always Enabled 57
      DmamuxSlot_AlwaysEnabled58   = DMAMUX_CHCFG_SOURCE(58),  ///< Always Enabled 58
      DmamuxSlot_AlwaysEnabled59   = DMAMUX_CHCFG_SOURCE(59),  ///< Always Enabled 59
      DmamuxSlot_AlwaysEnabled60   = DMAMUX_CHCFG_SOURCE(60),  ///< Always Enabled 60
      DmamuxSlot_AlwaysEnabled61   = DMAMUX_CHCFG_SOURCE(61),  ///< Always Enabled 61
      DmamuxSlot_AlwaysEnabled62   = DMAMUX_CHCFG_SOURCE(62),  ///< Always Enabled 62
      DmamuxSlot_AlwaysEnabled63   = DMAMUX_CHCFG_SOURCE(63),  ///< Always Enabled 63
   };

   /**
    * USB voltage regulator power control
    * (sim_sopt1_usbpower)
    *
    * Controls when the USB voltage regulator is enabled in
    * (RUN), (STOP, VLPS, LLS and VLLS) or (VLPR and VLPW) modes
    */
   enum SimUsbPower {
      SimUsbPower_Disabled                = SIM_SOPT1_USBREGEN(0)|SIM_SOPT1_USBSSTBY(0)|SIM_SOPT1_USBVSTBY(0),  ///< Disabled in all modes
      SimUsbPower_EnabledInAll            = SIM_SOPT1_USBREGEN(1)|SIM_SOPT1_USBSSTBY(0)|SIM_SOPT1_USBVSTBY(0),  ///< Enabled in all modes
      SimUsbPower_EnabledInRun_LowPower   = SIM_SOPT1_USBREGEN(1)|SIM_SOPT1_USBSSTBY(1)|SIM_SOPT1_USBVSTBY(0),  ///< Enabled in run and low power
      SimUsbPower_EnabledInRun_Stop       = SIM_SOPT1_USBREGEN(1)|SIM_SOPT1_USBSSTBY(0)|SIM_SOPT1_USBVSTBY(1),  ///< Enabled in run and stop
      SimUsbPower_EnabledInRun            = SIM_SOPT1_USBREGEN(1)|SIM_SOPT1_USBSSTBY(1)|SIM_SOPT1_USBVSTBY(1),  ///< Enabled in run only
   };

   /**
    * PTD7 pad drive strength
    * (sim_sopt2_ptd7pad)
    *
    * Controls the output drive strength of the PTD7 pin
    * by selecting either one or two pads to drive it
    */
   enum SimPortDPad {
      SimPortDPad_Single   = SIM_SOPT2_PTD7PAD(0),  ///< Single-pad drive strength
      SimPortDPad_Double   = SIM_SOPT2_PTD7PAD(1),  ///< Double-pad drive strength
   };

   /**
    * Debug trace clock select
    * (sim_sopt2_traceclksel)
    *
    * Selects the core/system clock or MCG output clock (MCGOUTCLK) as the trace clock source
    * The chosen clock is divided by 2.
    */
   enum SimTraceClockoutSel {
      SimTraceClockoutSel_McgOutClk   = SIM_SOPT2_TRACECLKSEL(0),  ///< MCGOUTCLK
      SimTraceClockoutSel_CoreClk     = SIM_SOPT2_TRACECLKSEL(1),  ///< Core/system clock
   };

   /**
    * FTM0 Hardware Trigger 0 Source
    * (sim_sopt4_ftm0trg0src)
    *
    * Source of FTM 0 hardware trigger 0
    */
   enum SimFtm0Trg0Src {
      SimFtm0Trg0Src_Cmp0        = SIM_SOPT4_FTM0TRG0SRC(0),  ///< CMP0 output
      SimFtm0Trg0Src_Ftm1Match   = SIM_SOPT4_FTM0TRG0SRC(1),  ///< FTM1 channel match (enable FTM1.EXTTRIG)
   };

   /**
    * FTM0 External Clock Pin
    * (sim_sopt4_ftm0clksel)
    *
    * External pin used to drive the clock to the FTM module
    */
   enum SimFtm0ClkSel {
      SimFtm0ClkSel_FtmClkin0   = SIM_SOPT4_FTM0CLKSEL(0),  ///< FTM_CLKIN0 pin
      SimFtm0ClkSel_FtmClkin1   = SIM_SOPT4_FTM0CLKSEL(1),  ///< FTM_CLKIN1 pin
   };

   /**
    * FTM0 Fault 0 Select
    * (sim_sopt4_ftm0flt0)
    *
    * Source of FTM fault input 0
    */
   enum SimFtm0Flt0 {
      SimFtm0Flt0_Ftm0Fault0   = SIM_SOPT4_FTM0FLT0(0),  ///< FTM0_FLT0 pin
      SimFtm0Flt0_Cmp0         = SIM_SOPT4_FTM0FLT0(1),  ///< CMP0 output
   };

   /**
    * FTM0 Fault 1 Select
    * (sim_sopt4_ftm0flt1)
    *
    * Source of FTM fault input 1
    */
   enum SimFtm0Flt1 {
      SimFtm0Flt1_Ftm0Fault1   = SIM_SOPT4_FTM0FLT1(0),  ///< FTM0_FLT1 pin
      SimFtm0Flt1_Cmp1         = SIM_SOPT4_FTM0FLT1(1),  ///< CMP1 output
   };

   /**
    * FTM1 External Clock Pin
    * (sim_sopt4_ftm1clksel)
    *
    * External pin used to drive the clock to the FTM module
    */
   enum SimFtm1ClkSel {
      SimFtm1ClkSel_FtmClkin0   = SIM_SOPT4_FTM1CLKSEL(0),  ///< FTM_CLKIN0 pin
      SimFtm1ClkSel_FtmClkin1   = SIM_SOPT4_FTM1CLKSEL(1),  ///< FTM_CLKIN1 pin
   };

   /**
    * FTM 1 channel 0 input capture source
    * (sim_sopt4_ftm1ch0src)
    *
    * Source for FTM channel 0 input capture
    * NOTE: When the FTM is not in input capture mode, clear this field
    */
   enum SimFtm1Ch0Src {
      SimFtm1Ch0Src_IcPin    = SIM_SOPT4_FTM1CH0SRC(0),  ///< FTM1_CH0 signal
      SimFtm1Ch0Src_Cmp0     = SIM_SOPT4_FTM1CH0SRC(1),  ///< CMP0 output
      SimFtm1Ch0Src_Cmp1     = SIM_SOPT4_FTM1CH0SRC(2),  ///< CMP1 output
      SimFtm1Ch0Src_UsbSof   = SIM_SOPT4_FTM1CH0SRC(3),  ///< USB start of frame pulse
   };

   /**
    * FTM1 Fault 0 Select
    * (sim_sopt4_ftm1flt0)
    *
    * Source of FTM fault input 0
    */
   enum SimFtm1Flt0 {
      SimFtm1Flt0_Ftm1Fault0   = SIM_SOPT4_FTM1FLT0(0),  ///< FTM1_FLT0 pin
      SimFtm1Flt0_Cmp0         = SIM_SOPT4_FTM1FLT0(1),  ///< CMP0 output
   };

   /**
    * UART0 receive data source
    * (sim_sopt5_uart0rxsrc)
    *
    * Source for the UART0 receive data
    */
   enum SimUart0RxSrc {
      SimUart0RxSrc_RxPin   = SIM_SOPT5_UART0RXSRC(0),  ///< Rx pin
      SimUart0RxSrc_Cmp0    = SIM_SOPT5_UART0RXSRC(1),  ///< CMP0 output
      SimUart0RxSrc_Cmp1    = SIM_SOPT5_UART0RXSRC(2),  ///< CMP1 output
   };

   /**
    * UART0 transmit data source
    * (sim_sopt5_uart0txsrc)
    *
    * Source for the UART0 transmit data
    */
   enum SimUart0TxSrc {
      SimUart0TxSrc_Direct               = SIM_SOPT5_UART0TXSRC(0),  ///< Tx pin
      SimUart0TxSrc_ModulatedByFtm1Ch0   = SIM_SOPT5_UART0TXSRC(1),  ///< Tx pin modulated by FTM1 channel 0
      SimUart0TxSrc_ModulatedByFtm2Ch0   = SIM_SOPT5_UART0TXSRC(2),  ///< Tx pin modulated by FTM2 channel 0
   };

   /**
    * UART1 receive data source
    * (sim_sopt5_uart1rxsrc)
    *
    * Source for the UART1 receive data
    */
   enum SimUart1RxSrc {
      SimUart1RxSrc_RxPin   = SIM_SOPT5_UART1RXSRC(0),  ///< Rx pin
      SimUart1RxSrc_Cmp0    = SIM_SOPT5_UART1RXSRC(1),  ///< CMP0 output
      SimUart1RxSrc_Cmp1    = SIM_SOPT5_UART1RXSRC(2),  ///< CMP1 output
   };

   /**
    * UART1 transmit data source
    * (sim_sopt5_uart1txsrc)
    *
    * Source for the UART1 transmit data
    */
   enum SimUart1TxSrc {
      SimUart1TxSrc_Direct               = SIM_SOPT5_UART1TXSRC(0),  ///< Tx pin
      SimUart1TxSrc_ModulatedByFtm1Ch0   = SIM_SOPT5_UART1TXSRC(1),  ///< Tx pin modulated by FTM1 channel 0
      SimUart1TxSrc_ModulatedByFtm2Ch0   = SIM_SOPT5_UART1TXSRC(2),  ///< Tx pin modulated by FTM2 channel 0
   };

   /**
    * ADC0 trigger mode
    * (sim_sopt7_adc0trigger)
    *
    * Alternative conversion triggers for ADC
    * _Pdb              - ADC is triggered by PDB
    * _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
    * _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
    */
   enum SimAdc0TriggerMode {
      SimAdc0TriggerMode_Pdb                = SIM_SOPT7_ADC0ALTTRGEN(0)|SIM_SOPT7_ADC0PRETRGSEL(0),  ///< Triggered by PDB
      SimAdc0TriggerMode_Alt_PreTrigger_0   = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(0),  ///< External trigger using SC1[0]/R[0]
      SimAdc0TriggerMode_Alt_PreTrigger_1   = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(1),  ///< External trigger using SC1[1]/R[1]
   };

   /**
    * ADC0 trigger source
    * (sim_sopt7_adc0trgsel)
    *
    * ADC Trigger source in STOP and VLPS modes, or when ADC Alternative Trigger is active
    */
   enum SimAdc0TriggerSrc {
      SimAdc0TriggerSrc_External     = SIM_SOPT7_ADC0TRGSEL(0),   ///< External trigger pin input (PDB0_EXTRG)
      SimAdc0TriggerSrc_Cmp0         = SIM_SOPT7_ADC0TRGSEL(1),   ///< CMP 0 output
      SimAdc0TriggerSrc_Cmp1         = SIM_SOPT7_ADC0TRGSEL(2),   ///< CMP 1 output
      SimAdc0TriggerSrc_PitCh0       = SIM_SOPT7_ADC0TRGSEL(4),   ///< PIT trigger 0
      SimAdc0TriggerSrc_Pit_ch0      = SIM_SOPT7_ADC0TRGSEL(4),   ///< Pin PIT_CH0
      SimAdc0TriggerSrc_PitCh1       = SIM_SOPT7_ADC0TRGSEL(5),   ///< PIT trigger 1
      SimAdc0TriggerSrc_Pit_ch1      = SIM_SOPT7_ADC0TRGSEL(5),   ///< Pin PIT_CH1
      SimAdc0TriggerSrc_PitCh2       = SIM_SOPT7_ADC0TRGSEL(6),   ///< PIT trigger 2
      SimAdc0TriggerSrc_Pit_ch2      = SIM_SOPT7_ADC0TRGSEL(6),   ///< Pin PIT_CH2
      SimAdc0TriggerSrc_PitCh3       = SIM_SOPT7_ADC0TRGSEL(7),   ///< PIT trigger 3
      SimAdc0TriggerSrc_Pit_ch3      = SIM_SOPT7_ADC0TRGSEL(7),   ///< Pin PIT_CH3
      SimAdc0TriggerSrc_Ftm0         = SIM_SOPT7_ADC0TRGSEL(8),   ///< FTM0 trigger
      SimAdc0TriggerSrc_Ftm1         = SIM_SOPT7_ADC0TRGSEL(9),   ///< FTM1 trigger
      SimAdc0TriggerSrc_RtcAlarm     = SIM_SOPT7_ADC0TRGSEL(12),  ///< RTC alarm
      SimAdc0TriggerSrc_RtcSeconds   = SIM_SOPT7_ADC0TRGSEL(13),  ///< RTC seconds
      SimAdc0TriggerSrc_Lptmr        = SIM_SOPT7_ADC0TRGSEL(14),  ///< LPTMR trigger
   };

   /**
    * CLKOUT pin clock
    * (sim_sopt2_clkoutsel[0])
    *
    * Clock to output on the CLKOUT pin
    */
   enum SimClkoutSel {
      SimClkoutSel_Unused0     = SIM_SOPT2_CLKOUTSEL(0),  ///< Disabled0
      SimClkoutSel_Unused1     = SIM_SOPT2_CLKOUTSEL(1),  ///< Disabled1
      SimClkoutSel_FlashClk    = SIM_SOPT2_CLKOUTSEL(2),  ///< Flash clock
      SimClkoutSel_LpoClk      = SIM_SOPT2_CLKOUTSEL(3),  ///< LPO clock (1 kHz)
      SimClkoutSel_McgIrClk    = SIM_SOPT2_CLKOUTSEL(4),  ///< MCGIRCLK
      SimClkoutSel_RtcClk      = SIM_SOPT2_CLKOUTSEL(5),  ///< RTC 32.768kHz clock
      SimClkoutSel_OscerClk0   = SIM_SOPT2_CLKOUTSEL(6),  ///< OSCERCLK0
      SimClkoutSel_Unused7     = SIM_SOPT2_CLKOUTSEL(7),  ///< Disabled7
   };

   /**
    * Peripheral Clock
    * (sim_sopt2_pllfllsel[0])
    *
    * Clock for various peripherals (LPUART, TPM etc.)
    * If there is a peripheral clock divider then this is the
    * Frequency of the undivided peripheral clock
    */
   enum SimPeripheralClockSource {
      SimPeripheralClockSource_McgFllClk   = SIM_SOPT2_PLLFLLSEL(0),  ///< MCGFLLCLK clock
      SimPeripheralClockSource_McgPllClk   = SIM_SOPT2_PLLFLLSEL(1),  ///< MCGPLLCLK clock
   };

   /**
    * USB clock divider (SIM_CLKDIV2)
    * (sim_clkdiv2_usb[0])
    *
    * Sets the clock divider when using an internal clock
    * as the USB clock source
    */
   enum SimUsbClockDivider {
      SimUsbClockDivider_Mult2    = (1),   ///< Multiply by 2 (div=0, frac=1)
      SimUsbClockDivider_Mult1    = (0),   ///< Multiply by 1 (div=0, frac=0)
      SimUsbClockDivider_Mult1b   = (3),   ///< Multiply by 1 (div=1, frac=1)
      SimUsbClockDivider_Div1_5   = (5),   ///< Divide by 1.5 (div=2, frac=1)
      SimUsbClockDivider_Div2     = (2),   ///< Divide by 2 (div=1, frac=0)
      SimUsbClockDivider_Div2b    = (7),   ///< Divide by 2 (div=3, frac=1)
      SimUsbClockDivider_Div2_5   = (9),   ///< Divide by 2.5 (div=4, frac=1)
      SimUsbClockDivider_Div3     = (4),   ///< Divide by 3 (div=2, frac=0)
      SimUsbClockDivider_Div3b    = (11),  ///< Divide by 3 (div=5, frac=1)
      SimUsbClockDivider_Div3_5   = (13),  ///< Divide by 3.5 (div=6, frac=1)
      SimUsbClockDivider_Div4     = (6),   ///< Divide by 4 (div=3, frac=0)
      SimUsbClockDivider_Div4b    = (15),  ///< Divide by 4 (div=7, frac=1)
      SimUsbClockDivider_Div5     = (8),   ///< Divide by 5 (div=4, frac=0)
      SimUsbClockDivider_Div6     = (10),  ///< Divide by 6 (div=5, frac=0)
      SimUsbClockDivider_Div7     = (12),  ///< Divide by 7 (div=6, frac=0)
      SimUsbClockDivider_Div8     = (14),  ///< Divide by 8 (div=7, frac=0)
   };

   /**
    * USB Clock
    * (sim_sopt2_usbsrc[0])
    *
    * Source for the USB clock
    */
   enum SimUsbFullSpeedClockSource {
      SimUsbFullSpeedClockSource_External        = SIM_SOPT2_USBSRC(0),  ///< External bypass clock (USB_CLKIN)
      SimUsbFullSpeedClockSource_PeripheralClk   = SIM_SOPT2_USBSRC(1),  ///< Peripheral Clock/SIM_CLKDIV2
   };

   /**
    * Core &amp;amp; System Clock Divider (OUTDIV1) - Divide by [1-16]
    * (sim_clkdiv1_outdiv1[0])
    *
    * Clocks the ARM Cortex-M4 core and bus masters
    * Divides MCGOUTCLK Clock to generate system_core_clock.
    */
   enum SimCoreClkDivider {
      SimCoreClkDivider_Direct    = SIM_CLKDIV1_OUTDIV1(0),   ///< /1
      SimCoreClkDivider_DivBy2    = SIM_CLKDIV1_OUTDIV1(1),   ///< /2
      SimCoreClkDivider_DivBy3    = SIM_CLKDIV1_OUTDIV1(2),   ///< /3
      SimCoreClkDivider_DivBy4    = SIM_CLKDIV1_OUTDIV1(3),   ///< /4
      SimCoreClkDivider_DivBy5    = SIM_CLKDIV1_OUTDIV1(4),   ///< /5
      SimCoreClkDivider_DivBy6    = SIM_CLKDIV1_OUTDIV1(5),   ///< /6
      SimCoreClkDivider_DivBy7    = SIM_CLKDIV1_OUTDIV1(6),   ///< /7
      SimCoreClkDivider_DivBy8    = SIM_CLKDIV1_OUTDIV1(7),   ///< /8
      SimCoreClkDivider_DivBy9    = SIM_CLKDIV1_OUTDIV1(8),   ///< /9
      SimCoreClkDivider_DivBy10   = SIM_CLKDIV1_OUTDIV1(9),   ///< /10
      SimCoreClkDivider_DivBy11   = SIM_CLKDIV1_OUTDIV1(10),  ///< /11
      SimCoreClkDivider_DivBy12   = SIM_CLKDIV1_OUTDIV1(11),  ///< /12
      SimCoreClkDivider_DivBy13   = SIM_CLKDIV1_OUTDIV1(12),  ///< /13
      SimCoreClkDivider_DivBy14   = SIM_CLKDIV1_OUTDIV1(13),  ///< /14
      SimCoreClkDivider_DivBy15   = SIM_CLKDIV1_OUTDIV1(14),  ///< /15
      SimCoreClkDivider_DivBy16   = SIM_CLKDIV1_OUTDIV1(15),  ///< /16
   };

   /**
    * Bus Clock Divider (OUTDIV2) - Divide by [1-16]
    * (sim_clkdiv1_outdiv2[0])
    *
    * Clocks the bus slaves and peripheral.
    * Divides MCGOUTCLK Clock to generate system_bus_clock.
    */
   enum SimBusClkDivider {
      SimBusClkDivider_Direct    = SIM_CLKDIV1_OUTDIV2(0),   ///< /1
      SimBusClkDivider_DivBy2    = SIM_CLKDIV1_OUTDIV2(1),   ///< /2
      SimBusClkDivider_DivBy3    = SIM_CLKDIV1_OUTDIV2(2),   ///< /3
      SimBusClkDivider_DivBy4    = SIM_CLKDIV1_OUTDIV2(3),   ///< /4
      SimBusClkDivider_DivBy5    = SIM_CLKDIV1_OUTDIV2(4),   ///< /5
      SimBusClkDivider_DivBy6    = SIM_CLKDIV1_OUTDIV2(5),   ///< /6
      SimBusClkDivider_DivBy7    = SIM_CLKDIV1_OUTDIV2(6),   ///< /7
      SimBusClkDivider_DivBy8    = SIM_CLKDIV1_OUTDIV2(7),   ///< /8
      SimBusClkDivider_DivBy9    = SIM_CLKDIV1_OUTDIV2(8),   ///< /9
      SimBusClkDivider_DivBy10   = SIM_CLKDIV1_OUTDIV2(9),   ///< /10
      SimBusClkDivider_DivBy11   = SIM_CLKDIV1_OUTDIV2(10),  ///< /11
      SimBusClkDivider_DivBy12   = SIM_CLKDIV1_OUTDIV2(11),  ///< /12
      SimBusClkDivider_DivBy13   = SIM_CLKDIV1_OUTDIV2(12),  ///< /13
      SimBusClkDivider_DivBy14   = SIM_CLKDIV1_OUTDIV2(13),  ///< /14
      SimBusClkDivider_DivBy15   = SIM_CLKDIV1_OUTDIV2(14),  ///< /15
      SimBusClkDivider_DivBy16   = SIM_CLKDIV1_OUTDIV2(15),  ///< /16
   };

   /**
    * Flash Clock Divider (OUTDIV4) - Divide by [1-16]
    * (sim_clkdiv1_outdiv4[0])
    *
    * Clocks the flash memory.
    * Divides MCGOUTCLK Clock to generate system_flash_clock.
    */
   enum SimFlashClkDivider {
      SimFlashClkDivider_Direct    = SIM_CLKDIV1_OUTDIV4(0),   ///< /1
      SimFlashClkDivider_DivBy2    = SIM_CLKDIV1_OUTDIV4(1),   ///< /2
      SimFlashClkDivider_DivBy3    = SIM_CLKDIV1_OUTDIV4(2),   ///< /3
      SimFlashClkDivider_DivBy4    = SIM_CLKDIV1_OUTDIV4(3),   ///< /4
      SimFlashClkDivider_DivBy5    = SIM_CLKDIV1_OUTDIV4(4),   ///< /5
      SimFlashClkDivider_DivBy6    = SIM_CLKDIV1_OUTDIV4(5),   ///< /6
      SimFlashClkDivider_DivBy7    = SIM_CLKDIV1_OUTDIV4(6),   ///< /7
      SimFlashClkDivider_DivBy8    = SIM_CLKDIV1_OUTDIV4(7),   ///< /8
      SimFlashClkDivider_DivBy9    = SIM_CLKDIV1_OUTDIV4(8),   ///< /9
      SimFlashClkDivider_DivBy10   = SIM_CLKDIV1_OUTDIV4(9),   ///< /10
      SimFlashClkDivider_DivBy11   = SIM_CLKDIV1_OUTDIV4(10),  ///< /11
      SimFlashClkDivider_DivBy12   = SIM_CLKDIV1_OUTDIV4(11),  ///< /12
      SimFlashClkDivider_DivBy13   = SIM_CLKDIV1_OUTDIV4(12),  ///< /13
      SimFlashClkDivider_DivBy14   = SIM_CLKDIV1_OUTDIV4(13),  ///< /14
      SimFlashClkDivider_DivBy15   = SIM_CLKDIV1_OUTDIV4(14),  ///< /15
      SimFlashClkDivider_DivBy16   = SIM_CLKDIV1_OUTDIV4(15),  ///< /16
   };

   /**
    * Adc0 Clock Gate Control
    * (sim_scgc6_adc0)
    *
    * This clock gate must be enabled to access Adc0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimAdc0Clock {
      SimAdc0Clock_Disabled   = SIM_SCGC6_ADC0(0),  ///< Adc0 Clock disabled
      SimAdc0Clock_Enabled    = SIM_SCGC6_ADC0(1),  ///< Adc0 Clock enabled
   };

   /**
    * Cmp Clock Gate Control
    * (sim_scgc4_cmp)
    *
    * This clock gate must be enabled to access Cmp. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimCmpClock {
      SimCmpClock_Disabled   = SIM_SCGC4_CMP(0),  ///< Cmp Clock disabled
      SimCmpClock_Enabled    = SIM_SCGC4_CMP(1),  ///< Cmp Clock enabled
   };

   /**
    * Cmt Clock Gate Control
    * (sim_scgc4_cmt)
    *
    * This clock gate must be enabled to access Cmt. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimCmtClock {
      SimCmtClock_Disabled   = SIM_SCGC4_CMT(0),  ///< Cmt Clock disabled
      SimCmtClock_Enabled    = SIM_SCGC4_CMT(1),  ///< Cmt Clock enabled
   };

   /**
    * Crc Clock Gate Control
    * (sim_scgc6_crc)
    *
    * This clock gate must be enabled to access Crc. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimCrcClock {
      SimCrcClock_Disabled   = SIM_SCGC6_CRC(0),  ///< Crc Clock disabled
      SimCrcClock_Enabled    = SIM_SCGC6_CRC(1),  ///< Crc Clock enabled
   };

   /**
    * Dma0 Clock Gate Control
    * (sim_scgc7_dma0)
    *
    * This clock gate must be enabled to access Dma0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimDma0Clock {
      SimDma0Clock_Disabled   = SIM_SCGC7_DMA0(0),  ///< Dma0 Clock disabled
      SimDma0Clock_Enabled    = SIM_SCGC7_DMA0(1),  ///< Dma0 Clock enabled
   };

   /**
    * Dmamux0 Clock Gate Control
    * (sim_scgc6_dmamux0)
    *
    * This clock gate must be enabled to access Dmamux0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimDmamux0Clock {
      SimDmamux0Clock_Disabled   = SIM_SCGC6_DMAMUX0(0),  ///< Dmamux0 Clock disabled
      SimDmamux0Clock_Enabled    = SIM_SCGC6_DMAMUX0(1),  ///< Dmamux0 Clock enabled
   };

   /**
    * Ewm Clock Gate Control
    * (sim_scgc4_ewm)
    *
    * This clock gate must be enabled to access Ewm. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimEwmClock {
      SimEwmClock_Disabled   = SIM_SCGC4_EWM(0),  ///< Ewm Clock disabled
      SimEwmClock_Enabled    = SIM_SCGC4_EWM(1),  ///< Ewm Clock enabled
   };

   /**
    * Ftfl Clock Gate Control
    * (sim_scgc6_ftfl)
    *
    * This clock gate must be enabled to access Ftfl. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimFtflClock {
      SimFtflClock_Disabled   = SIM_SCGC6_FTFL(0),  ///< Ftfl Clock disabled
      SimFtflClock_Enabled    = SIM_SCGC6_FTFL(1),  ///< Ftfl Clock enabled
   };

   /**
    * Ftm0 Clock Gate Control
    * (sim_scgc6_ftm0)
    *
    * This clock gate must be enabled to access Ftm0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimFtm0Clock {
      SimFtm0Clock_Disabled   = SIM_SCGC6_FTM0(0),  ///< Ftm0 Clock disabled
      SimFtm0Clock_Enabled    = SIM_SCGC6_FTM0(1),  ///< Ftm0 Clock enabled
   };

   /**
    * Ftm1 Clock Gate Control
    * (sim_scgc6_ftm1)
    *
    * This clock gate must be enabled to access Ftm1. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimFtm1Clock {
      SimFtm1Clock_Disabled   = SIM_SCGC6_FTM1(0),  ///< Ftm1 Clock disabled
      SimFtm1Clock_Enabled    = SIM_SCGC6_FTM1(1),  ///< Ftm1 Clock enabled
   };

   /**
    * I2c0 Clock Gate Control
    * (sim_scgc4_i2c0)
    *
    * This clock gate must be enabled to access I2c0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimI2c0Clock {
      SimI2c0Clock_Disabled   = SIM_SCGC4_I2C0(0),  ///< I2c0 Clock disabled
      SimI2c0Clock_Enabled    = SIM_SCGC4_I2C0(1),  ///< I2c0 Clock enabled
   };

   /**
    * I2s0 Clock Gate Control
    * (sim_scgc6_i2s0)
    *
    * This clock gate must be enabled to access I2s0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimI2s0Clock {
      SimI2s0Clock_Disabled   = SIM_SCGC6_I2S0(0),  ///< I2s0 Clock disabled
      SimI2s0Clock_Enabled    = SIM_SCGC6_I2S0(1),  ///< I2s0 Clock enabled
   };

   /**
    * Lptmr0 Clock Gate Control
    * (sim_scgc5_lptmr0)
    *
    * This clock gate must be enabled to access Lptmr0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimLptmr0Clock {
      SimLptmr0Clock_Disabled   = SIM_SCGC5_LPTMR0(0),  ///< Lptmr0 Clock disabled
      SimLptmr0Clock_Enabled    = SIM_SCGC5_LPTMR0(1),  ///< Lptmr0 Clock enabled
   };

   /**
    * Pdb Clock Gate Control
    * (sim_scgc6_pdb)
    *
    * This clock gate must be enabled to access Pdb. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimPdbClock {
      SimPdbClock_Disabled   = SIM_SCGC6_PDB(0),  ///< Pdb Clock disabled
      SimPdbClock_Enabled    = SIM_SCGC6_PDB(1),  ///< Pdb Clock enabled
   };

   /**
    * Pit Clock Gate Control
    * (sim_scgc6_pit)
    *
    * This clock gate must be enabled to access Pit. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimPitClock {
      SimPitClock_Disabled   = SIM_SCGC6_PIT(0),  ///< Pit Clock disabled
      SimPitClock_Enabled    = SIM_SCGC6_PIT(1),  ///< Pit Clock enabled
   };

   /**
    * Porta Clock Gate Control
    * (sim_scgc5_porta)
    *
    * This clock gate must be enabled to access Porta. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimPortaClock {
      SimPortaClock_Disabled   = SIM_SCGC5_PORTA(0),  ///< Porta Clock disabled
      SimPortaClock_Enabled    = SIM_SCGC5_PORTA(1),  ///< Porta Clock enabled
   };

   /**
    * Portb Clock Gate Control
    * (sim_scgc5_portb)
    *
    * This clock gate must be enabled to access Portb. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimPortbClock {
      SimPortbClock_Disabled   = SIM_SCGC5_PORTB(0),  ///< Portb Clock disabled
      SimPortbClock_Enabled    = SIM_SCGC5_PORTB(1),  ///< Portb Clock enabled
   };

   /**
    * Portc Clock Gate Control
    * (sim_scgc5_portc)
    *
    * This clock gate must be enabled to access Portc. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimPortcClock {
      SimPortcClock_Disabled   = SIM_SCGC5_PORTC(0),  ///< Portc Clock disabled
      SimPortcClock_Enabled    = SIM_SCGC5_PORTC(1),  ///< Portc Clock enabled
   };

   /**
    * Portd Clock Gate Control
    * (sim_scgc5_portd)
    *
    * This clock gate must be enabled to access Portd. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimPortdClock {
      SimPortdClock_Disabled   = SIM_SCGC5_PORTD(0),  ///< Portd Clock disabled
      SimPortdClock_Enabled    = SIM_SCGC5_PORTD(1),  ///< Portd Clock enabled
   };

   /**
    * Porte Clock Gate Control
    * (sim_scgc5_porte)
    *
    * This clock gate must be enabled to access Porte. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimPorteClock {
      SimPorteClock_Disabled   = SIM_SCGC5_PORTE(0),  ///< Porte Clock disabled
      SimPorteClock_Enabled    = SIM_SCGC5_PORTE(1),  ///< Porte Clock enabled
   };

   /**
    * Rtc Clock Gate Control
    * (sim_scgc6_rtc)
    *
    * This clock gate must be enabled to access Rtc. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimRtcClock {
      SimRtcClock_Disabled   = SIM_SCGC6_RTC(0),  ///< Rtc Clock disabled
      SimRtcClock_Enabled    = SIM_SCGC6_RTC(1),  ///< Rtc Clock enabled
   };

   /**
    * Spi0 Clock Gate Control
    * (sim_scgc6_spi0)
    *
    * This clock gate must be enabled to access Spi0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimSpi0Clock {
      SimSpi0Clock_Disabled   = SIM_SCGC6_SPI0(0),  ///< Spi0 Clock disabled
      SimSpi0Clock_Enabled    = SIM_SCGC6_SPI0(1),  ///< Spi0 Clock enabled
   };

   /**
    * Tsi0 Clock Gate Control
    * (sim_scgc5_tsi0)
    *
    * This clock gate must be enabled to access Tsi0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimTsi0Clock {
      SimTsi0Clock_Disabled   = SIM_SCGC5_TSI0(0),  ///< Tsi0 Clock disabled
      SimTsi0Clock_Enabled    = SIM_SCGC5_TSI0(1),  ///< Tsi0 Clock enabled
   };

   /**
    * Uart0 Clock Gate Control
    * (sim_scgc4_uart0)
    *
    * This clock gate must be enabled to access Uart0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimUart0Clock {
      SimUart0Clock_Disabled   = SIM_SCGC4_UART0(0),  ///< Uart0 Clock disabled
      SimUart0Clock_Enabled    = SIM_SCGC4_UART0(1),  ///< Uart0 Clock enabled
   };

   /**
    * Uart1 Clock Gate Control
    * (sim_scgc4_uart1)
    *
    * This clock gate must be enabled to access Uart1. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimUart1Clock {
      SimUart1Clock_Disabled   = SIM_SCGC4_UART1(0),  ///< Uart1 Clock disabled
      SimUart1Clock_Enabled    = SIM_SCGC4_UART1(1),  ///< Uart1 Clock enabled
   };

   /**
    * Uart2 Clock Gate Control
    * (sim_scgc4_uart2)
    *
    * This clock gate must be enabled to access Uart2. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimUart2Clock {
      SimUart2Clock_Disabled   = SIM_SCGC4_UART2(0),  ///< Uart2 Clock disabled
      SimUart2Clock_Enabled    = SIM_SCGC4_UART2(1),  ///< Uart2 Clock enabled
   };

   /**
    * Usb0 Clock Gate Control
    * (sim_scgc4_usb0)
    *
    * This clock gate must be enabled to access Usb0. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimUsb0Clock {
      SimUsb0Clock_Disabled   = SIM_SCGC4_USB0(0),  ///< Usb0 Clock disabled
      SimUsb0Clock_Enabled    = SIM_SCGC4_USB0(1),  ///< Usb0 Clock enabled
   };

   /**
    * Usbdcd Clock Gate Control
    * (sim_scgc6_usbdcd)
    *
    * This clock gate must be enabled to access Usbdcd. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimUsbdcdClock {
      SimUsbdcdClock_Disabled   = SIM_SCGC6_USBDCD(0),  ///< Usbdcd Clock disabled
      SimUsbdcdClock_Enabled    = SIM_SCGC6_USBDCD(1),  ///< Usbdcd Clock enabled
   };

   /**
    * Vref Clock Gate Control
    * (sim_scgc4_vref)
    *
    * This clock gate must be enabled to access Vref. 
    * This may be done when configuring the SIM or when the individual peripheral is configured.
    */
   enum SimVrefClock {
      SimVrefClock_Disabled   = SIM_SCGC4_VREF(0),  ///< Vref Clock disabled
      SimVrefClock_Enabled    = SIM_SCGC4_VREF(1),  ///< Vref Clock enabled
   };

   /**
    * ERCLK32K clock source
    * (sim_sopt1_osc32ksel)
    *
    * Clock source for External 32k Reference Clock [ERCLK32K]
    */
   enum SimErc32kSel {
      SimErc32kSel_Osc32kClk   = SIM_SOPT1_OSC32KSEL(0),  ///< OSC0 in low range (OSC32KCLK)
      SimErc32kSel_Rtc32kClk   = SIM_SOPT1_OSC32KSEL(2),  ///< RTC 32kHz clock
      SimErc32kSel_LpoClk      = SIM_SOPT1_OSC32KSEL(3),  ///< LPO 1kHz clock
   };

   /**
    * RTC clock out source
    * (sim_sopt2_rtcclkoutsel)
    *
    * Clock output on the RTC_CLKOUT pin
    */
   enum SimRtcClkoutSel {
      SimRtcClkoutSel_1Hz     = SIM_SOPT2_RTCCLKOUTSEL(0),  ///< RTC 1 Hz clock
      SimRtcClkoutSel_32kHz   = SIM_SOPT2_RTCCLKOUTSEL(1),  ///< RTC 32kHz clock
   };

   /**
    * RAM size
    */
   enum SimRamSize {
      SimRamSize_8KiB    = SIM_SOPT1_RAMSIZE(1),  ///< 8KiB RAM
      SimRamSize_16KiB   = SIM_SOPT1_RAMSIZE(3),  ///< 16KiB RAM
      SimRamSize_24KiB   = SIM_SOPT1_RAMSIZE(4),  ///< 24KiB RAM
      SimRamSize_32KiB   = SIM_SOPT1_RAMSIZE(5),  ///< 32KiB RAM
      SimRamSize_48KiB   = SIM_SOPT1_RAMSIZE(6),  ///< 32KiB RAM
      SimRamSize_64KiB   = SIM_SOPT1_RAMSIZE(7),  ///< 64KiB RAM
      SimRamSize_96KiB   = SIM_SOPT1_RAMSIZE(8),  ///< 96KiB RAM
      SimRamSize_128KiB  = SIM_SOPT1_RAMSIZE(9),  ///< 128KiB RAM
      SimRamSize_256KiB  = SIM_SOPT1_RAMSIZE(11), ///< 256KiB RAM
      SimRamSize_512KiB  = SIM_SOPT1_RAMSIZE(12), ///< 256KiB RAM
      SimRamSize_1024KiB = SIM_SOPT1_RAMSIZE(13), ///< 256KiB RAM
   };

   /*
    * Global clocks
    */
   
   /**
    *  System Core Clock
    *  Clocks the ARM Cortex-M4 core and bus masters
    *  (Full configuration - declaration)
    */
   extern "C" uint32_t SystemCoreClock;
   
   /**
    *  System Bus Clock
    *  Clocks the bus slaves and peripherals
    *        - Must be &lt;= Core Clock frequency and an integer divisor
    *  (Full configuration - declaration)
    */
   extern "C" uint32_t SystemBusClock;
   
class SimBasicInfo {

public:
   /**
    * Class used to do initialisation of the Sim clock enables
    *
    * This class has a templated constructor that accepts various values.
    * Parameters available may vary with device - see Sim::DefaultInitValue for relevant example.
    * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Sim::ClockEnables simClockEnables {
    *
    *   // Setup values
    *   SimScgc4Spi1_ClockDisabled                // SPI1 Clock Gate Control,
    *   SimScgc4Spi0_ClockDisabled                // SPI0 Clock Gate Control,
    *   SimScgc4Cmp0_ClockDisabled                // Comparator Clock Gate Control,
    *   SimScgc4Usb0_ClockDisabled                // USB Clock Gate Control,
    *   SimScgc4Uart2_ClockDisabled               // UART2 Clock Gate Control,
    *   SimScgc4Uart1_ClockDisabled               // UART1 Clock Gate Control,
    *   SimScgc4Uart0_ClockDisabled               // UART0 Clock Gate Control,
    *   SimScgc4I2c1_ClockDisabled                // I2C1 Clock Gate Control,
    *   SimScgc4I2c0_ClockDisabled                // I2C0 Clock Gate Control,
    *   SimScgc5Porte_ClockDisabled               // Port E Clock Gate Control,
    *   SimScgc5Portd_ClockDisabled               // Port D Clock Gate Control,
    *   SimScgc5Portc_ClockDisabled               // Port C Clock Gate Control,
    *   SimScgc5Portb_ClockDisabled               // Port B Clock Gate Control,
    *   SimScgc5Porta_ClockDisabled               // Port A Clock Gate Control,
    *   SimScgc5Tsi0_ClockDisabled                // TSI0 Clock Gate Control,
    *   SimScgc5Lptmr_ClockDisabled               // LPTMR  Clock Gate Control,
    *   SimScgc6Rtc_ClockDisabled                 // RTC Clock Gate Control,
    *   SimScgc6Adc0_ClockDisabled                // ADC0 Clock Gate Control,
    *   SimScgc6Tpm1_ClockDisabled                // TPM1 Clock Gate Control,
    *   SimScgc6Tpm0_ClockDisabled                // TPM0 Clock Gate Control,
    *   SimScgc6Ftf_ClockDisabled                 // Flash Clock Gate Control,
    * };
    *
    * // Initialise Sim from values specified above
    * Sim::configure(simClockEnables)
    * @endcode
    */
   class ClockEnables {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr ClockEnables(const ClockEnables &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr ClockEnables() = default;
   
      /// System Clock Gating Control Register 4
      uint32_t scgc4 = 0;

      /// System Clock Gating Control Register 5
      uint32_t scgc5 = 0;

      /// System Clock Gating Control Register 6
      uint32_t scgc6 = 0;

      /// System Clock Gating Control Register 7
      uint32_t scgc7 = 0;

      /**
       * Constructor for Adc0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simAdc0Clock This clock gate must be enabled to access Adc0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimAdc0Clock simAdc0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_ADC0_MASK) | simAdc0Clock;
      }
   
      /**
       * Constructor for Cmp Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simCmpClock This clock gate must be enabled to access Cmp. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimCmpClock simCmpClock, Types... rest) : ClockEnables(rest...) {
   
         scgc4 = (scgc4&~SIM_SCGC4_CMP_MASK) | simCmpClock;
      }
   
      /**
       * Constructor for Cmt Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simCmtClock This clock gate must be enabled to access Cmt. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimCmtClock simCmtClock, Types... rest) : ClockEnables(rest...) {
   
         scgc4 = (scgc4&~SIM_SCGC4_CMT_MASK) | simCmtClock;
      }
   
      /**
       * Constructor for Crc Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simCrcClock This clock gate must be enabled to access Crc. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimCrcClock simCrcClock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_CRC_MASK) | simCrcClock;
      }
   
      /**
       * Constructor for Dma0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simDma0Clock This clock gate must be enabled to access Dma0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimDma0Clock simDma0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc7 = (scgc7&~SIM_SCGC7_DMA0_MASK) | simDma0Clock;
      }
   
      /**
       * Constructor for Dmamux0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simDmamux0Clock This clock gate must be enabled to access Dmamux0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimDmamux0Clock simDmamux0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_DMAMUX0_MASK) | simDmamux0Clock;
      }
   
      /**
       * Constructor for Ewm Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simEwmClock This clock gate must be enabled to access Ewm. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimEwmClock simEwmClock, Types... rest) : ClockEnables(rest...) {
   
         scgc4 = (scgc4&~SIM_SCGC4_EWM_MASK) | simEwmClock;
      }
   
      /**
       * Constructor for Ftfl Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtflClock This clock gate must be enabled to access Ftfl. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimFtflClock simFtflClock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_FTFL_MASK) | simFtflClock;
      }
   
      /**
       * Constructor for Ftm0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtm0Clock This clock gate must be enabled to access Ftm0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimFtm0Clock simFtm0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_FTM0_MASK) | simFtm0Clock;
      }
   
      /**
       * Constructor for Ftm1 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtm1Clock This clock gate must be enabled to access Ftm1. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimFtm1Clock simFtm1Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_FTM1_MASK) | simFtm1Clock;
      }
   
      /**
       * Constructor for I2c0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simI2c0Clock This clock gate must be enabled to access I2c0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimI2c0Clock simI2c0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc4 = (scgc4&~SIM_SCGC4_I2C0_MASK) | simI2c0Clock;
      }
   
      /**
       * Constructor for I2s0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simI2s0Clock This clock gate must be enabled to access I2s0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimI2s0Clock simI2s0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_I2S0_MASK) | simI2s0Clock;
      }
   
      /**
       * Constructor for Lptmr0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simLptmr0Clock This clock gate must be enabled to access Lptmr0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimLptmr0Clock simLptmr0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc5 = (scgc5&~SIM_SCGC5_LPTMR0_MASK) | simLptmr0Clock;
      }
   
      /**
       * Constructor for Pdb Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPdbClock This clock gate must be enabled to access Pdb. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimPdbClock simPdbClock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_PDB_MASK) | simPdbClock;
      }
   
      /**
       * Constructor for Pit Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPitClock This clock gate must be enabled to access Pit. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimPitClock simPitClock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_PIT_MASK) | simPitClock;
      }
   
      /**
       * Constructor for Porta Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPortaClock This clock gate must be enabled to access Porta. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimPortaClock simPortaClock, Types... rest) : ClockEnables(rest...) {
   
         scgc5 = (scgc5&~SIM_SCGC5_PORTA_MASK) | simPortaClock;
      }
   
      /**
       * Constructor for Portb Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPortbClock This clock gate must be enabled to access Portb. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimPortbClock simPortbClock, Types... rest) : ClockEnables(rest...) {
   
         scgc5 = (scgc5&~SIM_SCGC5_PORTB_MASK) | simPortbClock;
      }
   
      /**
       * Constructor for Portc Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPortcClock This clock gate must be enabled to access Portc. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimPortcClock simPortcClock, Types... rest) : ClockEnables(rest...) {
   
         scgc5 = (scgc5&~SIM_SCGC5_PORTC_MASK) | simPortcClock;
      }
   
      /**
       * Constructor for Portd Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPortdClock This clock gate must be enabled to access Portd. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimPortdClock simPortdClock, Types... rest) : ClockEnables(rest...) {
   
         scgc5 = (scgc5&~SIM_SCGC5_PORTD_MASK) | simPortdClock;
      }
   
      /**
       * Constructor for Porte Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPorteClock This clock gate must be enabled to access Porte. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimPorteClock simPorteClock, Types... rest) : ClockEnables(rest...) {
   
         scgc5 = (scgc5&~SIM_SCGC5_PORTE_MASK) | simPorteClock;
      }
   
      /**
       * Constructor for Rtc Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simRtcClock This clock gate must be enabled to access Rtc. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimRtcClock simRtcClock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_RTC_MASK) | simRtcClock;
      }
   
      /**
       * Constructor for Spi0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSpi0Clock This clock gate must be enabled to access Spi0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimSpi0Clock simSpi0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_SPI0_MASK) | simSpi0Clock;
      }
   
      /**
       * Constructor for Tsi0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simTsi0Clock This clock gate must be enabled to access Tsi0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimTsi0Clock simTsi0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc5 = (scgc5&~SIM_SCGC5_TSI0_MASK) | simTsi0Clock;
      }
   
      /**
       * Constructor for Uart0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart0Clock This clock gate must be enabled to access Uart0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimUart0Clock simUart0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc4 = (scgc4&~SIM_SCGC4_UART0_MASK) | simUart0Clock;
      }
   
      /**
       * Constructor for Uart1 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart1Clock This clock gate must be enabled to access Uart1. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimUart1Clock simUart1Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc4 = (scgc4&~SIM_SCGC4_UART1_MASK) | simUart1Clock;
      }
   
      /**
       * Constructor for Uart2 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart2Clock This clock gate must be enabled to access Uart2. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimUart2Clock simUart2Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc4 = (scgc4&~SIM_SCGC4_UART2_MASK) | simUart2Clock;
      }
   
      /**
       * Constructor for Usb0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUsb0Clock This clock gate must be enabled to access Usb0. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimUsb0Clock simUsb0Clock, Types... rest) : ClockEnables(rest...) {
   
         scgc4 = (scgc4&~SIM_SCGC4_USB0_MASK) | simUsb0Clock;
      }
   
      /**
       * Constructor for Usbdcd Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUsbdcdClock This clock gate must be enabled to access Usbdcd. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimUsbdcdClock simUsbdcdClock, Types... rest) : ClockEnables(rest...) {
   
         scgc6 = (scgc6&~SIM_SCGC6_USBDCD_MASK) | simUsbdcdClock;
      }
   
      /**
       * Constructor for Vref Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simVrefClock This clock gate must be enabled to access Vref. 
       *        This may be done when configuring the SIM or when the individual peripheral is configured.
       */
      template <typename... Types>
      constexpr ClockEnables(SimVrefClock simVrefClock, Types... rest) : ClockEnables(rest...) {
   
         scgc4 = (scgc4&~SIM_SCGC4_VREF_MASK) | simVrefClock;
      }
   
   }; // class SimBasicInfo::ClockEnables
   
   /**
    * Class used to do initialisation of SIM Clock control (SOPT2)
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Generic Example: (see Sim::DefaultClockSouceInitValues for device specific example)
    * @code
    * static const ClockSourceInit clockSourceInit {
    *    SimUsbFullSpeedClockSource_McgPClk, // USB Clock - Peripheral clock (MCGPCLK)
    *    SimTpmClockSource_McgPClk,          // TPM Clock source - MCGPCLK (HIRC=IRC48M) Clock
    *    SimFlexioClockSource_McgPClk,       // FLEXIO Clock select - MCGPCLK (HIRC=IRC48M) Clock
    *    SimClkoutSel_LpoClk,                // CLKOUT pin clock - LPO clock (1 kHz)
    *    SimRtcClkoutSel_32kHz,              // RTC clock out source - OSC32KCLK clock (from OSC0)
    *    SimLpuart0ClockSource_McgPClk,      // LPUART0 Clock - MCGPCLK (HIRC=IRC48M) Clock
    *    SimLpuart1ClockSource_McgPClk,      // LPUART1 Clock - MCGPCLK (HIRC=IRC48M) Clock
    *
    *    // Base value modified by above
    *    Sim::DefaultClockSouceInitValues[McgClockMode_HIRC_48MHz]
    * };
    *
    * // Initialise SIM Clock control from values specified above
    * Sim::configure(clockSourceInit);
    * @endcode
    */
   class ClockSourceInit {
   
   public:
   
      /// System Options Register 2
      uint32_t sopt2 = 0;
   
      /**
       * Copy Constructor
       */
      constexpr ClockSourceInit(const ClockSourceInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr ClockSourceInit() = default;
         /**
       * Constructor for Peripheral Clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPeripheralClockSource Clock for various peripherals (LPUART, TPM etc.)
       *        If there is a peripheral clock divider then this is the
       *        Frequency of the undivided peripheral clock
       */
      template <typename... Types>
      constexpr ClockSourceInit(SimPeripheralClockSource simPeripheralClockSource, Types... rest) : ClockSourceInit(rest...) {
   
         sopt2 |= simPeripheralClockSource;
      }
   
      /**
       * Constructor for USB Clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUsbFullSpeedClockSource Source for the USB clock
       */
      template <typename... Types>
      constexpr ClockSourceInit(SimUsbFullSpeedClockSource simUsbFullSpeedClockSource, Types... rest) : ClockSourceInit(rest...) {
   
         sopt2 |= simUsbFullSpeedClockSource;
      }
   
      /**
       * Constructor for CLKOUT pin clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simClkoutSel Clock to output on the CLKOUT pin
       */
      template <typename... Types>
      constexpr ClockSourceInit(SimClkoutSel simClkoutSel, Types... rest) : ClockSourceInit(rest...) {
   
         sopt2 |= simClkoutSel;
      }
   
      /**
       * Constructor for RTC clock out source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simRtcClkoutSel Clock output on the RTC_CLKOUT pin
       */
      template <typename... Types>
      constexpr ClockSourceInit(SimRtcClkoutSel simRtcClkoutSel, Types... rest) : ClockSourceInit(rest...) {
   
         sopt2 |= simRtcClkoutSel;
      }
   
      /**
       * Constructor for Debug trace clock select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simTraceClockoutSel Selects the core/system clock or MCG output clock (MCGOUTCLK) as the trace clock source
       *        The chosen clock is divided by 2.
       */
      template <typename... Types>
      constexpr ClockSourceInit(SimTraceClockoutSel simTraceClockoutSel, Types... rest) : ClockSourceInit(rest...) {
   
         sopt2 |= simTraceClockoutSel;
      }
   
      /**
       * Constructor for PTD7 pad drive strength
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPortDPad Controls the output drive strength of the PTD7 pin
       *        by selecting either one or two pads to drive it
       */
      template <typename... Types>
      constexpr ClockSourceInit(SimPortDPad simPortDPad, Types... rest) : ClockSourceInit(rest...) {
   
         sopt2 |= simPortDPad;
      }
   
   }; // class ClockSourceInit 

   /**
    * Class used to do initialisation of Uart0 signals
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Uart0Init uart0Init {
    * };
    *
    * // Initialise Uart0 signals from values specified above
    * Sim.configure(uart0Init)
    * @endcode
    */
   class Uart0Init {
   
   public:
      /// Uart0 signals
      uint32_t sopt5 = 0;
   
      /**
       * Copy Constructor
       */
      constexpr Uart0Init(const Uart0Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Uart0Init() = default;
   
      /**
       * Constructor
       * @param simUart0TxSrc Source for the UART0 transmit data
       * @param simUart0RxSrc Source for the UART0 receive data
       */
      constexpr Uart0Init(
            SimUart0TxSrc simUart0TxSrc,
            SimUart0RxSrc simUart0RxSrc = SimUart0RxSrc_RxPin) {
   
         sopt5 = (sopt5 & ~(SIM_SOPT5_UART0TXSRC_MASK|SIM_SOPT5_UART0RXSRC_MASK)) |
                          simUart0TxSrc|simUart0RxSrc;
      }
   
      /**
       * Set UART0 transmit data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart0TxSrc Source for the UART0 transmit data
       */
         template <typename... Types>
         constexpr Uart0Init(SimUart0TxSrc simUart0TxSrc, Types... rest) : Uart0Init(rest...) {
            sopt5 = (sopt5 & ~SIM_SOPT5_UART0TXSRC_MASK) | simUart0TxSrc;
      }

      /**
       * Set UART0 receive data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart0RxSrc Source for the UART0 receive data
       */
         template <typename... Types>
         constexpr Uart0Init(SimUart0RxSrc simUart0RxSrc, Types... rest) : Uart0Init(rest...) {
            sopt5 = (sopt5 & ~SIM_SOPT5_UART0RXSRC_MASK) | simUart0RxSrc;
      }

   }; // class Uart0Init 

   /**
    * Class used to do initialisation of Uart1 signals
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Uart1Init uart1Init {
    * };
    *
    * // Initialise Uart1 signals from values specified above
    * Sim.configure(uart1Init)
    * @endcode
    */
   class Uart1Init {
   
   public:
      /// Uart1 signals
      uint32_t sopt5 = 0;
   
      /**
       * Copy Constructor
       */
      constexpr Uart1Init(const Uart1Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Uart1Init() = default;
   
      /**
       * Constructor
       * @param simUart1TxSrc Source for the UART1 transmit data
       * @param simUart1RxSrc Source for the UART1 receive data
       */
      constexpr Uart1Init(
            SimUart1TxSrc simUart1TxSrc,
            SimUart1RxSrc simUart1RxSrc = SimUart1RxSrc_RxPin) {
   
         sopt5 = (sopt5 & ~(SIM_SOPT5_UART1TXSRC_MASK|SIM_SOPT5_UART1RXSRC_MASK)) |
                          simUart1TxSrc|simUart1RxSrc;
      }
   
      /**
       * Set UART1 transmit data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart1TxSrc Source for the UART1 transmit data
       */
         template <typename... Types>
         constexpr Uart1Init(SimUart1TxSrc simUart1TxSrc, Types... rest) : Uart1Init(rest...) {
            sopt5 = (sopt5 & ~SIM_SOPT5_UART1TXSRC_MASK) | simUart1TxSrc;
      }

      /**
       * Set UART1 receive data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart1RxSrc Source for the UART1 receive data
       */
         template <typename... Types>
         constexpr Uart1Init(SimUart1RxSrc simUart1RxSrc, Types... rest) : Uart1Init(rest...) {
            sopt5 = (sopt5 & ~SIM_SOPT5_UART1RXSRC_MASK) | simUart1RxSrc;
      }

   }; // class Uart1Init 

   /**
    * Class used to do initialisation of all Adc trigger sources
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const AdcHardwareTriggerInit adcHardwareTriggerInit {
    * };
    *
    * // Initialise Adc signals from values specified above
    * Sim::configure(adcHardwareTriggerInit)
    * @endcode
    */
   class AdcHardwareTriggerInit {
   
   public:
      /// Adc signals
      uint32_t sopt7 = 0;
   
      /**
       * Copy Constructor
       */
      constexpr AdcHardwareTriggerInit(const AdcHardwareTriggerInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr AdcHardwareTriggerInit() = default;
   
      /**
       * Constructor for ADC0 trigger mode
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simAdc0TriggerMode Alternative conversion triggers for ADC
       *        _Pdb              - ADC is triggered by PDB
       *        _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
       *        _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
       */
      template <typename... Types>
      constexpr AdcHardwareTriggerInit(SimAdc0TriggerMode simAdc0TriggerMode, Types... rest) : AdcHardwareTriggerInit(rest...) {
   
         sopt7 = (sopt7 & ~(SIM_SOPT7_ADC0ALTTRGEN_MASK|SIM_SOPT7_ADC0PRETRGSEL_MASK)) | simAdc0TriggerMode;
      }
   
      /**
       * Constructor for ADC0 trigger mode and ADC0 trigger source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simAdc0TriggerMode Alternative conversion triggers for ADC
       *        _Pdb              - ADC is triggered by PDB
       *        _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
       *        _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
       * @param simAdc0TriggerSrc  ADC Trigger source in STOP and VLPS modes, or when ADC Alternative Trigger is active
       */
      template <typename... Types>
      constexpr AdcHardwareTriggerInit(
            SimAdc0TriggerMode simAdc0TriggerMode,
            SimAdc0TriggerSrc  simAdc0TriggerSrc, Types... rest) : AdcHardwareTriggerInit(rest...) {
   
         sopt7 = (sopt7 & ~(SIM_SOPT7_ADC0ALTTRGEN_MASK|SIM_SOPT7_ADC0PRETRGSEL_MASK|SIM_SOPT7_ADC0TRGSEL_MASK)) | simAdc0TriggerMode|simAdc0TriggerSrc;
      }
   
   };


   
   /**
    * Class used to do initialisation of Adc0 trigger sources
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * static const Adc0Init adc0Init {
    * };
    *
    * // Initialise Adc signals from values specified above
    * adc0Init.configure()
    * @endcode
    */
   class Adc0Init {
   
   public:
      /// Adc signals
      uint32_t sopt7 = 0;
   
      /**
       * Copy Constructor
       */
      constexpr Adc0Init(const Adc0Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Adc0Init() = default;
   
      /**
       * Constructor
       * @param simAdc0TriggerMode Alternative conversion triggers for ADC
       *        _Pdb              - ADC is triggered by PDB
       *        _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
       *        _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
       * @param simAdc0TriggerSrc  ADC Trigger source in STOP and VLPS modes, or when ADC Alternative Trigger is active
       */
      constexpr Adc0Init(
            SimAdc0TriggerMode simAdc0TriggerMode,
            SimAdc0TriggerSrc  simAdc0TriggerSrc  = SimAdc0TriggerSrc_External) {
   
         sopt7 = simAdc0TriggerMode|simAdc0TriggerSrc;
      }
   };

   /**
    * Class used to do initialisation of SIM
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    * @note Actual parameters available vary with device - see Sim::DefaultInitValue for custom example
    *
    * Example:
    * @code
    * static const Sim::Init simInit {
    *    SimErc32kClkoutPinSelect_None,            // ERCLK32K Clock Output
    *    SimErc32kSel_LpoClk,                      // ERCLK32K clock source
    *    SimUsbPower_EnabledInAll,                 // USB voltage regulator power control
    *    SimUsbFullSpeedClockSource_PeripheralClk, // USB Clock
    *    SimTraceClockoutSel_McgOutClk,            // Debug trace clock select
    *    SimRtcClkoutSel_32kHz ,                   // RTC clock out source
    *    SimClkoutSel_OscerClk0 ,                  // CLKOUT pin clock
    *    SimPeripheralClockSource_Irc48mClk ,      // Peripheral Clock
    *    SimFlexbusSecurity_None,                  // FlexBus off-chip access security level
    *    SimLpuartClockSource_PeripheralClk,       // LPUART Clock select
    *    SimTraceClockoutSel_McgOutClk,            // Debug trace clock select
    *    SimRtcClkoutSel_32kHz,                    // RTC clock out source
    *    SimClkoutSel_OscerClk0,                   // CLKOUT pin clock
    *    SimPeripheralClockSource_Irc48mClk,       // Peripheral Clock
    *    SimFlexbusSecurity_None,                  // FlexBus off-chip access security level
    *    SimFtm0Flt0_Ftm0Fault0,                   // FTM0 Fault 0 Select
    *    SimFtm0Trg0Src_Cmp0,                      // FTM0 Hardware Trigger 0 Source
    *    SimFtm0Flt1_Ftm0Fault1,                   // FTM0 Fault 1 Select
    *    SimFtm0Trg1Src_PdbTrigger1,               // FTM0 Hardware Trigger 1 Source
    *    SimFtm0ClkSel_FtmClkin0,                  // FTM0 External Clock Pin
    *    SimFtm1Flt0_Ftm1Fault0,                   // FTM1 Fault 0 Select
    *    SimFtm1Ch0Src_IcPin,                      // FTM 1 channel 0 input capture source
    *    SimFtm1ClkSel_FtmClkin0,                  // FTM1 External Clock Pin
    *    SimFtm2Flt0_Ftm2Fault0,                   // FTM2 Fault 0 Select
    *    SimFtm2Ch0Src_IcPin,                      // FTM2 channel 0 input capture source
    *    SimFtm2Ch1Src_IcPin,                      // FTM2 channel 1 input capture source
    *    SimFtm2ClkSel_FtmClkin0,                  // FTM2 External Clock Pin
    *    SimFtm3Flt0_Ftm3Fault0,                   // FTM3 Fault 0 Select
    *    SimFtm3Trg0Src_Ftm1,                      // FTM3 Hardware Trigger 0 Source
    *    SimFtm3Trg1Src_Ftm2,                      // FTM3 Hardware Trigger 1 Source
    *    SimFtm3ClkSel_FtmClkin0,                  // FTM3 External Clock Pin
    *    SimUart0RxSrc_RxPin,                      // UART 0 receive data source
    *    SimUart0TxSrc_Direct,                     // UART 0 transmit data source
    *    SimLpuart0RxSrc_RxPin,                    // LPUART 0 receive data source
    *    SimUart1RxSrc_RxPin,                      // UART 1 receive data source
    *    SimUart1TxSrc_Direct,                     // UART 1 transmit data source
    *    SimAdc0TriggerMode_Pdb ,                  // ADC0 trigger mode
    *    SimAdc0TriggerSrc_External,               // ADC0 trigger
    *    SimAdc1TriggerMode_Pdb ,                  // ADC1 trigger mode
    *    SimAdc1TriggerSrc_External,               // ADC1 trigger
    *    SimFtm0Ch0OutputSrc_Direct,               // FTM0 channel 0 output source
    *    SimFtm3Ch0OutputSrc_Direct,               // FTM3 channel 0 output source
    *    SimFtm0Ch1OutputSrc_Direct,               // FTM0 channel 1 output source
    *    SimFtm3Ch1OutputSrc_Direct,               // FTM3 channel 1 output source
    *    SimFtm0Ch2OutputSrc_Direct,               // FTM0 channel 2 output source
    *    SimFtm3Ch2OutputSrc_Direct,               // FTM3 channel 2 output source
    *    SimFtm0Ch3OutputSrc_Direct,               // FTM0 channel 3 output source
    *    SimFtm3Ch3OutputSrc_Direct,               // FTM3 channel 3 output source
    *    SimFtm0Ch4OutputSrc_Direct,               // FTM0 channel 4 output source
    *    SimFtm3Ch4OutputSrc_Direct,               // FTM3 channel 4 output source
    *    SimFtm0Ch5OutputSrc_Direct,               // FTM0 channel 5 output source
    *    SimFtm3Ch5OutputSrc_Direct,               // FTM3 channel 5 output source
    *    SimFtm0Ch6OutputSrc_Direct,               // FTM0 channel 6 output source
    *    SimFtm3Ch6OutputSrc_Direct,               // FTM3 channel 6 output source
    *    SimFtm0Ch7OutputSrc_Direct,               // FTM0 channel 7 output source
    *    SimFtm3Ch7OutputSrc_Direct,               // FTM3 channel 7 output source
    *    SimTpm1ClkSel_TpmClkin0,                  // TPM1 External Clock Pin
    *    SimTpm1Ch0Src_IcPin,                      // TPM1 channel 0 input capture source
    *    SimTpm2ClkSel_TpmClkin0,                  // TPM2 External Clock Pin
    *    SimTpm2Ch0Src_IcPin,                      // TPM2 channel 0 input capture source
    * };
    *
    * // Initialise SIM from values specified above
    * Sim::configure(simInit);
    * @endcode
    */
   class Init {
   
   public:
   /**
    * Copy Constructor
    */
   constexpr Init(const Init &other) = default;
   
   /**
    * Default Constructor
    */
   constexpr Init() = default;
   
      /// System Options Register 1
      uint32_t sopt1 = 0;

      /// System Options Register 2
      uint32_t sopt2 = 0;

      /// System Options Register 4
      uint32_t sopt4 = 0;

      /// System Options Register 5
      uint32_t sopt5 = 0;

      /// System Options Register 7
      uint32_t sopt7 = 0;

   
   public:
      /**
       * Constructor for Peripheral Clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPeripheralClockSource Clock for various peripherals (LPUART, TPM etc.)
       *        If there is a peripheral clock divider then this is the
       *        Frequency of the undivided peripheral clock
       */
      template <typename... Types>
      constexpr Init(SimPeripheralClockSource simPeripheralClockSource, Types... rest) : Init(rest...) {
   
         sopt2 |= simPeripheralClockSource;
      }
   
      /**
       * Constructor for USB Clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUsbFullSpeedClockSource Source for the USB clock
       */
      template <typename... Types>
      constexpr Init(SimUsbFullSpeedClockSource simUsbFullSpeedClockSource, Types... rest) : Init(rest...) {
   
         sopt2 |= simUsbFullSpeedClockSource;
      }
   
      /**
       * Constructor for CLKOUT pin clock
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simClkoutSel Clock to output on the CLKOUT pin
       */
      template <typename... Types>
      constexpr Init(SimClkoutSel simClkoutSel, Types... rest) : Init(rest...) {
   
         sopt2 |= simClkoutSel;
      }
   
      /**
       * Constructor for ERCLK32K clock source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simErc32kSel Clock source for External 32k Reference Clock [ERCLK32K]
       */
      template <typename... Types>
      constexpr Init(SimErc32kSel simErc32kSel, Types... rest) : Init(rest...) {
   
         sopt1 |= simErc32kSel;
      }
   
      /**
       * Constructor for USB voltage regulator power control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUsbPower Controls when the USB voltage regulator is enabled in
       *        (RUN), (STOP, VLPS, LLS and VLLS) or (VLPR and VLPW) modes
       */
      template <typename... Types>
      constexpr Init(SimUsbPower simUsbPower, Types... rest) : Init(rest...) {
   
         sopt1 |= simUsbPower;
      }
   
      /**
       * Constructor for PTD7 pad drive strength
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPortDPad Controls the output drive strength of the PTD7 pin
       *        by selecting either one or two pads to drive it
       */
      template <typename... Types>
      constexpr Init(SimPortDPad simPortDPad, Types... rest) : Init(rest...) {
   
         sopt2 |= simPortDPad;
      }
   
      /**
       * Constructor for Debug trace clock select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simTraceClockoutSel Selects the core/system clock or MCG output clock (MCGOUTCLK) as the trace clock source
       *        The chosen clock is divided by 2.
       */
      template <typename... Types>
      constexpr Init(SimTraceClockoutSel simTraceClockoutSel, Types... rest) : Init(rest...) {
   
         sopt2 |= simTraceClockoutSel;
      }
   
      /**
       * Constructor for RTC clock out source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simRtcClkoutSel Clock output on the RTC_CLKOUT pin
       */
      template <typename... Types>
      constexpr Init(SimRtcClkoutSel simRtcClkoutSel, Types... rest) : Init(rest...) {
   
         sopt2 |= simRtcClkoutSel;
      }
   
      /**
       * Constructor for FTM0 Fault 0 Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtm0Flt0 Source of FTM fault input 0
       */
      template <typename... Types>
      constexpr Init(SimFtm0Flt0 simFtm0Flt0, Types... rest) : Init(rest...) {
   
         sopt4 |= simFtm0Flt0;
      }
   
      /**
       * Constructor for FTM0 Hardware Trigger 0 Source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtm0Trg0Src Source of FTM 0 hardware trigger 0
       */
      template <typename... Types>
      constexpr Init(SimFtm0Trg0Src simFtm0Trg0Src, Types... rest) : Init(rest...) {
   
         sopt4 |= simFtm0Trg0Src;
      }
   
      /**
       * Constructor for FTM0 Fault 1 Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtm0Flt1 Source of FTM fault input 1
       */
      template <typename... Types>
      constexpr Init(SimFtm0Flt1 simFtm0Flt1, Types... rest) : Init(rest...) {
   
         sopt4 |= simFtm0Flt1;
      }
   
      /**
       * Constructor for FTM0 External Clock Pin
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtm0ClkSel External pin used to drive the clock to the FTM module
       */
      template <typename... Types>
      constexpr Init(SimFtm0ClkSel simFtm0ClkSel, Types... rest) : Init(rest...) {
   
         sopt4 |= simFtm0ClkSel;
      }
   
      /**
       * Constructor for FTM1 Fault 0 Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtm1Flt0 Source of FTM fault input 0
       */
      template <typename... Types>
      constexpr Init(SimFtm1Flt0 simFtm1Flt0, Types... rest) : Init(rest...) {
   
         sopt4 |= simFtm1Flt0;
      }
   
      /**
       * Constructor for FTM 1 channel 0 input capture source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtm1Ch0Src Source for FTM channel 0 input capture
       *        NOTE: When the FTM is not in input capture mode, clear this field
       */
      template <typename... Types>
      constexpr Init(SimFtm1Ch0Src simFtm1Ch0Src, Types... rest) : Init(rest...) {
   
         sopt4 |= simFtm1Ch0Src;
      }
   
      /**
       * Constructor for FTM1 External Clock Pin
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simFtm1ClkSel External pin used to drive the clock to the FTM module
       */
      template <typename... Types>
      constexpr Init(SimFtm1ClkSel simFtm1ClkSel, Types... rest) : Init(rest...) {
   
         sopt4 |= simFtm1ClkSel;
      }
   
      /**
       * Constructor for UART0 receive data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart0RxSrc Source for the UART0 receive data
       */
      template <typename... Types>
      constexpr Init(SimUart0RxSrc simUart0RxSrc, Types... rest) : Init(rest...) {
   
         sopt5 |= simUart0RxSrc;
      }
   
      /**
       * Constructor for UART0 transmit data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart0TxSrc Source for the UART0 transmit data
       */
      template <typename... Types>
      constexpr Init(SimUart0TxSrc simUart0TxSrc, Types... rest) : Init(rest...) {
   
         sopt5 |= simUart0TxSrc;
      }
   
      /**
       * Constructor for UART1 receive data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart1RxSrc Source for the UART1 receive data
       */
      template <typename... Types>
      constexpr Init(SimUart1RxSrc simUart1RxSrc, Types... rest) : Init(rest...) {
   
         sopt5 |= simUart1RxSrc;
      }
   
      /**
       * Constructor for UART1 transmit data source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simUart1TxSrc Source for the UART1 transmit data
       */
      template <typename... Types>
      constexpr Init(SimUart1TxSrc simUart1TxSrc, Types... rest) : Init(rest...) {
   
         sopt5 |= simUart1TxSrc;
      }
   
      /**
       * Constructor for ADC0 trigger mode and ADC0 trigger source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simAdc0TriggerMode Alternative conversion triggers for ADC
       *        _Pdb              - ADC is triggered by PDB
       *        _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
       *        _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
       * @param simAdc0TriggerSrc  ADC Trigger source in STOP and VLPS modes, or when ADC Alternative Trigger is active
       */
      template <typename... Types>
      constexpr Init(
            SimAdc0TriggerMode simAdc0TriggerMode,
            SimAdc0TriggerSrc  simAdc0TriggerSrc  = SimAdc0TriggerSrc_External, Types... rest) : Init(rest...) {
   
         sopt7 |= simAdc0TriggerMode|simAdc0TriggerSrc;
      }
   
   };

}; // class SimBasicInfo 

class SimInfo : public SimBasicInfo {

public:
   /*
    * Template:sim_mk20d5
    */
   /**
    * Basic enable of Sim
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
   }
   
   /**
    * Disables Sim
    */
   static void disable() {
   
      
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SIM_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<SIM_Type> sim = baseAddress;
   
   /// This input is available as a FTM external clock source
   static constexpr uint32_t FtmClkin0 =  0_Hz;  // (FtmClkin0)                FTM External clock input #0;
   
   /// This input is available as a FTM external clock source
   static constexpr uint32_t FtmClkin1 =  0_Hz;  // (FtmClkin1)                FTM External clock input #1;
   
   /**
    * Set FTM0 External Clock Pin
    *
    * @param simFtm0ClkSel External pin used to drive the clock to the FTM module
    */
   static void setFtm0ExternalClock(SimFtm0ClkSel simFtm0ClkSel) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM0CLKSEL_MASK) | simFtm0ClkSel;
   }
   
   /**
    * Get FTM0 External Clock Pin
    *
    * @return External pin used to drive the clock to the FTM module
    */
   static SimFtm0ClkSel getFtm0ExternalClock() {
   
      return SimFtm0ClkSel(sim->SOPT4&SIM_SOPT4_FTM0CLKSEL_MASK);
   }
   
   
   /**
    * Get FTM0 External Clock Pin frequency
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getFtm0ExternalClockFrequency() {
   
      switch(sim->SOPT4&SIM_SOPT4_FTM0CLKSEL_MASK) {
         default: return 0;
         case SimFtm0ClkSel_FtmClkin0 : return FtmClkin0; ///< FTM_CLKIN0 pin
         case SimFtm0ClkSel_FtmClkin1 : return FtmClkin1; ///< FTM_CLKIN1 pin

      }
   }

   /**
    * Set FTM1 External Clock Pin
    *
    * @param simFtm1ClkSel External pin used to drive the clock to the FTM module
    */
   static void setFtm1ExternalClock(SimFtm1ClkSel simFtm1ClkSel) {
      sim->SOPT4 = (sim->SOPT4&~SIM_SOPT4_FTM1CLKSEL_MASK) | simFtm1ClkSel;
   }
   
   /**
    * Get FTM1 External Clock Pin
    *
    * @return External pin used to drive the clock to the FTM module
    */
   static SimFtm1ClkSel getFtm1ExternalClock() {
   
      return SimFtm1ClkSel(sim->SOPT4&SIM_SOPT4_FTM1CLKSEL_MASK);
   }
   
   
   /**
    * Get FTM1 External Clock Pin frequency
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getFtm1ExternalClockFrequency() {
   
      switch(sim->SOPT4&SIM_SOPT4_FTM1CLKSEL_MASK) {
         default: return 0;
         case SimFtm1ClkSel_FtmClkin0 : return FtmClkin0; ///< FTM_CLKIN0 pin
         case SimFtm1ClkSel_FtmClkin1 : return FtmClkin1; ///< FTM_CLKIN1 pin

      }
   }

   //! Frequency of Low Power Oscillator (LPO) Clock [~1kHz]
   static constexpr uint32_t system_low_power_clock = 1000UL;

   /**
    * Get LPO clock
    *
    * @return frequency in Hz as uint32_t
    */
   static constexpr uint32_t getLpoClock() {
      return system_low_power_clock;
   }

   /*
    * Template:sim_commonTemplates.xml
    */ 
   /**
    * Set RTC clock out source
    *
    * @param simRtcClkoutSel Clock output on the RTC_CLKOUT pin
    */
   static void setRtcClockout(SimRtcClkoutSel simRtcClkoutSel) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_RTCCLKOUTSEL_MASK) | simRtcClkoutSel;
   }

   ///  Frequency of External USB Clock
   static constexpr uint32_t usbExternalClock=0;

   /**
    * Get chip unique 32-bit ID value UIDH
    */
   static uint32_t getUidh() {
      return sim->UIDH;
   }
   
   /**
    * Get chip unique 32-bit ID value UIDMH
    */
   static uint32_t getUidmh() {
      return sim->UIDMH;
   }
   
   /**
    * Get chip unique 32-bit ID value UIDML
    */
   static uint32_t getUidml() {
      return sim->UIDML;
   }
   
   /**
    * Get chip unique 32-bit ID value UIDL
    */
   static uint32_t getUidl() {
      return sim->UIDL;
   }
   
   /**
    * Get RAM size
    *
    * @return RAM size value
    */
   static SimRamSize getRamSize() {
   
      return static_cast<SimRamSize>(sim->SOPT1&SIM_SOPT1_RAMSIZE_MASK);
   }

   /**
    * Set ERCLK32K clock source
    *
    * @param simErc32kSel Clock source for External 32k Reference Clock [ERCLK32K]
    */
   static void setErc32kClock(SimErc32kSel simErc32kSel) {
      sim->SOPT1 = (sim->SOPT1&~SIM_SOPT1_OSC32KSEL_MASK) | simErc32kSel;
   }

   /**
    * Get ERCLK32K clock source
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getErc32kClock() {
   
      switch(sim->SOPT1&SIM_SOPT1_OSC32KSEL_MASK) {
         default: return 0;
         case SimErc32kSel_Osc32kClk : return Osc0Info::getOsc32kClock();  ///< OSC0 in low range (OSC32KCLK)
         case SimErc32kSel_Rtc32kClk : return RtcInfo::getExternalClock(); ///< RTC 32kHz clock
         case SimErc32kSel_LpoClk    : return SimInfo::getLpoClock();      ///< LPO 1kHz clock

      }
   }

   /**
    * Set CLKOUT pin clock
    *
    * @param simClkoutSel Clock to output on the CLKOUT pin
    */
   static void setClkout(SimClkoutSel simClkoutSel) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_CLKOUTSEL_MASK) | simClkoutSel;
   }
   
   /**
    * Get CLKOUT pin clock
    *
    * @return Clock to output on the CLKOUT pin
    */
   static uint32_t getClkout() {
   
      return sim->SOPT2&SIM_SOPT2_CLKOUTSEL_MASK;
   }

   /**
    * Set Peripheral Clock
    *
    * @param simPeripheralClockSource Clock for various peripherals (LPUART, TPM etc.)
    *        If there is a peripheral clock divider then this is the
    *        Frequency of the undivided peripheral clock
    */
   static void setPeripheralClock(SimPeripheralClockSource simPeripheralClockSource) {
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_PLLFLLSEL_MASK) | simPeripheralClockSource;
   }

   /**
    * Get Peripheral Clock
    *  Clock for various peripherals (LPUART, TPM etc.)
    *        If there is a peripheral clock divider then this is the
    *        Frequency of the undivided peripheral clock
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getPeripheralClock() {
   
      switch(sim->SOPT2&SIM_SOPT2_PLLFLLSEL_MASK) {
         default: return 0;
         case SimPeripheralClockSource_McgFllClk : return SystemMcgFllClock; ///< MCGFLLCLK clock
         case SimPeripheralClockSource_McgPllClk : return SystemMcgPllClock; ///< MCGPLLCLK clock

      }
   }

   /**
    * Get UART0 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart0Clock() {
      return SystemCoreClock;
   }

   /**
    * Get UART1 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart1Clock() {
      return SystemCoreClock;
   }

   /**
    * Get UART2 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart2Clock() {
      return SystemBusClock;
   }

   /**
    * Default initialisation value for Sim peripheral clock gating
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr ClockEnables DefaultClockEnables = {
      SimAdc0Clock_Disabled,  // (sim_scgc6_adc0)           Adc0 Clock Gate Control - Adc0 Clock disabled
      SimCmpClock_Disabled,  // (sim_scgc4_cmp)            Cmp Clock Gate Control - Cmp Clock disabled
      SimCmtClock_Disabled,  // (sim_scgc4_cmt)            Cmt Clock Gate Control - Cmt Clock disabled
      SimCrcClock_Disabled,  // (sim_scgc6_crc)            Crc Clock Gate Control - Crc Clock disabled
      SimDma0Clock_Disabled,  // (sim_scgc7_dma0)           Dma0 Clock Gate Control - Dma0 Clock disabled
      SimDmamux0Clock_Disabled,  // (sim_scgc6_dmamux0)        Dmamux0 Clock Gate Control - Dmamux0 Clock disabled
      SimEwmClock_Disabled,  // (sim_scgc4_ewm)            Ewm Clock Gate Control - Ewm Clock disabled
      SimFtflClock_Disabled,  // (sim_scgc6_ftfl)           Ftfl Clock Gate Control - Ftfl Clock disabled
      SimFtm0Clock_Disabled,  // (sim_scgc6_ftm0)           Ftm0 Clock Gate Control - Ftm0 Clock disabled
      SimFtm1Clock_Disabled,  // (sim_scgc6_ftm1)           Ftm1 Clock Gate Control - Ftm1 Clock disabled
      SimI2c0Clock_Disabled,  // (sim_scgc4_i2c0)           I2c0 Clock Gate Control - I2c0 Clock disabled
      SimI2s0Clock_Disabled,  // (sim_scgc6_i2s0)           I2s0 Clock Gate Control - I2s0 Clock disabled
      SimLptmr0Clock_Disabled,  // (sim_scgc5_lptmr0)         Lptmr0 Clock Gate Control - Lptmr0 Clock disabled
      SimPdbClock_Disabled,  // (sim_scgc6_pdb)            Pdb Clock Gate Control - Pdb Clock disabled
      SimPitClock_Disabled,  // (sim_scgc6_pit)            Pit Clock Gate Control - Pit Clock disabled
      SimPortaClock_Disabled,  // (sim_scgc5_porta)          Porta Clock Gate Control - Porta Clock disabled
      SimPortbClock_Disabled,  // (sim_scgc5_portb)          Portb Clock Gate Control - Portb Clock disabled
      SimPortcClock_Disabled,  // (sim_scgc5_portc)          Portc Clock Gate Control - Portc Clock disabled
      SimPortdClock_Disabled,  // (sim_scgc5_portd)          Portd Clock Gate Control - Portd Clock disabled
      SimPorteClock_Disabled,  // (sim_scgc5_porte)          Porte Clock Gate Control - Porte Clock disabled
      SimRtcClock_Disabled,  // (sim_scgc6_rtc)            Rtc Clock Gate Control - Rtc Clock disabled
      SimSpi0Clock_Disabled,  // (sim_scgc6_spi0)           Spi0 Clock Gate Control - Spi0 Clock disabled
      SimTsi0Clock_Disabled,  // (sim_scgc5_tsi0)           Tsi0 Clock Gate Control - Tsi0 Clock disabled
      SimUart0Clock_Disabled,  // (sim_scgc4_uart0)          Uart0 Clock Gate Control - Uart0 Clock disabled
      SimUart1Clock_Disabled,  // (sim_scgc4_uart1)          Uart1 Clock Gate Control - Uart1 Clock disabled
      SimUart2Clock_Disabled,  // (sim_scgc4_uart2)          Uart2 Clock Gate Control - Uart2 Clock disabled
      SimUsb0Clock_Disabled,  // (sim_scgc4_usb0)           Usb0 Clock Gate Control - Usb0 Clock disabled
      SimUsbdcdClock_Disabled,  // (sim_scgc6_usbdcd)         Usbdcd Clock Gate Control - Usbdcd Clock disabled
      SimVrefClock_Disabled,  // (sim_scgc4_vref)           Vref Clock Gate Control - Vref Clock disabled
   };
   
   /**
    * Configure peripheral clock gating from values specified in init
    *
    * @param init Class containing initialisation values
    */
   static void configureClocks(const ClockEnables &init) {
   
      sim->SCGC4  = init.scgc4;
      sim->SCGC5  = init.scgc5;
      sim->SCGC6  = init.scgc6;
      sim->SCGC7  = init.scgc7;
   }
   
   /**
    * Enable peripheral clock gating from values specified in init
    *
    * @param init Class containing initialisation values
    */
   static void enableClocks(const ClockEnables &init) {
   
      sim->SCGC4  |= init.scgc4;
      sim->SCGC5  |= init.scgc5;
      sim->SCGC6  |= init.scgc6;
      sim->SCGC7  |= init.scgc7;
   }
   
   /**
    * Disable peripheral clock gating from values specified in init
    *
    * @param init Class containing initialisation values
    */
   static void disableClocks(const ClockEnables &init) {
   
      sim->SCGC4  &= ~ init.scgc4;
      sim->SCGC5  &= ~ init.scgc5;
      sim->SCGC6  &= ~ init.scgc6;
      sim->SCGC7  &= ~ init.scgc7;
   }
   
   /**
    * Configure SIM Clock control from values specified in constructor.
    */
   static void configure(const ClockSourceInit &clockSourceInit) {

      sim->SOPT2 = clockSourceInit.sopt2;
   }

   /**
    * Default value for Sim::ClockSourceInit
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr ClockSourceInit DefaultClockSouceInitValues[] = {
   { // ClockConfig_RUN_PEE_48MHz (McgClockMode_PEE)
      SimPeripheralClockSource_McgFllClk , // (sim_sopt2_pllfllsel[0])   Peripheral Clock - MCGFLLCLK clock
      SimUsbFullSpeedClockSource_PeripheralClk , // (sim_sopt2_usbsrc[0])      USB Clock - Peripheral Clock/SIM_CLKDIV2
      SimClkoutSel_FlashClk , // (sim_sopt2_clkoutsel[0])   CLKOUT pin clock - Flash clock
      SimRtcClkoutSel_32kHz , // (sim_sopt2_rtcclkoutsel)   RTC clock out source - RTC 32kHz clock
      SimTraceClockoutSel_McgOutClk , // (sim_sopt2_traceclksel)    Debug trace clock select - MCGOUTCLK
      SimPortDPad_Single,  // (sim_sopt2_ptd7pad)        PTD7 pad drive strength - Single-pad drive strength
   },
};

   /**
    * Configure Uart0 signals from values specified in constructor.
    */
   static void configure(const Uart0Init &config) {

      sim->SOPT5 = (sim->SOPT5&~(SIM_SOPT5_UART0TXSRC_MASK|SIM_SOPT5_UART0RXSRC_MASK)) | config.sopt5;
   }
   
   /**
    * Configure Uart1 signals from values specified in constructor.
    */
   static void configure(const Uart1Init &config) {

      sim->SOPT5 = (sim->SOPT5&~(SIM_SOPT5_UART1TXSRC_MASK|SIM_SOPT5_UART1RXSRC_MASK)) | config.sopt5;
   }
   
   /**
    * Configure ADC trigger sources from values specified
    */
   static void configure(const AdcHardwareTriggerInit &config) {

      sim->SOPT7 = (sim->SOPT7&~(SIM_SOPT7_ADC0ALTTRGEN_MASK|SIM_SOPT7_ADC0PRETRGSEL_MASK|SIM_SOPT7_ADC0TRGSEL_MASK)) |
                   config.sopt7;
   }
   
   /**
    * Default initialisation value for ADC hardware triggers
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr AdcHardwareTriggerInit DefaultAdcHardwareTriggerInitValue = {
      SimAdc0TriggerMode_Pdb , // (sim_sopt7_adc0trigger)    ADC0 trigger mode - Triggered by PDB
   };
   
   /**
    * Configure Adc signals from values specified
    */
   static void configure(const Adc0Init &config) {

      sim->SOPT7 = (sim->SOPT7&~(SIM_SOPT7_ADC0ALTTRGEN_MASK|SIM_SOPT7_ADC0PRETRGSEL_MASK|SIM_SOPT7_ADC0TRGSEL_MASK)) | config.sopt7;
   }
   
   /**
    * Set USB Clock
    *
    * If the internal clock is selected then the clock divider will be recalculated
    *
    * @param simUsbFullSpeedClockSource Source for the USB clock
    */
   static ErrorCode setUsbFullSpeedClock(SimUsbFullSpeedClockSource simUsbFullSpeedClockSource) {
      ErrorCode rc = E_NO_ERROR;
   
      // The USB interface must be disabled for clock changes to have effect
      sim->SCGC4 = sim->SCGC4 & ~SIM_SCGC4_USB0_MASK;
   
      // Set clock source
      sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_USBSRC_MASK) | simUsbFullSpeedClockSource;
   
      if (simUsbFullSpeedClockSource == SimUsbFullSpeedClockSource_PeripheralClk) {
         // Set clock divider for internal clock
         rc = E_CLOCK_INIT_FAILED;
         // Try to calculate value
         unsigned inputFreq = getPeripheralClock();
         for (unsigned frac = 0; frac < 2; frac++) {
            for (unsigned div = 0; div < 8; div++) {
               unsigned usbClock = (inputFreq * (frac+1))/(div+1);
               if (usbClock == 48000000) {
                  // Found suitable value
                  sim->CLKDIV2 = SIM_CLKDIV2_USBFRAC(frac)|SIM_CLKDIV2_USBDIV(div);
                  rc = E_NO_ERROR;
               }
            }
         }
      }
      rc = setErrorCode(rc);

      // Restore USB clock
      sim->SCGC4 = sim->SCGC4 | SIM_SCGC4_USB0_MASK;
      return rc;
   }

   /**
    * Get USB clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getUsbFullSpeedClock() {
      switch ((sim->SOPT2&SIM_SOPT2_USBSRC_MASK)) {
         default:
         case SimUsbFullSpeedClockSource_External : return usbExternalClock;
         case SimUsbFullSpeedClockSource_PeripheralClk :
            return  (getPeripheralClock()*
               (((sim->CLKDIV2&SIM_CLKDIV2_USBFRAC_MASK)>>SIM_CLKDIV2_USBFRAC_SHIFT)+1))/
               (((sim->CLKDIV2&SIM_CLKDIV2_USBDIV_MASK)>>SIM_CLKDIV2_USBDIV_SHIFT)+1);
      }
   }

   /**
    * Set USB clock divisors to suitable value and enable clock
    */
   static void updateUsbClockDivider() {
   
      setUsbFullSpeedClock((SimUsbFullSpeedClockSource)(sim->SOPT2&SIM_SOPT2_USBSRC_MASK));
   }

   /**
    * Configure SIM from values specified in config
    */
   static void configure(const Init &config) {
      sim->SOPT1CFG = SIM_SOPT1CFG_USSWE_MASK|SIM_SOPT1CFG_UVSWE_MASK|SIM_SOPT1CFG_URWE_MASK;
      sim->SOPT1 = config.sopt1;
      sim->SOPT2 = config.sopt2;   // SOPT2 may also be altered by MCG clock code
      sim->SOPT4 = config.sopt4;
      sim->SOPT5 = config.sopt5;
      sim->SOPT7 = config.sopt7;
   
      updateUsbClockDivider();
   }
   
   static void defaultConfigure() {
      configure(DefaultInitValue);
   }
   
   /**
    * Default value for Sim::DefaultInit
    * This value is created from Configure.usbdmProject settings (Peripheral Parameters->SIM)
    */
   static constexpr Init DefaultInitValue {
      SimPeripheralClockSource_McgFllClk ,   // (sim_sopt2_pllfllsel[0])   Peripheral Clock - MCGFLLCLK clock
      SimUsbFullSpeedClockSource_PeripheralClk , // (sim_sopt2_usbsrc[0])      USB Clock - Peripheral Clock/SIM_CLKDIV2
      SimClkoutSel_FlashClk ,                // (sim_sopt2_clkoutsel[0])   CLKOUT pin clock - Flash clock
      SimRtcClkoutSel_32kHz ,                // (sim_sopt2_rtcclkoutsel)   RTC clock out source - RTC 32kHz clock
      SimTraceClockoutSel_McgOutClk ,        // (sim_sopt2_traceclksel)    Debug trace clock select - MCGOUTCLK
      SimErc32kSel_Rtc32kClk ,               // (sim_sopt1_osc32ksel)      ERCLK32K clock source - RTC 32kHz clock
      SimUsbPower_EnabledInAll ,             // (sim_sopt1_usbpower)       USB voltage regulator power control - Enabled in all modes
      SimPortDPad_Single,                    // (sim_sopt2_ptd7pad)        PTD7 pad drive strength - Single-pad drive strength
      SimFtm0Flt0_Ftm0Fault0,  // (sim_sopt4_ftm0flt0)       FTM0 Fault 0 Select - FTM0_FLT0 pin
      SimFtm0Trg0Src_Cmp0,  // (sim_sopt4_ftm0trg0src)    FTM0 Hardware Trigger 0 Source - CMP0 output
      SimFtm0Flt1_Ftm0Fault1,  // (sim_sopt4_ftm0flt1)       FTM0 Fault 1 Select - FTM0_FLT1 pin
      SimFtm0ClkSel_FtmClkin0,  // (sim_sopt4_ftm0clksel)     FTM0 External Clock Pin - FTM_CLKIN0 pin
      SimFtm1Flt0_Ftm1Fault0,  // (sim_sopt4_ftm1flt0)       FTM1 Fault 0 Select - FTM1_FLT0 pin
      SimFtm1Ch0Src_IcPin,  // (sim_sopt4_ftm1ch0src)     FTM 1 channel 0 input capture source - FTM1_CH0 signal
      SimFtm1ClkSel_FtmClkin0,  // (sim_sopt4_ftm1clksel)     FTM1 External Clock Pin - FTM_CLKIN0 pin
      SimUart0RxSrc_RxPin,  // (sim_sopt5_uart0rxsrc)     UART0 receive data source - Rx pin
      SimUart0TxSrc_Direct,  // (sim_sopt5_uart0txsrc)     UART0 transmit data source - Tx pin
      SimUart1RxSrc_RxPin,  // (sim_sopt5_uart1rxsrc)     UART1 receive data source - Rx pin
      SimUart1TxSrc_Direct,  // (sim_sopt5_uart1txsrc)     UART1 transmit data source - Tx pin
      SimAdc0TriggerMode_Pdb , // (sim_sopt7_adc0trigger)    ADC0 trigger mode - Triggered by PDB
      SimAdc0TriggerSrc_External,  // (sim_sopt7_adc0trgsel)     ADC0 trigger source - External trigger pin input (PDB0_EXTRG)
   };

   /**
    * Update system clock values
    *
    * @param systemClock Frequency of clock provided to system clock dividers
    */
   static void updateSystemClocks(unsigned systemClock) {
   
      SystemCoreClock    = systemClock/(((SIM->CLKDIV1&SIM_CLKDIV1_OUTDIV1_MASK)>>SIM_CLKDIV1_OUTDIV1_SHIFT)+1);
      SystemBusClock     = systemClock/(((SIM->CLKDIV1&SIM_CLKDIV1_OUTDIV2_MASK)>>SIM_CLKDIV1_OUTDIV2_SHIFT)+1);
   #ifdef SIM_CLKDIV1_OUTDIV3_MASK
      SystemFlexbusClock = systemClock/(((SIM->CLKDIV1&SIM_CLKDIV1_OUTDIV3_MASK)>>SIM_CLKDIV1_OUTDIV3_SHIFT)+1);
   #endif
   #ifdef SIM_CLKDIV1_OUTDIV4_MASK
   //   SystemFlashClock = systemClock/(((SIM->CLKDIV1&SIM_CLKDIV1_OUTDIV4_MASK)>>SIM_CLKDIV1_OUTDIV4_SHIFT)+1);
   #endif
   }

   /** Reset clock divider value if clock not fully configured */
   static constexpr uint32_t sim_clkdiv1 = 
      SimCoreClkDivider_DivBy2 | // (sim_clkdiv1_outdiv1[0])   Core &amp; System Clock Divider (OUTDIV1) - Divide by [1-16] - /2
      SimBusClkDivider_DivBy2 | // (sim_clkdiv1_outdiv2[0])   Bus Clock Divider (OUTDIV2) - Divide by [1-16] - /2
      SimFlashClkDivider_DivBy4;  // (sim_clkdiv1_outdiv4[0])   Flash Clock Divider (OUTDIV4) - Divide by [1-16] - /4;
   
}; // class SimInfo

/** 
 * End group SIM_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Abstraction for Control
 * @{
 */
/**
 * Peripheral information for CONTROL, Control.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ControlInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 10;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: RESET_b              = RESET_b(p26)                   */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   1: JTAG_TCLK            = PTA0(p17)                      */  { PinIndex::PTA0,         PcrValue(0x00700UL) },
         /*   2: SWD_CLK              = PTA0(p17)                      */  { PinIndex::PTA0,         PcrValue(0x00700UL) },
         /*   3: JTAG_TDI             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: JTAG_TDO             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   5: TRACE_SWO            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   6: JTAG_TMS             = PTA3(p20)                      */  { PinIndex::PTA3,         PcrValue(0x00700UL) },
         /*   7: SWD_DIO              = PTA3(p20)                      */  { PinIndex::PTA3,         PcrValue(0x00700UL) },
         /*   8: NMI_b                = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   9: JTAG_TRST_b          = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK);
      PORTA->GPCLR = (0x0700UL|PORT_GPCLR_GPWE(0x0009UL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK);
      PORTA->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0009UL);
   }

   /*
    * Template:control
    */
using JTAG_TCLK_pin        = PcrTable_T<ControlInfo, 1>;
using SWD_CLK_pin          = PcrTable_T<ControlInfo, 2>;
using JTAG_TMS_pin         = PcrTable_T<ControlInfo, 6>;
using SWD_DIO_pin          = PcrTable_T<ControlInfo, 7>;

}; // class ControlInfo

/** 
 * End group Control_Group
 * @}
 */
/**
 * @addtogroup CONSOLE_Group Console, Console Interface
 * @brief Abstraction for Console Interface
 * @{
 */
/**
 * Peripheral information for Console, Console Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * UART baud rate
    * (console_baudrate)
    *
    * Baud rate for UART
    * Values available will depend on peripheral clock frequency
    */
   enum UartBaudRate : uint32_t {
      UartBaudRate_110      = 110,     ///< 110
      UartBaudRate_300      = 300,     ///< 300
      UartBaudRate_600      = 600,     ///< 600
      UartBaudRate_1200     = 1200,    ///< 1200
      UartBaudRate_2400     = 2400,    ///< 2400
      UartBaudRate_4800     = 4800,    ///< 4800
      UartBaudRate_9600     = 9600,    ///< 9600
      UartBaudRate_14400    = 14400,   ///< 14400
      UartBaudRate_19200    = 19200,   ///< 19200
      UartBaudRate_28800    = 28800,   ///< 28800
      UartBaudRate_38400    = 38400,   ///< 38400
      UartBaudRate_56000    = 56000,   ///< 56000
      UartBaudRate_57600    = 57600,   ///< 57600
      UartBaudRate_115200   = 115200,  ///< 115200
   };

class ConsoleInfo {

public:
   /*
    * Template:console
    */
}; // class ConsoleInfo

/** 
 * End group CONSOLE_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtmInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: FTM_CLKIN0           = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: FTM_CLKIN1           = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:ftm
    */

}; // class FtmInfo

/** 
 * End group FTM_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Abstraction for Power
 * @{
 */
/**
 * Peripheral information for POWER, Power.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PowerInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 13;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: VBAT                 = VBAT(p16)                      */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   1: VDD1                 = VDD1(p1)                       */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   2: VDD2                 = VDD2(p22)                      */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   3: VDD3                 = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: VDDA                 = VDDA(p9)                       */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   5: VOUT33               = VOUT33(p5)                     */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   6: VREFH                = VREFH(p10)                     */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   7: VREFL                = VREFL(p11)                     */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   8: VREGIN               = VREGIN(p6)                     */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*   9: VSS1                 = VSS1(p2)                       */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*  10: VSS2                 = VSS2(p23)                      */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
         /*  11: VSS3                 = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  12: VSSA                 = VSSA(p12)                      */  { PinIndex::FIXED_NO_PCR, PcrValue(0)         },
   };

   /*
    * Template:power
    */
}; // class PowerInfo

/** 
 * End group Power_Group
 * @}
 */
/**
 * @addtogroup TSI_Group TSI, Touch Sense Interface
 * @brief Abstraction for Touch Sense Interface
 * @{
 */
/**
 * Peripheral information for TSI, Touch Sense Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Software Trigger
    * (tsi_gencs_swts)
    *
    * Used to start a scan when software trigger mode is selected
    */
   enum TsiSoftwareTrigger : uint32_t {
      TsiSoftwareTrigger_NoAction    = TSI_GENCS_SWTS(0),  ///< NoAction
      TsiSoftwareTrigger_StartScan   = TSI_GENCS_SWTS(1),  ///< Start scan
   };

   /**
    * Out of Range Flag
    * (tsi_gencs_outrgf)
    *
    * This flag is set when Out of Range is detected.
    * Write 1 , when this flag is set, to clear it.
    */
   enum TsiOutOfRangeFlag : uint32_t {
      TsiOutOfRangeFlag_InRange              = TSI_GENCS_OUTRGF(0),  ///< In Range
      TsiOutOfRangeFlag_OutOfRangeDetected   = TSI_GENCS_OUTRGF(1),  ///< Out of Range detected
   };

   /**
    * Select scan mode
    * (tsi_gencs_scanmode)
    *
    * Enables and selects between software triggered or automatic hardware scanning
    */
   enum TsiScanMode : uint32_t {
      TsiScanMode_Disabled    = TSI_GENCS_TSIEN(0)|TSI_GENCS_STM(0),  ///< Disabled
      TsiScanMode_Triggered   = TSI_GENCS_TSIEN(1)|TSI_GENCS_STM(0),  ///< Software triggered single scan
      TsiScanMode_Periodic    = TSI_GENCS_TSIEN(1)|TSI_GENCS_STM(1),  ///< Hardware scanning (repeated periodically)
   };

   /**
    * TSI STOP Enable
    * (tsi_gencs_stpe)
    *
    * Controls operation while in Low Power Modes (STOP, VLPS, LLS and VLLS{3,2,1})
    */
   enum TsiStopMode : uint32_t {
      TsiStopMode_Disabled   = TSI_GENCS_STPE(0),  ///< Disabled in low power
      TsiStopMode_Enabled    = TSI_GENCS_STPE(1),  ///< Enabled in low power
   };

   /**
    * Touch Sensing Input Event Enable
    * (tsi_gencs_intsource)
    *
    * Enables events from Out-of-Range and End-of-Scan conditions
    */
   enum TsiEventSource : uint32_t {
      TsiEventSource_Disabled     = TSI_GENCS_TSIIE(0)|TSI_GENCS_ESOR(0),  ///< Disabled
      TsiEventSource_OutOfRange   = TSI_GENCS_TSIIE(1)|TSI_GENCS_ESOR(0),  ///< Out Of Range
      TsiEventSource_EndOfScan    = TSI_GENCS_TSIIE(1)|TSI_GENCS_ESOR(1),  ///< End Of Scan
   };

   /**
    * Action on Error
    * (tsi_gencs_erie)
    *
    * Action taken on Short Detection or Overrun Error
    */
   enum TsiErrorAction : uint32_t {
      TsiErrorAction_None        = TSI_GENCS_ERIE(0),  ///< None
      TsiErrorAction_Interrupt   = TSI_GENCS_ERIE(1),  ///< Interrupt
   };

   /**
    * Consecutive Scan number
    * (tsi_gencs_nscn)
    *
    * Number of Consecutive Scans Per Electrode
    */
   enum TsiConsecutiveScan : uint32_t {
      TsiConsecutiveScan_1Time     = TSI_GENCS_NSCN(0),   ///< Scan Electrode 1 time
      TsiConsecutiveScan_2Times    = TSI_GENCS_NSCN(1),   ///< Scan Electrode 2 times
      TsiConsecutiveScan_3Times    = TSI_GENCS_NSCN(2),   ///< Scan Electrode 3 times
      TsiConsecutiveScan_4Times    = TSI_GENCS_NSCN(3),   ///< Scan Electrode 4 times
      TsiConsecutiveScan_5Times    = TSI_GENCS_NSCN(4),   ///< Scan Electrode 5 times
      TsiConsecutiveScan_6Times    = TSI_GENCS_NSCN(5),   ///< Scan Electrode 6 times
      TsiConsecutiveScan_7Times    = TSI_GENCS_NSCN(6),   ///< Scan Electrode 7 times
      TsiConsecutiveScan_8Times    = TSI_GENCS_NSCN(7),   ///< Scan Electrode 8 times
      TsiConsecutiveScan_9Times    = TSI_GENCS_NSCN(8),   ///< Scan Electrode 9 times
      TsiConsecutiveScan_10Times   = TSI_GENCS_NSCN(9),   ///< Scan Electrode 10 times
      TsiConsecutiveScan_11Times   = TSI_GENCS_NSCN(10),  ///< Scan Electrode 11 times
      TsiConsecutiveScan_12Times   = TSI_GENCS_NSCN(11),  ///< Scan Electrode 12 times
      TsiConsecutiveScan_13Times   = TSI_GENCS_NSCN(12),  ///< Scan Electrode 13 times
      TsiConsecutiveScan_14Times   = TSI_GENCS_NSCN(13),  ///< Scan Electrode 14 times
      TsiConsecutiveScan_15Times   = TSI_GENCS_NSCN(14),  ///< Scan Electrode 15 times
      TsiConsecutiveScan_16Times   = TSI_GENCS_NSCN(15),  ///< Scan Electrode 16 times
      TsiConsecutiveScan_17Times   = TSI_GENCS_NSCN(16),  ///< Scan Electrode 17 times
      TsiConsecutiveScan_18Times   = TSI_GENCS_NSCN(17),  ///< Scan Electrode 18 times
      TsiConsecutiveScan_19Times   = TSI_GENCS_NSCN(18),  ///< Scan Electrode 19 times
      TsiConsecutiveScan_20Times   = TSI_GENCS_NSCN(19),  ///< Scan Electrode 20 times
      TsiConsecutiveScan_21Times   = TSI_GENCS_NSCN(20),  ///< Scan Electrode 21 times
      TsiConsecutiveScan_22Times   = TSI_GENCS_NSCN(21),  ///< Scan Electrode 22 times
      TsiConsecutiveScan_23Times   = TSI_GENCS_NSCN(22),  ///< Scan Electrode 23 times
      TsiConsecutiveScan_24Times   = TSI_GENCS_NSCN(23),  ///< Scan Electrode 24 times
      TsiConsecutiveScan_25Times   = TSI_GENCS_NSCN(24),  ///< Scan Electrode 25 times
      TsiConsecutiveScan_26Times   = TSI_GENCS_NSCN(25),  ///< Scan Electrode 26 times
      TsiConsecutiveScan_27Times   = TSI_GENCS_NSCN(26),  ///< Scan Electrode 27 times
      TsiConsecutiveScan_28Times   = TSI_GENCS_NSCN(27),  ///< Scan Electrode 28 times
      TsiConsecutiveScan_29Times   = TSI_GENCS_NSCN(28),  ///< Scan Electrode 29 times
      TsiConsecutiveScan_30Times   = TSI_GENCS_NSCN(29),  ///< Scan Electrode 30 times
      TsiConsecutiveScan_31Times   = TSI_GENCS_NSCN(30),  ///< Scan Electrode 31 times
      TsiConsecutiveScan_32Times   = TSI_GENCS_NSCN(31),  ///< Scan Electrode 32 times
   };

   /**
    * Prescaler for Electrode Oscillator Frequency
    * (tsi_gencs_ps)
    *
    * Only be changed if the TSI module is disabled
    */
   enum TsiElectrodePrescaler : uint32_t {
      TsiElectrodePrescaler_DivBy1     = TSI_GENCS_PS(0),  ///< Divide by 1
      TsiElectrodePrescaler_DivBy2     = TSI_GENCS_PS(1),  ///< Divide by 2
      TsiElectrodePrescaler_DivBy4     = TSI_GENCS_PS(2),  ///< Divide by 4
      TsiElectrodePrescaler_DivBy8     = TSI_GENCS_PS(3),  ///< Divide by 8
      TsiElectrodePrescaler_DivBy16    = TSI_GENCS_PS(4),  ///< Divide by 16
      TsiElectrodePrescaler_DivBy32    = TSI_GENCS_PS(5),  ///< Divide by 32
      TsiElectrodePrescaler_DivBy64    = TSI_GENCS_PS(6),  ///< Divide by 64
      TsiElectrodePrescaler_DivBy128   = TSI_GENCS_PS(7),  ///< Divide by 128
   };

   /**
    * Low-Power Mode Scan Interval
    * (tsi_gencs_lpscnitv)
    *
    * 
    */
   enum TsiLowPowerScanInterval : uint32_t {
      TsiLowPowerScanInterval_1ms     = TSI_GENCS_LPSCNITV(0),   ///< 1 ms interval
      TsiLowPowerScanInterval_5ms     = TSI_GENCS_LPSCNITV(1),   ///< 5 ms interval
      TsiLowPowerScanInterval_10ms    = TSI_GENCS_LPSCNITV(2),   ///< 10 ms interval
      TsiLowPowerScanInterval_15ms    = TSI_GENCS_LPSCNITV(3),   ///< 15 ms interval
      TsiLowPowerScanInterval_20ms    = TSI_GENCS_LPSCNITV(4),   ///< 20 ms interval
      TsiLowPowerScanInterval_30ms    = TSI_GENCS_LPSCNITV(5),   ///< 30 ms interval
      TsiLowPowerScanInterval_40ms    = TSI_GENCS_LPSCNITV(6),   ///< 40 ms interval
      TsiLowPowerScanInterval_50ms    = TSI_GENCS_LPSCNITV(7),   ///< 50 ms interval
      TsiLowPowerScanInterval_75ms    = TSI_GENCS_LPSCNITV(8),   ///< 75 ms interval
      TsiLowPowerScanInterval_100ms   = TSI_GENCS_LPSCNITV(9),   ///< 100 ms interval
      TsiLowPowerScanInterval_125ms   = TSI_GENCS_LPSCNITV(10),  ///< 125 ms interval
      TsiLowPowerScanInterval_150ms   = TSI_GENCS_LPSCNITV(11),  ///< 150 ms interval
      TsiLowPowerScanInterval_200ms   = TSI_GENCS_LPSCNITV(12),  ///< 200 ms interval
      TsiLowPowerScanInterval_300ms   = TSI_GENCS_LPSCNITV(13),  ///< 300 ms interval
      TsiLowPowerScanInterval_400ms   = TSI_GENCS_LPSCNITV(14),  ///< 400 ms interval
      TsiLowPowerScanInterval_500ms   = TSI_GENCS_LPSCNITV(15),  ///< 500 ms interval
   };

   /**
    * Low-Power Mode Clock Source
    * (tsi_gencs_lpclks)
    *
    * 
    */
   enum TsiLowPowerClockSource : uint32_t {
      TsiLowPowerClockSource_LpoClk     = TSI_GENCS_LPCLKS(0),  ///< LPOCLK
      TsiLowPowerClockSource_Erclk32k   = TSI_GENCS_LPCLKS(1),  ///< VLPOSCCLK
   };

   /**
    * End of Scan Flag
    * (tsi_gencs_eosf)
    *
    * This flag is set when all active electrodes are finished scanning
    * after a scan trigger.
    * Write 1 , when this flag is set, to clear it.
    */
   enum TsiEndOfScanFlag : uint32_t {
      TsiEndOfScanFlag_ScanNotComplete   = TSI_GENCS_EOSF(0),  ///< Scan not complete
      TsiEndOfScanFlag_ScanComplete      = TSI_GENCS_EOSF(1),  ///< Scan complete
   };

   /**
    * Scan In Progress status
    * (tsi_gencs_scnip)
    *
    * This read-only bit indicates if scan is in progress.
    * This bit will get asserted after the analogue bias circuit is
    * stable after a trigger and it changes automatically by the TSI.
    */
   enum TsiScanInProgess : uint32_t {
      TsiScanInProgess_NoScanInProgress   = TSI_GENCS_SCNIP(0),  ///< Idle - No scan in progress
      TsiScanInProgess_ScanInProgress     = TSI_GENCS_SCNIP(1),  ///< Busy - Scan in progress
   };

   /**
    * External Electrode Error
    * (tsi_gencs_exterf)
    *
    * Indicates that the external electrode appears shorted
    * Write 1 to clear
    */
   enum TsiElectrodeError : uint32_t {
      TsiElectrodeError_NoFault         = TSI_GENCS_EXTERF(0),  ///< No fault
      TsiElectrodeError_ShortToVddVss   = TSI_GENCS_EXTERF(1),  ///< Short to VDD/VSS
   };

   /**
    * Overrun error Flag
    * (tsi_gencs_ovrf)
    *
    * This flag is set when a scan trigger occurs while a scan is still in progress.
    * Write 1 to clear
    */
   enum TsiOverrun : uint32_t {
      TsiOverrun_NoOverrun         = TSI_GENCS_OVRF(0),  ///< No overrun
      TsiOverrun_OverrunOccurred   = TSI_GENCS_OVRF(1),  ///< Overrun occurred
   };

   /**
    * Scan Period Modulus
    * (tsi_scanc_smod)
    *
    * Modulus == 0 indicates continuous mode
    */
   enum TsiScanPeriod : uint32_t {
   };

   /**
    * Reference Oscillator Charge Current select
    * (tsi_scanc_refchrg)
    *
    * Charge current in uA
    */
   enum TsiReferenceChargeCurrent : uint32_t {
      TsiReferenceChargeCurrent_2uA    = TSI_SCANC_REFCHRG(0),   ///< 2 uA
      TsiReferenceChargeCurrent_4uA    = TSI_SCANC_REFCHRG(1),   ///< 4 uA
      TsiReferenceChargeCurrent_6uA    = TSI_SCANC_REFCHRG(2),   ///< 6 uA
      TsiReferenceChargeCurrent_8uA    = TSI_SCANC_REFCHRG(3),   ///< 8 uA
      TsiReferenceChargeCurrent_10uA   = TSI_SCANC_REFCHRG(4),   ///< 10 uA
      TsiReferenceChargeCurrent_12uA   = TSI_SCANC_REFCHRG(5),   ///< 12 uA
      TsiReferenceChargeCurrent_14uA   = TSI_SCANC_REFCHRG(6),   ///< 14 uA
      TsiReferenceChargeCurrent_16uA   = TSI_SCANC_REFCHRG(7),   ///< 16 uA
      TsiReferenceChargeCurrent_18uA   = TSI_SCANC_REFCHRG(8),   ///< 18 uA
      TsiReferenceChargeCurrent_20uA   = TSI_SCANC_REFCHRG(9),   ///< 20 uA
      TsiReferenceChargeCurrent_22uA   = TSI_SCANC_REFCHRG(10),  ///< 22 uA
      TsiReferenceChargeCurrent_24uA   = TSI_SCANC_REFCHRG(11),  ///< 24 uA
      TsiReferenceChargeCurrent_26uA   = TSI_SCANC_REFCHRG(12),  ///< 26 uA
      TsiReferenceChargeCurrent_28uA   = TSI_SCANC_REFCHRG(13),  ///< 28 uA
      TsiReferenceChargeCurrent_30uA   = TSI_SCANC_REFCHRG(14),  ///< 30 uA
      TsiReferenceChargeCurrent_32uA   = TSI_SCANC_REFCHRG(15),  ///< 32 uA
   };

   /**
    * External Oscillator Charge Current select
    * (tsi_scanc_extchrg)
    *
    * Charge current in uA
    */
   enum TsiExternalChargeCurrent : uint32_t {
      TsiExternalChargeCurrent_2uA    = TSI_SCANC_EXTCHRG(0),   ///< 2 uA
      TsiExternalChargeCurrent_4uA    = TSI_SCANC_EXTCHRG(1),   ///< 4 uA
      TsiExternalChargeCurrent_6uA    = TSI_SCANC_EXTCHRG(2),   ///< 6 uA
      TsiExternalChargeCurrent_8uA    = TSI_SCANC_EXTCHRG(3),   ///< 8 uA
      TsiExternalChargeCurrent_10uA   = TSI_SCANC_EXTCHRG(4),   ///< 10 uA
      TsiExternalChargeCurrent_12uA   = TSI_SCANC_EXTCHRG(5),   ///< 12 uA
      TsiExternalChargeCurrent_14uA   = TSI_SCANC_EXTCHRG(6),   ///< 14 uA
      TsiExternalChargeCurrent_16uA   = TSI_SCANC_EXTCHRG(7),   ///< 16 uA
      TsiExternalChargeCurrent_18uA   = TSI_SCANC_EXTCHRG(8),   ///< 18 uA
      TsiExternalChargeCurrent_20uA   = TSI_SCANC_EXTCHRG(9),   ///< 20 uA
      TsiExternalChargeCurrent_22uA   = TSI_SCANC_EXTCHRG(10),  ///< 22 uA
      TsiExternalChargeCurrent_24uA   = TSI_SCANC_EXTCHRG(11),  ///< 24 uA
      TsiExternalChargeCurrent_26uA   = TSI_SCANC_EXTCHRG(12),  ///< 26 uA
      TsiExternalChargeCurrent_28uA   = TSI_SCANC_EXTCHRG(13),  ///< 28 uA
      TsiExternalChargeCurrent_30uA   = TSI_SCANC_EXTCHRG(14),  ///< 30 uA
      TsiExternalChargeCurrent_32uA   = TSI_SCANC_EXTCHRG(15),  ///< 32 uA
   };

   /**
    * Active Mode Clock Source
    * (tsi_scanc_amclks)
    *
    * 
    */
   enum TsiClockSource : uint32_t {
      TsiClockSource_LpoClk     = TSI_SCANC_AMCLKS(0),  ///< LPOSCCLK
      TsiClockSource_McgirClk   = TSI_SCANC_AMCLKS(1),  ///< MCGIRCLK
      TsiClockSource_OscerClk   = TSI_SCANC_AMCLKS(2),  ///< OSCERCLK
   };

   /**
    * Active Mode Prescaler
    * (tsi_scanc_ampsc)
    *
    * Input Clock Source division factor
    */
   enum TsiClockDivider : uint32_t {
      TsiClockDivider_DivBy1     = TSI_SCANC_AMPSC(0),  ///< Divided by 1
      TsiClockDivider_DivBy2     = TSI_SCANC_AMPSC(1),  ///< Divided by 2
      TsiClockDivider_DivBy4     = TSI_SCANC_AMPSC(2),  ///< Divided by 4
      TsiClockDivider_DivBy8     = TSI_SCANC_AMPSC(3),  ///< Divided by 8
      TsiClockDivider_DivBy16    = TSI_SCANC_AMPSC(4),  ///< Divided by 16
      TsiClockDivider_DivBy32    = TSI_SCANC_AMPSC(5),  ///< Divided by 32
      TsiClockDivider_DivBy64    = TSI_SCANC_AMPSC(6),  ///< Divided by 64
      TsiClockDivider_DivBy128   = TSI_SCANC_AMPSC(7),  ///< Divided by 128
   };

   /**
    * TSI input
    * (tsi_pen_num)
    *
    * Used to select a TSI input
    */
   enum TsiInput : uint32_t {
      TsiInput_Ptb0    = 0,   ///< TSI0_CH0 [-]
      TsiInput_Pta0    = 1,   ///< TSI0_CH1 [-]
      TsiInput_Pta1    = 2,   ///< TSI0_CH2 [-]
      TsiInput_Pta2    = 3,   ///< TSI0_CH3 [-]
      TsiInput_Pta3    = 4,   ///< TSI0_CH4 [-]
      TsiInput_Pta4    = 5,   ///< TSI0_CH5 [-]
      TsiInput_Ptb1    = 6,   ///< TSI0_CH6 [-]
      TsiInput_Ptb2    = 7,   ///< TSI0_CH7 [-]
      TsiInput_Ptb3    = 8,   ///< TSI0_CH8 [PTB3(p30)]
      TsiInput_Ptb16   = 9,   ///< TSI0_CH9 [-]
      TsiInput_Ptb17   = 10,  ///< TSI0_CH10 [-]
      TsiInput_Ptb18   = 11,  ///< TSI0_CH11 [-]
      TsiInput_Ptb19   = 12,  ///< TSI0_CH12 [-]
      TsiInput_Ptc0    = 13,  ///< TSI0_CH13 [-]
      TsiInput_Ptc1    = 14,  ///< TSI0_CH14 [-]
      TsiInput_Ptc2    = 15,  ///< TSI0_CH15 [-]
   };

   /**
    * Channels enabled as TSI inputs
    * (tsi_pen_enum)
    *
    * Bitmask representing the selected channels
    */
   enum PinEnableMask : uint32_t {
      PinEnableMask_Ptb0    = TSI_PEN_PEN(1U<<0),   ///< TSI0_CH0 [-]
      PinEnableMask_Pta0    = TSI_PEN_PEN(1U<<1),   ///< TSI0_CH1 [-]
      PinEnableMask_Pta1    = TSI_PEN_PEN(1U<<2),   ///< TSI0_CH2 [-]
      PinEnableMask_Pta2    = TSI_PEN_PEN(1U<<3),   ///< TSI0_CH3 [-]
      PinEnableMask_Pta3    = TSI_PEN_PEN(1U<<4),   ///< TSI0_CH4 [-]
      PinEnableMask_Pta4    = TSI_PEN_PEN(1U<<5),   ///< TSI0_CH5 [-]
      PinEnableMask_Ptb1    = TSI_PEN_PEN(1U<<6),   ///< TSI0_CH6 [-]
      PinEnableMask_Ptb2    = TSI_PEN_PEN(1U<<7),   ///< TSI0_CH7 [-]
      PinEnableMask_Ptb3    = TSI_PEN_PEN(1U<<8),   ///< TSI0_CH8 [PTB3(p30)]
      PinEnableMask_Ptb16   = TSI_PEN_PEN(1U<<9),   ///< TSI0_CH9 [-]
      PinEnableMask_Ptb17   = TSI_PEN_PEN(1U<<10),  ///< TSI0_CH10 [-]
      PinEnableMask_Ptb18   = TSI_PEN_PEN(1U<<11),  ///< TSI0_CH11 [-]
      PinEnableMask_Ptb19   = TSI_PEN_PEN(1U<<12),  ///< TSI0_CH12 [-]
      PinEnableMask_Ptc0    = TSI_PEN_PEN(1U<<13),  ///< TSI0_CH13 [-]
      PinEnableMask_Ptc1    = TSI_PEN_PEN(1U<<14),  ///< TSI0_CH14 [-]
      PinEnableMask_Ptc2    = TSI_PEN_PEN(1U<<15),  ///< TSI0_CH15 [-]
   };

   /**
    * Low-Power Scan Pin
    * (tsi_pen_lpsp)
    *
    * Selects which input is active in low-power mode
    */
   enum TsiLowPowerInput : uint32_t {
      TsiLowPowerInput_Ptb0    = TSI_PEN_LPSP(0),   ///< TSI0_CH0 [-]
      TsiLowPowerInput_Pta0    = TSI_PEN_LPSP(1),   ///< TSI0_CH1 [-]
      TsiLowPowerInput_Pta1    = TSI_PEN_LPSP(2),   ///< TSI0_CH2 [-]
      TsiLowPowerInput_Pta2    = TSI_PEN_LPSP(3),   ///< TSI0_CH3 [-]
      TsiLowPowerInput_Pta3    = TSI_PEN_LPSP(4),   ///< TSI0_CH4 [-]
      TsiLowPowerInput_Pta4    = TSI_PEN_LPSP(5),   ///< TSI0_CH5 [-]
      TsiLowPowerInput_Ptb1    = TSI_PEN_LPSP(6),   ///< TSI0_CH6 [-]
      TsiLowPowerInput_Ptb2    = TSI_PEN_LPSP(7),   ///< TSI0_CH7 [-]
      TsiLowPowerInput_Ptb3    = TSI_PEN_LPSP(8),   ///< TSI0_CH8 [PTB3(p30)]
      TsiLowPowerInput_Ptb16   = TSI_PEN_LPSP(9),   ///< TSI0_CH9 [-]
      TsiLowPowerInput_Ptb17   = TSI_PEN_LPSP(10),  ///< TSI0_CH10 [-]
      TsiLowPowerInput_Ptb18   = TSI_PEN_LPSP(11),  ///< TSI0_CH11 [-]
      TsiLowPowerInput_Ptb19   = TSI_PEN_LPSP(12),  ///< TSI0_CH12 [-]
      TsiLowPowerInput_Ptc0    = TSI_PEN_LPSP(13),  ///< TSI0_CH13 [-]
      TsiLowPowerInput_Ptc1    = TSI_PEN_LPSP(14),  ///< TSI0_CH14 [-]
      TsiLowPowerInput_Ptc2    = TSI_PEN_LPSP(15),  ///< TSI0_CH15 [-]
   };

   /**
    * Low Power Channel Low Threshold value
    * (tsi_threshold_lthh)
    *
    * Determines the low threshold for the channel active in low power mode
    */
   enum TsiLowThreshold : uint32_t {
   };

   /**
    * Low Power Channel High Threshold value
    * (tsi_threshold_hthh)
    *
    * Determines the high threshold for the channel active in low power mode
    */
   enum TsiHighThreshold : uint32_t {
   };

class TsiBasicInfo {

public:
}; // class TsiBasicInfo 

class Tsi0Info : public TsiBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: TSI0_CH0             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: TSI0_CH1             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: TSI0_CH2             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   3: TSI0_CH3             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: TSI0_CH4             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   5: TSI0_CH5             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   6: TSI0_CH6             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   7: TSI0_CH7             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   8: TSI0_CH8             = PTB3(p30)                      */  { PinIndex::PTB3,         PcrValue(0x00000UL) },
         /*   9: TSI0_CH9             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  10: TSI0_CH10            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  11: TSI0_CH11            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  12: TSI0_CH12            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  13: TSI0_CH13            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  14: TSI0_CH14            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  15: TSI0_CH15            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTB_CLOCK_MASK);
      PORTB->GPCLR = (0x0000UL|PORT_GPCLR_GPWE(0x0008UL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTB_CLOCK_MASK);
      PORTB->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0008UL);
   }

   /*
    * Template:tsi0_mk
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with TSI0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with TSI0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = TSI0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Tsi0
    */
   static void enableClock() {
      SIM->SCGC5 = SIM->SCGC5 | SIM_SCGC5_TSI0_MASK;
   }
   
   /**
    *  Disable clock to Tsi0
    */
   static void disableClock() {
      SIM->SCGC5 = SIM->SCGC5 & ~SIM_SCGC5_TSI0_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = TSI0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<TSI_Type> tsi = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   /**
    * Get input clock when configured in Active mode
    *
    * @return frequency on Hz
    */
   static uint32_t getInputClockFrequency() {
      switch(tsi->SCANC&TSI_SCANC_AMCLKS_MASK) {
         case TSI_SCANC_AMCLKS(0):  return SimInfo::getLpoClock();
         case TSI_SCANC_AMCLKS(1):  return McgInfo::getMcgIrClock();
         case TSI_SCANC_AMCLKS(2):  return Osc0Info::getOscerClock();
      }
      return 0;
   }

   /**
    * Get input clock when configured in low power mode
    *
    * @return frequency on Hz
    */
   static uint32_t getLowPowerInputClockFrequency() {
      switch(tsi->GENCS&TSI_GENCS_LPCLKS_MASK) {
         case TSI_GENCS_LPCLKS(0):  return SimInfo::getLpoClock();
         case TSI_GENCS_LPCLKS(1):  return SimInfo::getErc32kClock();
      }
      return 0;
   }

   /**
    * Set Software Trigger
    * (tsi_gencs_swts)
    *
    * @param tsiSoftwareTrigger Used to start a scan when software trigger mode is selected
    */
   static void setStartScan(TsiSoftwareTrigger tsiSoftwareTrigger) {
      tsi->GENCS = (tsi->GENCS&~TSI_GENCS_SWTS_MASK) | tsiSoftwareTrigger;
   }
   
}; // class Tsi0Info

/** 
 * End group TSI_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM


///
/// @page PinSummary Pin Mapping
///
/// @section PinsByPinName Pins by Pin Name
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTA0           | SwdClk                        | SWD_CLK                                            | p17                       | SWD_CLK
///  PTA1           | -                             | UART0_RX                                           | p18                       | DebugRx
///  PTA2           | -                             | UART0_TX                                           | p19                       | DebugTx
///  PTA3           | SwdDio                        | SWD_DIO                                            | p20                       | SWD_DIO
///  PTA4           | IrReceiver                    | GPIOA_4                                            | p21                       | IR Receiver
///  PTA18          | -                             | EXTAL0                                             | p24                       | Extal0
///  PTA19          | -                             | XTAL0                                              | p25                       | Xtal0
///  PTB0           | Charging                      | GPIOB_0                                            | p27                       | Charging detection
///  PTB1           | TftResetPin                   | GPIOB_1                                            | p28                       | TFT Reset 
///  PTB2           | TftBusyPin                    | GPIOB_2                                            | p29                       | TFT Busy Pin
///  PTB3           | BatteryLevel                  | ADC0_SE13                                          | p30                       | Battery Level
///  PTC1           | TftCs                         | SPI0_PCS3                                          | p34                       | TFT CS
///  PTC2           | TftDc                         | SPI0_PCS2                                          | p35                       | TFT D/C select
///  PTC3           | TouchCs                       | SPI0_PCS1                                          | p36                       | Touch panel CS
///  PTC4           | TftBacklight                  | GPIOC_4                                            | p37                       | TFT Backlight
///  PTC5           | SpiSck                        | SPI0_SCK                                           | p38                       | SPI SCK
///  PTC6           | SpiMOSI                       | SPI0_SOUT                                          | p39                       | SPI MOSI
///  PTC7           | SpiMISO                       | SPI0_SIN                                           | p40                       | SPI MISO
///  PTD0           | Switch4/Switches              | GPIOD_0                                            | p41                       | Switch 4
///  PTD1           | Switch3/Switches              | GPIOD_1                                            | p42                       | Switch 3
///  PTD2           | Switch2/Switches              | GPIOD_2                                            | p43                       | Switch 2
///  PTD3           | Switch1/Switches              | GPIOD_3                                            | p44                       | Switch 1
///  PTD4           | TouchIrq                      | GPIOD_4                                            | p45                       | Touch Panel IRQ
///  PTD4           | TouchWakeup                   | LLWU_P14                                           | p45                       | Touch Wakeup
///  PTD5           | DebugLed                      | GPIOD_5                                            | p46                       | Debug LED
///  PTD7           | -                             | CMT_IRO                                            | p48                       | CMT Infra-red output
///  RESET_b        | Resetb                        | RESET_b                                            | p26                       | Reset*
///  USB0_DM        | -                             | USB0_DM                                            | p4                        | USB_DM
///  USB0_DP        | -                             | USB0_DP                                            | p3                        | USB_DP
///  VBAT           | -                             | VBAT                                               | p16                       | Vbat
///  VDD1           | -                             | VDD1                                               | p1                        | Vdd
///  VDD2           | -                             | VDD2                                               | p22                       | Vdd
///  VDDA           | -                             | VDDA                                               | p9                        | VddA
///  VOUT33         | -                             | VOUT33                                             | p5                        | Vout 3.3V
///  VREFH          | -                             | VREFH                                              | p10                       | VrefH
///  VREFL          | -                             | VREFL                                              | p11                       | VrefL
///  VREGIN         | -                             | VREGIN                                             | p6                        | Vregin
///  VSS1           | -                             | VSS1                                               | p2                        | Vss
///  VSS2           | -                             | VSS2                                               | p23                       | Vss
///  VSSA           | -                             | VSSA                                               | p12                       | VssA
///
///
/// @section PinsByLocation Pins by Location
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  VDD1           | -                             | VDD1                                               | p1                        | Vdd
///  VSS1           | -                             | VSS1                                               | p2                        | Vss
///  USB0_DP        | -                             | USB0_DP                                            | p3                        | USB_DP
///  USB0_DM        | -                             | USB0_DM                                            | p4                        | USB_DM
///  VOUT33         | -                             | VOUT33                                             | p5                        | Vout 3.3V
///  VREGIN         | -                             | VREGIN                                             | p6                        | Vregin
///  VDDA           | -                             | VDDA                                               | p9                        | VddA
///  VREFH          | -                             | VREFH                                              | p10                       | VrefH
///  VREFL          | -                             | VREFL                                              | p11                       | VrefL
///  VSSA           | -                             | VSSA                                               | p12                       | VssA
///  VBAT           | -                             | VBAT                                               | p16                       | Vbat
///  PTA0           | SwdClk                        | SWD_CLK                                            | p17                       | SWD_CLK
///  PTA1           | -                             | UART0_RX                                           | p18                       | DebugRx
///  PTA2           | -                             | UART0_TX                                           | p19                       | DebugTx
///  PTA3           | SwdDio                        | SWD_DIO                                            | p20                       | SWD_DIO
///  PTA4           | IrReceiver                    | GPIOA_4                                            | p21                       | IR Receiver
///  VDD2           | -                             | VDD2                                               | p22                       | Vdd
///  VSS2           | -                             | VSS2                                               | p23                       | Vss
///  PTA18          | -                             | EXTAL0                                             | p24                       | Extal0
///  PTA19          | -                             | XTAL0                                              | p25                       | Xtal0
///  RESET_b        | Resetb                        | RESET_b                                            | p26                       | Reset*
///  PTB0           | Charging                      | GPIOB_0                                            | p27                       | Charging detection
///  PTB1           | TftResetPin                   | GPIOB_1                                            | p28                       | TFT Reset 
///  PTB2           | TftBusyPin                    | GPIOB_2                                            | p29                       | TFT Busy Pin
///  PTB3           | BatteryLevel                  | ADC0_SE13                                          | p30                       | Battery Level
///  PTC1           | TftCs                         | SPI0_PCS3                                          | p34                       | TFT CS
///  PTC2           | TftDc                         | SPI0_PCS2                                          | p35                       | TFT D/C select
///  PTC3           | TouchCs                       | SPI0_PCS1                                          | p36                       | Touch panel CS
///  PTC4           | TftBacklight                  | GPIOC_4                                            | p37                       | TFT Backlight
///  PTC5           | SpiSck                        | SPI0_SCK                                           | p38                       | SPI SCK
///  PTC6           | SpiMOSI                       | SPI0_SOUT                                          | p39                       | SPI MOSI
///  PTC7           | SpiMISO                       | SPI0_SIN                                           | p40                       | SPI MISO
///  PTD0           | Switch4/Switches              | GPIOD_0                                            | p41                       | Switch 4
///  PTD1           | Switch3/Switches              | GPIOD_1                                            | p42                       | Switch 3
///  PTD2           | Switch2/Switches              | GPIOD_2                                            | p43                       | Switch 2
///  PTD3           | Switch1/Switches              | GPIOD_3                                            | p44                       | Switch 1
///  PTD4           | TouchIrq                      | GPIOD_4                                            | p45                       | Touch Panel IRQ
///  PTD4           | TouchWakeup                   | LLWU_P14                                           | p45                       | Touch Wakeup
///  PTD5           | DebugLed                      | GPIOD_5                                            | p46                       | Debug LED
///  PTD7           | -                             | CMT_IRO                                            | p48                       | CMT Infra-red output
///
///
/// @section PinsByFunction Pins by Peripheral
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTB3           | BatteryLevel                  | ADC0_SE13                                          | p30                       | Battery Level
///  PTD7           | -                             | CMT_IRO                                            | p48                       | CMT Infra-red output
///  PTA18          | -                             | EXTAL0                                             | p24                       | Extal0
///  PTA4           | IrReceiver                    | GPIOA_4                                            | p21                       | IR Receiver
///  PTB0           | Charging                      | GPIOB_0                                            | p27                       | Charging detection
///  PTB1           | TftResetPin                   | GPIOB_1                                            | p28                       | TFT Reset 
///  PTB2           | TftBusyPin                    | GPIOB_2                                            | p29                       | TFT Busy Pin
///  PTC4           | TftBacklight                  | GPIOC_4                                            | p37                       | TFT Backlight
///  PTD0           | Switch4/Switches              | GPIOD_0                                            | p41                       | Switch 4
///  PTD1           | Switch3/Switches              | GPIOD_1                                            | p42                       | Switch 3
///  PTD2           | Switch2/Switches              | GPIOD_2                                            | p43                       | Switch 2
///  PTD3           | Switch1/Switches              | GPIOD_3                                            | p44                       | Switch 1
///  PTD4           | TouchIrq                      | GPIOD_4                                            | p45                       | Touch Panel IRQ
///  PTD5           | DebugLed                      | GPIOD_5                                            | p46                       | Debug LED
///  PTD4           | TouchWakeup                   | LLWU_P14                                           | p45                       | Touch Wakeup
///  RESET_b        | Resetb                        | RESET_b                                            | p26                       | Reset*
///  PTC3           | TouchCs                       | SPI0_PCS1                                          | p36                       | Touch panel CS
///  PTC2           | TftDc                         | SPI0_PCS2                                          | p35                       | TFT D/C select
///  PTC1           | TftCs                         | SPI0_PCS3                                          | p34                       | TFT CS
///  PTC5           | SpiSck                        | SPI0_SCK                                           | p38                       | SPI SCK
///  PTC7           | SpiMISO                       | SPI0_SIN                                           | p40                       | SPI MISO
///  PTC6           | SpiMOSI                       | SPI0_SOUT                                          | p39                       | SPI MOSI
///  PTA0           | SwdClk                        | SWD_CLK                                            | p17                       | SWD_CLK
///  PTA3           | SwdDio                        | SWD_DIO                                            | p20                       | SWD_DIO
///  PTA1           | -                             | UART0_RX                                           | p18                       | DebugRx
///  PTA2           | -                             | UART0_TX                                           | p19                       | DebugTx
///  USB0_DM        | -                             | USB0_DM                                            | p4                        | USB_DM
///  USB0_DP        | -                             | USB0_DP                                            | p3                        | USB_DP
///  VBAT           | -                             | VBAT                                               | p16                       | Vbat
///  VDD1           | -                             | VDD1                                               | p1                        | Vdd
///  VDD2           | -                             | VDD2                                               | p22                       | Vdd
///  VDDA           | -                             | VDDA                                               | p9                        | VddA
///  VOUT33         | -                             | VOUT33                                             | p5                        | Vout 3.3V
///  VREFH          | -                             | VREFH                                              | p10                       | VrefH
///  VREFL          | -                             | VREFL                                              | p11                       | VrefL
///  VREGIN         | -                             | VREGIN                                             | p6                        | Vregin
///  VSS1           | -                             | VSS1                                               | p2                        | Vss
///  VSS2           | -                             | VSS2                                               | p23                       | Vss
///  VSSA           | -                             | VSSA                                               | p12                       | VssA
///  PTA19          | -                             | XTAL0                                              | p25                       | Xtal0
///
///

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */
