/**
 * @file     llwu.h (180.ARM_Peripherals/Project_Headers/llwu.h)
 * @brief    Low leakage wake-up unit
 */

#ifndef HEADER_LLWU_H
#define HEADER_LLWU_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

// No handler defined for LLWU 


namespace USBDM {

#if true // /LLWU/_BasicInfoGuard

/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Abstraction for Low-leakage Wake-up Unit
 * @{
 */
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * LLWU peripheral wake-up source
    * (llwu_me_peripherals)
    *
    * Peripheral used as wake-up source
    */
   enum LlwuPeripheral : uint8_t {
      LlwuPeripheral_None         = 0,      ///< No wake-up peripheral
      LlwuPeripheral_Lptmr0       = 1U<<0,  ///< Wake-up by LPTMR0
      LlwuPeripheral_Cmp0         = 1U<<1,  ///< Wake-up by CMP0
      LlwuPeripheral_Cmp1         = 1U<<2,  ///< Wake-up by CMP1
      LlwuPeripheral_Tsi0         = 1U<<4,  ///< Wake-up by TSI0
      LlwuPeripheral_RtcAlarm     = 1U<<5,  ///< Wake-up by RtcAlarm
      LlwuPeripheral_RtcSeconds   = 1U<<7,  ///< Wake-up by RtcSeconds
// No wake-up peripherals found
   };

   /**
    * LLWU peripheral wake-up control
    * (llwu_me_wume)
    *
    * Whether this peripheral can wake-up the processor
    */
   enum LlwuPeripheralWakeup {
      LlwuPeripheralWakeup_Disabled   = false,  ///< Wake-up disabled
      LlwuPeripheralWakeup_Enabled    = true,   ///< Wake-up enabled
   };

   /**
    * Low-Leakage Mode RESET Enable
    * (llwu_rst_llrste)
    *
    * This bit must be set to allow the device to be reset while in a low-leakage power mode.
    * On devices where Reset is not a dedicated pin, the RESET pin must also be enabled
    * in the explicit port mux control
    */
   enum LlwuResetWakeup {
      LlwuResetWakeup_Disabled   = LLWU_RST_LLRSTE(0),  ///< RESET not enabled as LLWU exit source
      LlwuResetWakeup_Enabled    = LLWU_RST_LLRSTE(1),  ///< RESET enabled as LLWU exit source
   };

   /**
    * Digital Filter On RESET Pin
    * (llwu_rst_rstfilt)
    *
    * Enables the digital filter for the RESET pin during LLS, VLLS3, VLLS2, or VLLS1 modes
    */
   enum LlwuResetFilter {
      LlwuResetFilter_Disabled   = LLWU_RST_RSTFILT(0),  ///< Filter not enabled
      LlwuResetFilter_Enabled    = LLWU_RST_RSTFILT(1),  ///< Filter enabled
   };

   /**
    * Wake-up pin control
    * (llwu_pe)
    *
    * Enables and configures the edge detection for a wake-up pin
    */
   enum LlwuPinMode {
      LlwuPinMode_Disabled      = LLWU_PE1_WUPE0(0)|LLWU_PE1_WUPE1(0)|LLWU_PE1_WUPE2(0)|LLWU_PE1_WUPE3(0),  ///< Wake-up pin disabled
      LlwuPinMode_RisingEdge    = LLWU_PE1_WUPE0(1)|LLWU_PE1_WUPE1(1)|LLWU_PE1_WUPE2(1)|LLWU_PE1_WUPE3(1),  ///< Wake-up on pin rising edge
      LlwuPinMode_FallingEdge   = LLWU_PE1_WUPE0(2)|LLWU_PE1_WUPE1(2)|LLWU_PE1_WUPE2(2)|LLWU_PE1_WUPE3(2),  ///< Wake-up on pin falling edge
      LlwuPinMode_EitherEdge    = LLWU_PE1_WUPE0(3)|LLWU_PE1_WUPE1(3)|LLWU_PE1_WUPE2(3)|LLWU_PE1_WUPE3(3),  ///< Wake-up on pin either edge
   };

   /**
    * Pin filter numbers
    * (pin_filter_numbers)
    *
    * These are used as an index into the FILT table so 
    * do NOT correspond to filter names e.g. FILT1 = FILT[0] etc
    */
   enum LlwuFilterNum : uint8_t {
      LlwuFilterNum_1   = 0,  ///< Wake-up pin filter 1
      LlwuFilterNum_2   = 1,  ///< Wake-up pin filter 2
   };

   /**
    * Filter Pin Select
    * (pin_numbers)
    *
    * Selects 1 of the pins to be muxed into the filter
    */
   enum LlwuPin : uint8_t {
      LlwuPin_Pte1          = 0,   ///< LLWU_P0 [-]
      LlwuPin_Pta4          = 3,   ///< LLWU_P3 [PTA4(p21)]
      LlwuPin_Pta13         = 4,   ///< LLWU_P4 [-]
      LlwuPin_Ptb0          = 5,   ///< LLWU_P5 [PTB0(p27)]
      LlwuPin_Ptc1          = 6,   ///< LLWU_P6 [-]
      LlwuPin_Ptc3          = 7,   ///< LLWU_P7 [-]
      LlwuPin_Ptc4          = 8,   ///< LLWU_P8 [PTC4(p37)]
      LlwuPin_Ptc5          = 9,   ///< LLWU_P9 [-]
      LlwuPin_Ptc6          = 10,  ///< LLWU_P10 [-]
      LlwuPin_Ptc11         = 11,  ///< LLWU_P11 [-]
      LlwuPin_Ptd0          = 12,  ///< LLWU_P12 [PTD0(p41)]
      LlwuPin_Ptd2          = 13,  ///< LLWU_P13 [PTD2(p43)]
      LlwuPin_Ptd4          = 14,  ///< Touch Wakeup [PTD4(p45)]
      LlwuPin_TouchWakeup   = 14,  ///< Touch Wakeup
      LlwuPin_Ptd6          = 15,  ///< LLWU_P15 [-]

   };

   /**
    * Pin Filter Mode
    * (llwu_filt_filte)
    *
    * Controls the digital filter options for the filtered external pin detect
    */
   enum LlwuFilterPinMode {
      LlwuFilterPinMode_Disabled      = LLWU_FILT_FILTE(0),  ///< Wake-up disabled
      LlwuFilterPinMode_RisingEdge    = LLWU_FILT_FILTE(1),  ///< Wake-up on filtered rising edge
      LlwuFilterPinMode_FallingEdge   = LLWU_FILT_FILTE(2),  ///< Wake-up on filtered falling edge
      LlwuFilterPinMode_EitherEdge    = LLWU_FILT_FILTE(3),  ///< Wake-up on either filtered edge
   };

class LlwuBasicInfo {

public:
   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = true;
   
   /**
    * Type definition for Llwu interrupt call back.
    */
   typedef void (*CallbackFunction)();
   
   // Pointer to LLWU hardware instance
   volatile LLWU_Type * const llwu;
   
   /**
    * Constructor
    *
    * @param llwu LLWU hardware instance
    */
   constexpr LlwuBasicInfo(volatile LLWU_Type * llwu) : llwu(llwu) {
   }
   
   /**
    * Configure LLWU peripheral wake-up source
    *
    * @param llwuPeripheral       Peripheral used as wake-up source
    * @param llwuPeripheralWakeup Whether this peripheral can wake-up the processor
    */
   void configurePeripheralSource(
         LlwuPeripheral       llwuPeripheral,
         LlwuPeripheralWakeup llwuPeripheralWakeup) const {
   
      if (llwuPeripheralWakeup) {
         llwu->ME = llwu->ME | llwuPeripheral;
      }
      else {
         llwu->ME = llwu->ME & (uint8_t)~llwuPeripheral;
      }
   }
   
   /**
    * Get flag bit mask indicating wake-up peripheral sources
    * The mask returned correspond to (multiple) peripheral sources.
    * These flags are cleared through the originating peripheral.
    *
    *
    * Example checking source
    * @code
    *    if ((peripheralWakeupSource&LlwuPeripheral_Lptmr) != 0) {
    *       // Wake-up from LPTMR
    *    }
    * @endcode
    *
    * @return Bit mask
    */
   uint32_t getPeripheralWakeupSources() const {
      return llwu->MF;
   }

   /**
    *  Check if peripheral is source of wake-up
    *  These flags are cleared through the originating peripheral.
    *
    * @param llwuPeripheral       Peripheral used as wake-up source
    *
    * @return false Given peripheral is not source of wake-up.
    * @return true  Given peripheral is source of wake-up.
    */
   bool isPeripheralWakeupSource(LlwuPeripheral llwuPeripheral) const {
      return llwu->MF & llwuPeripheral;
   }

   /**
    * Controls Reset wake-up control
    *
    * @param llwuResetFilter Enables the digital filter for the RESET pin during LLS, VLLS3, VLLS2, or VLLS1 modes
    * @param llwuResetWakeup This bit must be set to allow the device to be reset while in a low-leakage power mode.
    *        On devices where Reset is not a dedicated pin, the RESET pin must also be enabled
    *        in the explicit port mux control
    */
   void configureResetFilter(
         LlwuResetFilter llwuResetFilter,
         LlwuResetWakeup llwuResetWakeup = LlwuResetWakeup_Enabled) const {
      llwu->RST = llwuResetFilter|llwuResetWakeup;
   }
   /*
    * ***************************************************
    * Wake-up pins
    * ***************************************************
    */
   /**
    * Configure pin as wake-up source
    *
    * @param[in] llwuPin       Pin to configure
    * @param[in] llwuPinMode   Mode for pin as wake-up input
    */
   void configurePinSource(
         LlwuPin     llwuPin,
         LlwuPinMode llwuPinMode) const {
   
      static const uint8_t masks[] =
         {LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE3_MASK, };
      volatile uint8_t &llwuPe = llwu->PE[llwuPin>>2];
      uint8_t mask = masks[llwuPin&3];
      llwuPe = (llwuPe&~mask) | (llwuPinMode&mask);
   }
   
   /**
    * Get bit mask indicating wake-up pin sources

    * The pin masks correspond to Pin sources.
    *
    * @code
    *    if ((pinWakeupSource&(1<<LlwuPin_ptc1)) != 0) {
    *       // Wakeup from LPTMR
    *    }
    * @endcode
    *
    * @return Bit mask
    */
   uint32_t getPinWakeupSources() const {
      constexpr unsigned PF_SIZE = sizeof(llwu->PF)/sizeof(llwu->PF[0]);
      if constexpr(PF_SIZE==4) {
         return (llwu->PF[1]<<24)|(llwu->PF[1]<<16)|(llwu->PF[1]<<8)|llwu->PF[0];
      }
      else if constexpr(PF_SIZE==3) {
         return (llwu->PF[1]<<16)|(llwu->PF[1]<<8)|llwu->PF[0];
      }
      else if constexpr(PF_SIZE==2) {
         return (llwu->PF[1]<<8)|llwu->PF[0];
      }
      else {
         return llwu->PF[0];
      }
   }
   
   /**
    * Check if pin is source of wake-up
    *
    * @param[in] llwuPin  Pin to check
    *
    * @return false Given pin is not source of wake-up.
    * @return true  Given pin is source of wake-up.
    */
   bool isPinWakeupSource(LlwuPin llwuPin) const {
      return getPinWakeupSources() & (1<<llwuPin);
   }
   
   /**
    * Clear wake-up pin flag
    *
    *  @param[in] llwuPin Pin indicating which flag to clear
    */
   void clearPinWakeupFlag(LlwuPin llwuPin) const {
      llwu->PF[llwuPin>>3] = (1<<(llwuPin&0x7));
   }
   
   /**
    * Clear all wake-up flags

    * Peripherals sources are not cleared since they are controlled by the peripheral
    */
   void clearAllFlags() const {
      clearPinWakeupFlags();
      clearFilteredPinWakeupFlags();
   }
   
   /**
    * Clear all wake-up pin flags
    */
   void clearPinWakeupFlags() const {
      for(unsigned index=0; index<(sizeof(llwu->PF)/sizeof(llwu->PF[0])); index++) {
         llwu->PF[index] = 0xFF;
      }
   }
   
   /*
    * ***************************************************
    * Wake-up filtered pins
    * ***************************************************
    */
   /**
    * Configure one of the input pins as a filtered wake-up source
    *
    * @param[in] llwuFilterNum      Filter to configure - number available depends on device
    * @param[in] llwuPin            Pin to assign to filter
    * @param[in] llwuFilterPinMode  Mode for pin as wake-up input
    *
    * @note Filtering is bypassed in VLLS0
    */
   ErrorCode configureFilteredPinSource(
         LlwuFilterNum     llwuFilterNum,
         LlwuPin           llwuPin,
         LlwuFilterPinMode llwuFilterPinMode) const {
   
      llwu->FILT[llwuFilterNum] = llwuPin|llwuFilterPinMode;
      return E_NO_ERROR;
   }
   
   /**
    * Check if filtered wake-up pin is source of wake-up
    *
    * @param[in] filterNum Pin Filter to check
    *
    * @return false Given filtered pin is not source of wake-up.
    * @return true  Given filtered pin is source of wake-up.
    */
   bool isFilteredPinWakeupSource(unsigned filterNum) const {
      return (llwu->FILT[filterNum] & LLWU_FILT_FILTF_MASK);
   }
   
   /**
    * Clear filtered wake-up pin flag
    *
    * @param[in] filterNum Pin Filter to clear flag
    */
   void clearFilteredPinWakeupFlag(LlwuFilterNum filterNum) const {
      llwu->FILT[filterNum] = llwu->FILT[filterNum] | LLWU_FILT_FILTF_MASK;
   }
   
   /**
    * Clear all filtered wake-up pin flags
    */
   void clearFilteredPinWakeupFlags() const {
      for (unsigned index=0; index<(sizeof(llwu->FILT)/sizeof(llwu->FILT[0])); index++) {
         llwu->FILT[index] = llwu->FILT[index] | LLWU_FILT_FILTF_MASK;
      }
   }
   
   /**
    * Disable all wake-up sources (pins and peripherals)
    */
   void disableAllSources() const {
      for (unsigned index=0; index<(sizeof(llwu->PE)/(sizeof(llwu->PE[0]))); index++) {
         llwu->PE[index] = 0;
      }
   
#if defined(LLWU_ME_WUME0_MASK)
      llwu->ME  = 0;
#endif
   }
   
   /**
    * Class used to do initialisation of the Llwu
    *
    * This class has a templated constructor that accepts various values:
    * - llwuPeripheral,                            - Peripheral to enable as wake-up source
    * - llwuPin, llwuPinMode,                      - Pin to enable as direct wake-up source
    * - llwuFilterNum, llwuPin, llwuFilterPinMode, - Pin to enable as filtered wake-up source
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * ///
    * /// LLWU call-back
    * ///
    * /// @param status  Status reflecting active inputs
    * ///
    * void llwuCallback(uint32_t status) {
    *    (void) status;
    * }
    *
    * static const Llwu::Init llwuInit {
    *    // Pins
    *    LlwuPin_Pta4,  LlwuPinMode_FallingEdge,
    *    LlwuPin_Pta13, LlwuPinMode_EitherEdge,
    *    LlwuPin_Ptd4,  LlwuPinMode_RisingEdge,
    *
    *    // Filtered Pins
    *    LlwuFilterNum_1, LlwuPin_Pta4, LlwuFilterPinMode_EitherEdge,
    *    LlwuFilterNum_2, LlwuPin_Ptc3, LlwuFilterPinMode_RisingEdge,
    *
    *    // Peripherals
    *    LlwuPeripheral_RtcAlarm,
    *    LlwuPeripheral_Lptmr0,
    *
    *    // Reset
    *    LlwuResetWakeup_Enabled, LlwuResetFilter_Enabled
    * };
    *
    * // Initialise Llwu from values specified above
    * Llwu::configure(llwuInit)
    * @endcode
    */
   
   class Init {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr Init(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /// Array to assist with mapping Pin to register bit-mask
      static constexpr uint8_t masks[] =
         {LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE3_MASK, };
   
   
      /// Pin sources enable
      uint8_t pe[4]   = {0};
   
      /// Filter configurations
      uint8_t filt[2] = {0};
   
      /// Module (peripheral) sources enable
      uint8_t me      = 0;
   
      /// Reset Pin Filter configuration
      uint8_t rst     = 0;
      /**
       * Constructor for LLWU peripheral wake-up source
       * (llwu_me_peripherals)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param llwuPeripheral Peripheral used as wake-up source
       */
      template <typename... Types>
      constexpr Init(LlwuPeripheral llwuPeripheral, Types... rest) : Init(rest...) {
   
         me |= llwuPeripheral;
      }
   
      /**
       * Constructor for filtered pin source
       *
       * @tparam Types
       * @param rest
       *
       * @param llwuFilterNum       Filter to use
       * @param llwuPin             Peripheral to enable as wake-up source
       * @param llwuFilterPinMode   Sensitivity of pin
       */
      template <typename... Types>
      constexpr Init(
            LlwuFilterNum     llwuFilterNum,
            LlwuPin           llwuPin,
            LlwuFilterPinMode llwuFilterPinMode,
            Types... rest) : Init(rest...) {
   
         // LLWU_FILT_FILTF_MASK clears flag on write to register
         filt[llwuFilterNum] = LLWU_FILT_FILTF_MASK|llwuFilterPinMode|llwuPin;
      }
   
      /**
       * Constructor for unfiltered pin source
       *
       * @tparam Types
       * @param rest
       *
       * @param llwuPin       Peripheral to enable as wake-up source
       * @param llwuPinMode   Sensitivity of pin
       */
      template <typename... Types>
      constexpr Init(LlwuPin llwuPin, LlwuPinMode llwuPinMode, Types... rest) : Init(rest...) {
   
         const uint8_t  mask  = masks[llwuPin&3];
         const int      index = llwuPin>>2;
   
         pe[index] = (pe[index]&~mask) | (llwuPinMode & mask);
      }
   
      /**
       * Constructor for Reset as wake-up source
       *
       * @tparam Types
       * @param rest
       *
       * @param llwuResetWakeup  Enable/Disable Reset source
       * @param llwuResetFilter  Enable/Disable Reset pin filter
       */
      template <typename... Types>
      constexpr Init(LlwuResetWakeup llwuResetWakeup, LlwuResetFilter llwuResetFilter, Types... rest) : Init(rest...) {
   
         rst = llwuResetWakeup|llwuResetFilter;
      }
   
   }; // class LlwuBasicInfo::Init
   
   /**
    * Configure LLWU from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param llwu            Hardware instance pointer
    * @param init            Class containing initialisation values
    */
   static void configure(
                  volatile LLWU_Type *llwu,
                  const Init    &init) {
   
   
      // Clear pin flags
      llwu->PF1 = 0xFF;
      // Clear pin flags
      llwu->PF2 = 0xFF;
      // Configure pin sources
      llwu->PE1  = init.pe[0];
      // Configure pin sources
      llwu->PE2  = init.pe[1];
      // Configure pin sources
      llwu->PE3  = init.pe[2];
      // Configure pin sources
      llwu->PE4  = init.pe[3];
      // Configure and clear filtered pin source
      llwu->FILT1 = init.filt[0];
      // Configure and clear filtered pin source
      llwu->FILT2 = init.filt[1];
      // Configure peripheral sources
      llwu->ME    = init.me;
      // Configure filtered reset pin source
      llwu->RST   = init.rst;
   }
   
   /**
    * Configure LLWU from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param init Class containing initialisation values
    */
   void configure(const Init &init) const {
   
      configure(llwu, init);
   }
   
}; // class LlwuBasicInfo 

class LlwuInfo : public LlwuBasicInfo {

public:
   //! Number of signals available in info table
   static constexpr int numSignals  = 40;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: LLWU_P0              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   2: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   3: LLWU_P3              = PTA4(p21)                      */  { PinIndex::PTA4,         PcrValue(0x00100UL) },
         /*   4: LLWU_P4              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   5: LLWU_P5              = PTB0(p27)                      */  { PinIndex::PTB0,         PcrValue(0x00100UL) },
         /*   6: LLWU_P6              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   7: LLWU_P7              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   8: LLWU_P8              = PTC4(p37)                      */  { PinIndex::PTC4,         PcrValue(0x00100UL) },
         /*   9: LLWU_P9              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  10: LLWU_P10             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  11: LLWU_P11             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  12: LLWU_P12             = PTD0(p41)                      */  { PinIndex::PTD0,         PcrValue(0x00100UL) },
         /*  13: LLWU_P13             = PTD2(p43)                      */  { PinIndex::PTD2,         PcrValue(0x00100UL) },
         /*  14: LLWU_P14             = PTD4(p45)                      */  { PinIndex::PTD4,         PcrValue(0x00100UL) },
         /*  15: LLWU_P15             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  16: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  17: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  18: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  19: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  20: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  21: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  22: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  23: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  24: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  25: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  26: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  27: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  28: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  29: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  30: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  31: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  32: LLWU_M0              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  33: LLWU_M1              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  34: LLWU_M2              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  35: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  36: LLWU_M4              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  37: LLWU_M5              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*  38: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*  39: LLWU_M7              = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK|USBDM::PORTB_CLOCK_MASK|USBDM::PORTC_CLOCK_MASK|USBDM::PORTD_CLOCK_MASK);
      PORTA->GPCLR = (0x0100UL|PORT_GPCLR_GPWE(0x0010UL));
      PORTB->GPCLR = (0x0100UL|PORT_GPCLR_GPWE(0x0001UL));
      PORTC->GPCLR = (0x0100UL|PORT_GPCLR_GPWE(0x0010UL));
      PORTD->GPCLR = (0x0100UL|PORT_GPCLR_GPWE(0x0015UL));
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
      enablePortClocks(USBDM::PORTA_CLOCK_MASK|USBDM::PORTB_CLOCK_MASK|USBDM::PORTC_CLOCK_MASK|USBDM::PORTD_CLOCK_MASK);
      PORTA->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0010UL);
      PORTB->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0001UL);
      PORTC->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0010UL);
      PORTD->GPCLR = uint32_t(PinMux_Disabled)|PORT_GPCLR_GPWE(0x0015UL);
   }

   /*
    * Template:llwu_me_pe4_filt2_rst_mk20d5
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;


   
   /**
    * Configures all mapped pins associated with LLWU
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with LLWU
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = true;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = LLWU_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   template<typename T>
   using CallbackWrapper = USBDM::CallbackWrapper<T, LlwuInfo>;
   
   /**
    * Function to wrap a member function as a static callback function
    * Example:
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callbackFuction() {
    *       ...;
    *    }
    * };
    * ...
    *    AClass *tester = new AClass{};
    *
    *    auto cb = Llwu::wrapCallback(tester, &AClass::callbackFuction);
    *    Llwu::setCallback(cb);
    *   @endcode
    *
    * @tparam T               Type of class containing callback (inferred)
    *
    * @param classInstance    Pointer to instance of class
    * @param memberFunction   Pointer to the member function
    *
    * @return  Wrapper
    */
   template<typename T>
   static auto wrapCallback(T *classInstance, void (T::*memberFunction)()) {
      static CallbackWrapper<T> sClass(classInstance, memberFunction);
      return sClass.callback;
   }
   
   /**
    * LLWU interrupt handler -  Calls LLWU callback
    */
   static void irqHandler() {
   
      // Execute call-back
      sCallback();
   }
   
   /** Callback function for Llwu */
   static inline CallbackFunction sCallback = unhandledCallback; // LLWU_IRQn;
   
   /**
    * Set interrupt callback function.
    *
    * @param  llwuCallback Callback function to execute on interrupt
    *                             Use nullptr to remove callback.
    */
   static void setCallback(CallbackFunction llwuCallback) {
      if (llwuCallback == nullptr) {
         llwuCallback = unhandledCallback;
      }
      // Allow either no handler set yet, setting same handler or removing handler
      usbdm_assert(
            (sCallback == unhandledCallback) ||
            (sCallback == llwuCallback) ||
            (llwuCallback == unhandledCallback),
            "Handler already set");
      sCallback = llwuCallback;
   }
   
   /**
    * Basic enable of Llwu
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      configureAllPins();
   }
   
   /**
    * Disables Llwu
    */
   static void disable() {
   
      
      disableNvicInterrupts();
      disableAllPins();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = LLWU_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<LLWU_Type> llwu = baseAddress;
   
   /**
    * Information describing the priority and callback function for each interrupt
    */
   typedef InitVectors<Init, CallbackFunction, int, 1> Init;
   
   /**
    * Configure LLWU peripheral wake-up source
    *
    * @param llwuPeripheral       Peripheral used as wake-up source
    * @param llwuPeripheralWakeup Whether this peripheral can wake-up the processor
    */
   static void configurePeripheralSource(
         LlwuPeripheral       llwuPeripheral,
         LlwuPeripheralWakeup llwuPeripheralWakeup) {
   
      if (llwuPeripheralWakeup) {
         llwu->ME = llwu->ME | llwuPeripheral;
      }
      else {
         llwu->ME = llwu->ME & (uint8_t)~llwuPeripheral;
      }
   }
   
   /**
    * Get flag bit mask indicating wake-up peripheral sources
    * The mask returned correspond to (multiple) peripheral sources.
    * These flags are cleared through the originating peripheral.
    *
    *
    * Example checking source
    * @code
    *    if ((peripheralWakeupSource&LlwuPeripheral_Lptmr) != 0) {
    *       // Wake-up from LPTMR
    *    }
    * @endcode
    *
    * @return Bit mask
    */
   static uint32_t getPeripheralWakeupSources() {
      return llwu->MF;
   }

   /**
    *  Check if peripheral is source of wake-up
    *  These flags are cleared through the originating peripheral.
    *
    * @param llwuPeripheral       Peripheral used as wake-up source
    *
    * @return false Given peripheral is not source of wake-up.
    * @return true  Given peripheral is source of wake-up.
    */
   static bool isPeripheralWakeupSource(LlwuPeripheral llwuPeripheral) {
      return llwu->MF & llwuPeripheral;
   }

   /**
    * Controls Reset wake-up control
    *
    * @param llwuResetFilter Enables the digital filter for the RESET pin during LLS, VLLS3, VLLS2, or VLLS1 modes
    * @param llwuResetWakeup This bit must be set to allow the device to be reset while in a low-leakage power mode.
    *        On devices where Reset is not a dedicated pin, the RESET pin must also be enabled
    *        in the explicit port mux control
    */
   static void configureResetFilter(
         LlwuResetFilter llwuResetFilter,
         LlwuResetWakeup llwuResetWakeup = LlwuResetWakeup_Enabled) {
      llwu->RST = llwuResetFilter|llwuResetWakeup;
   }
   /*
    * ***************************************************
    * Wake-up pins
    * ***************************************************
    */
   /**
    * Configure pin as wake-up source
    *
    * @param[in] llwuPin       Pin to configure
    * @param[in] llwuPinMode   Mode for pin as wake-up input
    */
   static void configurePinSource(
         LlwuPin     llwuPin,
         LlwuPinMode llwuPinMode) {
   
      static const uint8_t masks[] =
         {LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE3_MASK, };
      volatile uint8_t &llwuPe = llwu->PE[llwuPin>>2];
      uint8_t mask = masks[llwuPin&3];
      llwuPe = (llwuPe&~mask) | (llwuPinMode&mask);
   }
   
   /**
    * Get bit mask indicating wake-up pin sources

    * The pin masks correspond to Pin sources.
    *
    * @code
    *    if ((pinWakeupSource&(1<<LlwuPin_ptc1)) != 0) {
    *       // Wakeup from LPTMR
    *    }
    * @endcode
    *
    * @return Bit mask
    */
   static uint32_t getPinWakeupSources() {
      constexpr unsigned PF_SIZE = sizeof(llwu->PF)/sizeof(llwu->PF[0]);
      if constexpr(PF_SIZE==4) {
         return (llwu->PF[1]<<24)|(llwu->PF[1]<<16)|(llwu->PF[1]<<8)|llwu->PF[0];
      }
      else if constexpr(PF_SIZE==3) {
         return (llwu->PF[1]<<16)|(llwu->PF[1]<<8)|llwu->PF[0];
      }
      else if constexpr(PF_SIZE==2) {
         return (llwu->PF[1]<<8)|llwu->PF[0];
      }
      else {
         return llwu->PF[0];
      }
   }
   
   /**
    * Check if pin is source of wake-up
    *
    * @param[in] llwuPin  Pin to check
    *
    * @return false Given pin is not source of wake-up.
    * @return true  Given pin is source of wake-up.
    */
   static bool isPinWakeupSource(LlwuPin llwuPin) {
      return getPinWakeupSources() & (1<<llwuPin);
   }
   
   /**
    * Clear wake-up pin flag
    *
    *  @param[in] llwuPin Pin indicating which flag to clear
    */
   static void clearPinWakeupFlag(LlwuPin llwuPin) {
      llwu->PF[llwuPin>>3] = (1<<(llwuPin&0x7));
   }
   
   /**
    * Clear all wake-up flags

    * Peripherals sources are not cleared since they are controlled by the peripheral
    */
   static void clearAllFlags() {
      clearPinWakeupFlags();
      clearFilteredPinWakeupFlags();
   }
   
   /**
    * Clear all wake-up pin flags
    */
   static void clearPinWakeupFlags() {
      for(unsigned index=0; index<(sizeof(llwu->PF)/sizeof(llwu->PF[0])); index++) {
         llwu->PF[index] = 0xFF;
      }
   }
   
   /*
    * ***************************************************
    * Wake-up filtered pins
    * ***************************************************
    */
   /**
    * Configure one of the input pins as a filtered wake-up source
    *
    * @param[in] llwuFilterNum      Filter to configure - number available depends on device
    * @param[in] llwuPin            Pin to assign to filter
    * @param[in] llwuFilterPinMode  Mode for pin as wake-up input
    *
    * @note Filtering is bypassed in VLLS0
    */
   static ErrorCode configureFilteredPinSource(
         LlwuFilterNum     llwuFilterNum,
         LlwuPin           llwuPin,
         LlwuFilterPinMode llwuFilterPinMode) {
   
      llwu->FILT[llwuFilterNum] = llwuPin|llwuFilterPinMode;
      return E_NO_ERROR;
   }
   
   /**
    * Check if filtered wake-up pin is source of wake-up
    *
    * @param[in] filterNum Pin Filter to check
    *
    * @return false Given filtered pin is not source of wake-up.
    * @return true  Given filtered pin is source of wake-up.
    */
   static bool isFilteredPinWakeupSource(unsigned filterNum) {
      return (llwu->FILT[filterNum] & LLWU_FILT_FILTF_MASK);
   }
   
   /**
    * Clear filtered wake-up pin flag
    *
    * @param[in] filterNum Pin Filter to clear flag
    */
   static void clearFilteredPinWakeupFlag(LlwuFilterNum filterNum) {
      llwu->FILT[filterNum] = llwu->FILT[filterNum] | LLWU_FILT_FILTF_MASK;
   }
   
   /**
    * Clear all filtered wake-up pin flags
    */
   static void clearFilteredPinWakeupFlags() {
      for (unsigned index=0; index<(sizeof(llwu->FILT)/sizeof(llwu->FILT[0])); index++) {
         llwu->FILT[index] = llwu->FILT[index] | LLWU_FILT_FILTF_MASK;
      }
   }
   
   /**
    * Disable all wake-up sources (pins and peripherals)
    */
   static void disableAllSources() {
      for (unsigned index=0; index<(sizeof(llwu->PE)/(sizeof(llwu->PE[0]))); index++) {
         llwu->PE[index] = 0;
      }
   
#if defined(LLWU_ME_WUME0_MASK)
      llwu->ME  = 0;
#endif
   }
   
   protected:
      /** Class to static check llwuPin exists and is mapped to a pin */
      template<int llwuPin> class CheckPinExistsAndIsMapped {
         // Tests are chained so only a single assertion can fail so as to reduce noise
   
         // Out of bounds value for function index
         static constexpr bool Test1 = (llwuPin>=0) && (llwuPin<(numSignals));
         // Function is not currently mapped to a pin
         static constexpr bool Test2 = !Test1 || (info[llwuPin].pinIndex != PinIndex::UNMAPPED_PCR);
         // Non-existent function and catch-all. (should be INVALID_PCR)
         static constexpr bool Test3 = !Test1 || !Test2 || (info[llwuPin].pinIndex >= PinIndex::MIN_PIN_INDEX);
   
         static_assert(Test1, "Illegal LLWU Input - Check Configure.usbdm for available inputs");
         static_assert(Test2, "LLWU input is not mapped to a pin - Modify Configure.usbdm");
         static_assert(Test3, "LLWU input doesn't exist in this device/package - Check Configure.usbdm for available input pins");
   
      public:
         /** Dummy function to allow convenient in-line checking */
         static constexpr void check() {}
      };
   
   public:
   template<LlwuPin llwuPin>
   class Pin : public PcrTable_T<LlwuInfo, llwuPin> {
   
   private:
      // Checks pin mapping is valid
      CheckPinExistsAndIsMapped<llwuPin> checkPin;
   
      using Pcr = PcrTable_T<LlwuInfo, llwuPin>;
   
      // Hide setOutput
      using Pcr::setOutput;
   
   public:
      static constexpr LlwuPin  pin = llwuPin;
   
      /**
       * Configure pin as wake-up source
       *
       * @param[in] llwuPinMode   Mode for pin as wake-up input
       */
      static void configurePinSource(LlwuPinMode llwuPinMode=LlwuPinMode_EitherEdge) {
         LlwuInfo::configurePinSource(llwuPin, llwuPinMode);
      }
   
      /**
       * Set callback for Pin interrupts
       *
       * @param[in] pinCallback The function to call on Pin interrupt. 

       *                        nullptr to indicate none
       *
       * @return E_NO_ERROR            No error
       * @return E_HANDLER_ALREADY_SET Handler already set
       *
       * @note There is a single callback function for all pins on the related port.
       *       It is necessary to identify the originating pin in the callback
       */
      static void setPinCallback(PinCallbackFunction pinCallback) {
         static_assert(Pcr::HANDLER_INSTALLED, "Gpio associated with LLWU pin not configured for PIN interrupts - Modify Configure.usbdm");
         Pcr::setPinCallback(pinCallback);
      }
   };
   
   /*
    *   Default Constructor
    */
   LlwuInfo() : LlwuBasicInfo(llwu) {
      defaultConfigure();
   }
   
   /*
    *   Constructor
    */
   LlwuInfo(const Init &init) : LlwuBasicInfo(llwu) {
      configure(init);
   }
   
   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   static void defaultConfigure() {
   
      configure(DefaultInitValue);
   }
   
   /**
    * Configure LLWU from values specified in init
    * LLWU flags from pin events are cleared.
    * Requests from peripheral devices must be cleared at source
    *
    * @param init Class containing initialisation values
    */
   static void configure(const Init &init) {
   
      // Enable peripheral
      enable();
   
      // Configure call-back
      if (init.callbacks[0] != nullptr) {
         setCallback(init.callbacks[0]);
         enableNvicInterrupts(init.priorities[0]);
      }
   
      LlwuBasicInfo::configure(llwu, init);
   }
   
   /**
    * Default initialisation value for Llwu
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr LlwuBasicInfo::Init DefaultInitValue = {
      LlwuPin_Ptd2, LlwuPinMode_FallingEdge,      // (llwu_pe4_wupe13)          Wake-up by PTD2 [LLWU_P13] - Wake-up on pin falling edge, 
      LlwuFilterNum_1, LlwuPin_Ptd4,              // (llwu_filt1_filtsel)       Pin Filter 1 Pin Select - Touch Wakeup [PTD4(p45)], 
      LlwuFilterPinMode_FallingEdge,              // (llwu_filt1_filte)         Pin Filter 1 Mode - Wake-up on filtered falling edge, 
      
      LlwuResetWakeup_Enabled , // (llwu_rst_llrste)          Low-Leakage Mode RESET Enable - RESET enabled as LLWU exit source
      LlwuResetFilter_Enabled,  // (llwu_rst_rstfilt)         Digital Filter On RESET Pin - Filter enabled,  
   };

}; // class LlwuInfo


   /**
    * Class representing LLWU instance
    */
   typedef LlwuBasicInfo LlwuInstance;
   /**
    * Class representing LLWU
    */
   typedef LlwuInfo Llwu;
   

/**
 * End LLWU_Group
 * @}
 */
#endif // /LLWU/_BasicInfoGuard
} // End namespace USBDM

#endif /* HEADER_LLWU_H */
