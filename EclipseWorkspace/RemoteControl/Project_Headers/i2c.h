/**
 * @file     i2c.h (180.ARM_Peripherals/Project_Headers/i2c.h)
 * @brief    I2C interface
 */

#ifndef INCLUDE_USBDM_I2C_H_
#define INCLUDE_USBDM_I2C_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"
#include "gpio.h"

// No handler defined for I2C0


#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

#if false // /I2C/_CommonInfoGuard

namespace USBDM {

/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief C++ Class allowing access to I2C interface
 * @{
 */
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */

   /**
    * Baud rate prescaler
    * (i2c_f_mult)
    *
    * Prescale divider to generate the I2C baud rate
    */
   enum I2cPrescale : uint8_t {
      I2cPrescale_Mul1       = I2C_F_MULT(0),  ///< mul = 1
      I2cPrescale_Mul2       = I2C_F_MULT(1),  ///< mul = 2
      I2cPrescale_Mul4       = I2C_F_MULT(2),  ///< mul = 4
      I2cPrescale_Reserved   = I2C_F_MULT(3),  ///< Reserved
   };

   /**
    * Baud rate divider
    * (i2c_f_icr)
    *
    * Divider to generate the I2C baud rate
    */
   enum I2cDivider : uint8_t {
   };

   /**
    * I2C Enable
    * (i2c_c1_iicen)
    *
    * Enables I2C module operation.
    */
   enum I2cEnable : uint8_t {
      I2cEnable_Disabled   = I2C_C1_IICEN(0),  ///< Disabled
      I2cEnable_Enabled    = I2C_C1_IICEN(1),  ///< Enabled
   };

   /**
    * Interrupt Enable
    * (i2c_c1_iicie)
    *
    * Enables I2C interrupt requests.
    */
   enum I2cAction : uint8_t {
      I2cAction_None        = I2C_C1_IICIE(0),  ///< Disabled
      I2cAction_Interrupt   = I2C_C1_IICIE(1),  ///< Enabled
   };

   /**
    * Bus Role Select
    * (i2c_c1_mst)
    *
    * Slave mode not supported
    */
   enum I2cBusRole : uint8_t {
      I2cBusRole_Peripheral   = I2C_C1_MST(0),  ///< Peripheral mode
      I2cBusRole_Controller   = I2C_C1_MST(1),  ///< Controller mode
   };

   /**
    * Transmit Mode Select
    * (i2c_c1_tx)
    *
    * Selects the direction of master and slave transfers.
    * In master mode this bit must be set according to the type of transfer required.
    * Therefore, for address cycles, this bit is always set.
    * When addressed as a slave this bit must be set by software according to the SRW bit in the status register.
    */
   enum I2cTransferDirection {
      I2cTransferDirection_Receive    = I2C_C1_TX(0),  ///< Receive
      I2cTransferDirection_Transmit   = I2C_C1_TX(1),  ///< Transmit
   };

   /**
    * Transmit Acknowledge Enable
    * (i2c_c1_txak)
    *
    * Controls if an acknowledge signal is sent to the bus on
    * the following receiving byte (if FACK is cleared) or the current receiving byte (if FACK is set)
    */
   enum I2cAcknowledge : uint8_t {
      I2cAcknowledge_SendAck     = I2C_C1_TXAK(0),  ///< Acknowledge sent
      I2cAcknowledge_SendNoAck   = I2C_C1_TXAK(1),  ///< No acknowledge
   };

   /**
    * Repeat START
    * (i2c_c1_rsta)
    *
    * Writing a one to this bit generates a repeated START condition
    * provided it is the current master.
    * This bit will always be read as zero
    */
   enum I2cRepeatStart {
      I2cRepeatStart_Send   = I2C_C1_RSTA(0),  ///< Write 1 to trigger
   };

   /**
    * Wake-up on match
    * (i2c_c1_wuen)
    *
    * Controls if an interrupt is generated when address matching in low power mode
    * To have effect interrupts must be enabled in I2C
    */
   enum I2cWakeup : uint8_t {
      I2cWakeup_Disabled   = I2C_C1_WUEN(0),  ///< Disabled
      I2cWakeup_Enabled    = I2C_C1_WUEN(1),  ///< Enabled
   };

   /**
    * DMA transfer enable
    * (i2c_c1_dmaen)
    *
    * If DMA transfer is enabled the following conditions trigger the DMA request:
    * - While FACK = 0, a data byte is received, either address or data is transmitted. (ACK/NACK automatic)
    * - While FACK = 0, the first byte received matches the A1 register or is general call address.                If
    *  any address matching occurs, IAAS and TCF are set.                If the direction of transfer is known from 
    * master to slave, then it is not required to check the SRW.                With this assumption, DMA can also be
    *  used in this case.                In other cases, if the master reads data from the slave, then it is required
    *  to rewrite the C1 register operation.                 With this assumption, DMA cannot be used.               
    *  - When FACK = 1, an address or a data byte is transmitted
    */
   enum I2cDmaTransfer : uint8_t {
      I2cDmaTransfer_Disabled   = I2C_C1_DMAEN(0),  ///< DMA disabled
      I2cDmaTransfer_Enabled    = I2C_C1_DMAEN(1),  ///< DMA enabled
   };

   /**
    * Transfer Complete Flag
    * (i2c_s_tcf)
    *
    * 
    */
   enum I2cTransferCompleteFlag : uint8_t {
      I2cTransferCompleteFlag_TransferInProgress   = I2C_S_TCF(0),  ///< Transfer in progress
      I2cTransferCompleteFlag_TransferComplete     = I2C_S_TCF(1),  ///< Transfer complete
   };

   /**
    * Addressed As A Slave
    * (i2c_s_iaas)
    *
    * This bit is set by one of the following conditions:
    * - The calling address matches the programmed primary slave address in the A1 register, or matches          the 
    * range address in the RA register (which must be set to a nonzero value and under the condition          
    * I2C_C2[RMEN] = 1).
    * - C2[GCAEN] is set and a general call is received.
    * - SMB[SIICAEN] is set and the calling address matches the second programmed slave address.
    * - ALERTEN is set and an SMBus alert response address is received
    * - RMEN is set and an address is received that is within the range between the values of the A1 and             
    * RA registers.
    * IAAS sets before the ACK bit.
    * The CPU must check the SRW bit and set TX/RX accordingly.
    * Writing the C1 register with any value clears this bit.
    */
   enum I2cAddressedAsASlave : uint8_t {
      I2cAddressedAsASlave_NotAddressed        = I2C_S_IAAS(0),  ///< Not addressed
      I2cAddressedAsASlave_AddressedAsASlave   = I2C_S_IAAS(1),  ///< Addressed as a slave
   };

   /**
    * Bus Busy
    * (i2c_s_busy)
    *
    * Indicates the status of the bus regardless of slave or master mode.
    * This bit is set when a START signal is detected and cleared when a STOP signal is detected.
    */
   enum I2cBusState : uint8_t {
      I2cBusState_BusIsIdle   = I2C_S_BUSY(0),  ///< Bus is idle
      I2cBusState_BusIsBusy   = I2C_S_BUSY(1),  ///< Bus is busy
   };

   /**
    * Arbitration Lost
    * (i2c_s_arbl)
    *
    * This bit is set by hardware when the arbitration procedure is lost.
    * The ARBL bit must be cleared by software, by writing 1 to it.
    */
   enum I2cArbitrationStatus : uint8_t {
      I2cArbitrationStatus_Normal            = I2C_S_ARBL(0),  ///< Standard bus operation
      I2cArbitrationStatus_ArbitrationLost   = I2C_S_ARBL(1),  ///< Loss of arbitration
   };

   /**
    * Range Address Match
    * (i2c_s_ram)
    *
    * This bit is set by any of the following conditions:
    * - Any nonzero calling address is received that matches the address in the RA register.
    * - The RMEN bit is set and the calling address is within the range of values of the A1 and RA register
    */
   enum I2cRangeAddressMatch : uint8_t {
      I2cRangeAddressMatch_NotAddressed        = I2C_S_RAM(0),  ///< Not addressed
      I2cRangeAddressMatch_AddressedAsASlave   = I2C_S_RAM(1),  ///< Addressed as a slave
   };

   /**
    * Slave Read/Write
    * (i2c_s_srw)
    *
    * When addressed as a slave, SRW indicates the value of the R/W command bit of
    * the calling address sent to the master.
    */
   enum I2cSlaveRead_Write : uint8_t {
      I2cSlaveRead_Write_SlaveReceive    = I2C_S_SRW(0),  ///< Slave receive
      I2cSlaveRead_Write_SlaveTransmit   = I2C_S_SRW(1),  ///< Slave transmit
   };

   /**
    * Interrupt Flag
    * (i2c_s_iicif)
    *
    * This bit sets when an interrupt is pending.
    * This bit must be cleared by software by writing 1 to it, such as in the interrupt routine.
    * One of the following events can set this bit:                - One byte transfer, including ACK/NACK bit, 
    * completes if FACK is 0. An ACK or NACK is sent on the                bus by writing 0 or 1 to TXAK after this 
    * bit is set in receive mode.
    * - One byte transfer, excluding ACK/NACK bit, completes if FACK is 1.
    * - Match of slave address to calling address including primary slave address, range slave address,              
    *  alert response address, second slave address, or general call address.
    * - Arbitration lost
    * - In SMBus mode, any timeouts except SCL and SDA high timeouts
    * - I2C bus stop or start detection if the SSIE bit in the Input Glitch Filter register is 1
    * To clear the I2C bus stop or start detection interrupt:
    * In the interrupt service routine, first clear the STOPF or STARTF bit in the Input Glitch Filter               
    *  register by writing 1 to it, and then clear the IICIF bit. If this sequence is reversed, the IICIF            
    *  bit is asserted again.
    */
   enum I2cInterruptFlag : uint8_t {
      I2cInterruptFlag_InterruptNotPending   = I2C_S_IICIF(0),  ///< Interrupt not pending
      I2cInterruptFlag_InterruptPending      = I2C_S_IICIF(1),  ///< Interrupt pending
   };

   /**
    * Receive Acknowledge
    * (i2c_s_rxak)
    *
    * Indicates if an acknowledge signal was received after the completion of one byte
    * of data transmission on the bus
    */
   enum I2cReceiveAcknowledge : uint8_t {
      I2cReceiveAcknowledge_AcknowledgeReceived   = I2C_S_RXAK(0),  ///< Acknowledge received
      I2cReceiveAcknowledge_NoAcknowledge         = I2C_S_RXAK(1),  ///< No acknowledge
   };

   /**
    * Data
    * (i2c_d_data)
    *
    * In master transmit mode, when data is written to this register, a data transfer is initiated.
    * The most significant bit is sent first.
    * In master receive mode, reading this register initiates receiving of the next byte of data.
    */
   enum Uint8_t : uint8_t {
   };

   /**
    * General Call Address
    * (i2c_c2_gcaen)
    *
    * Enables General call address
    */
   enum I2cGeneralCall : uint8_t {
      I2cGeneralCall_Disabled   = I2C_C2_GCAEN(0),  ///< Disabled
      I2cGeneralCall_Enabled    = I2C_C2_GCAEN(1),  ///< Enabled
   };

   /**
    * High Drive Select
    * (i2c_c2_hdrs)
    *
    * Increases the pin drive on SCL and SDA
    */
   enum I2cHighDrive : uint8_t {
      I2cHighDrive_NormalDriveMode   = I2C_C2_HDRS(0),  ///< Normal drive mode
      I2cHighDrive_HighDriveMode     = I2C_C2_HDRS(1),  ///< High drive mode
   };

   /**
    * Address Extension
    * (i2c_c2_adext)
    *
    * Selects between 7-bit and 9-bit address schemes
    */
   enum I2cAddressLength : uint8_t {
      I2cAddressLength_7Bit    = I2C_C2_ADEXT(0),  ///< 7-bit address
      I2cAddressLength_10Bit   = I2C_C2_ADEXT(1),  ///< 10-bit address
   };

   /**
    * Slave Baud Rate Control
    * (i2c_c2_sbrc)
    *
    * Allows the slave baud rate to follows the master baud rate with clock stretching occurring
    */
   enum I2cSlaveBaudRate : uint8_t {
      I2cSlaveBaudRate_SlaveRateFollowsMaster   = I2C_C2_SBRC(0),  ///< Slave rate follows master
      I2cSlaveBaudRate_SlaveRateIndependent     = I2C_C2_SBRC(1),  ///< Slave rate independent
   };

   /**
    * Slave Address
    * (i2c_slaveaddress)
    *
    * Primary slave address used by the I2C module when it is addressed as a slave
    * Note: This is a physical device address i.e. an 8-bit or 11-bit value with the LSB=0
    */
   enum Int : uint8_t {
   };

   /**
    * Range Address Matching
    * (i2c_c2_rmen)
    *
    * Enables address matching for a range of slave addresses (A1..RA)
    */
   enum I2cRangeAddressMatchingEnable : uint8_t {
      I2cRangeAddressMatchingEnable_Disabled   = I2C_C2_RMEN(0),  ///< Range mode disabled
      I2cRangeAddressMatchingEnable_Enabled    = I2C_C2_RMEN(1),  ///< Range mode enabled
   };

   /**
    * Programmable Filter Factor
    * (i2c_flt_flt)
    *
    * Controls the width of the glitch, in terms of I2C module clock cycles, that the filter must absorb.
    * For any glitch whose size is less than or equal to this width setting, the filter does not allow the glitch to 
    * pass
    */
   enum I2cFilter : uint8_t {
      I2cFilter_NoFilterBypass   = I2C_FLT_FLT(0),   ///< No filter
      I2cFilter_1_ClockCycle     = I2C_FLT_FLT(1),   ///< 1 clock cycle
      I2cFilter_2_ClockCycles    = I2C_FLT_FLT(2),   ///< 2 clock cycles
      I2cFilter_3_ClockCycles    = I2C_FLT_FLT(3),   ///< 3 clock cycles
      I2cFilter_4_ClockCycles    = I2C_FLT_FLT(4),   ///< 4 clock cycles
      I2cFilter_5_ClockCycles    = I2C_FLT_FLT(5),   ///< 5 clock cycles
      I2cFilter_6_ClockCycles    = I2C_FLT_FLT(6),   ///< 6 clock cycles
      I2cFilter_7_ClockCycles    = I2C_FLT_FLT(7),   ///< 7 clock cycles
      I2cFilter_8_ClockCycles    = I2C_FLT_FLT(8),   ///< 8 clock cycles
      I2cFilter_9_ClockCycles    = I2C_FLT_FLT(9),   ///< 9 clock cycles
      I2cFilter_10_ClockCycles   = I2C_FLT_FLT(10),  ///< 10 clock cycles
      I2cFilter_11_ClockCycles   = I2C_FLT_FLT(11),  ///< 11 clock cycles
      I2cFilter_12_ClockCycles   = I2C_FLT_FLT(12),  ///< 12 clock cycles
      I2cFilter_13_ClockCycles   = I2C_FLT_FLT(13),  ///< 13 clock cycles
      I2cFilter_14_ClockCycles   = I2C_FLT_FLT(14),  ///< 14 clock cycles
      I2cFilter_15_ClockCycles   = I2C_FLT_FLT(15),  ///< 15 clock cycles
   };

   /**
    * Fast NACK/ACK
    * (i2c_smb_fack)
    *
    * For SMBus packet error checking, the CPU must be able to issue an ACK or NACK according to the result of 
    * receiving data byte
    */
   enum I2cSmbFastAck : uint8_t {
      I2cSmbFastAck_Disabled   = I2C_SMB_FACK(0),  ///< ACK/NAK on data byte
      I2cSmbFastAck_Enabled    = I2C_SMB_FACK(1),  ///< ACK/NAK on TXAK write
   };

   /**
    * SMBus Alert Response Address
    * (i2c_smb_alerten)
    *
    * Enables or disables SMBus alert response address matching
    */
   enum I2cSmbAlert : uint8_t {
      I2cSmbAlert_Disabled   = I2C_SMB_ALERTEN(0),  ///< Matching disabled
      I2cSmbAlert_Enabled    = I2C_SMB_ALERTEN(1),  ///< Matching enabled
   };

   /**
    * Timeout Counter Clock Select
    * (i2c_smb_tcksel)
    *
    * Selects the clock source of the timeout counter
    */
   enum I2cSmbTimeoutClock : uint8_t {
      I2cSmbTimeoutClock_BusClockDiv64   = I2C_SMB_TCKSEL(0),  ///< Bus clock / 64
      I2cSmbTimeoutClock_BusClock        = I2C_SMB_TCKSEL(1),  ///< Bus clock
   };

   /**
    * SCL Low Timeout Flag
    * (i2c_smb_sltf)
    *
    * This flag sets when an SCL low timeout occurs
    */
   enum I2cSclLowTimeout : uint8_t {
      I2cSclLowTimeout_NoTimeoutOccurs   = I2C_SMB_SLTF(0),  ///< No timeout occurs
      I2cSclLowTimeout_TimeoutOccurs     = I2C_SMB_SLTF(1),  ///< Timeout occurs
   };

   /**
    * SCL High Timeout Flag 1
    * (i2c_smb_shtf1)
    *
    * This read-only bit sets when SCL and SDA are held high more than LoValue/512 clock cycles, which indicates the 
    * bus is free.
    * This bit is cleared automatically
    */
   enum I2cSclHighTimeoutFlag1 : uint8_t {
      I2cSclHighTimeoutFlag1_NoTimeoutOccurs   = I2C_SMB_SHTF1(0),  ///< No timeout occurs
      I2cSclHighTimeoutFlag1_TimeoutOccurs     = I2C_SMB_SHTF1(1),  ///< Timeout occurs
   };

   /**
    * SCL High Timeout Flag 2
    * (i2c_smb_shtf2)
    *
    * This bit sets when SCL is held high and SDA is held low more than LoValue/512 clock cycles.
    * Software clears this bit by writing a 1 to it
    */
   enum I2cSclHighTimeout : uint8_t {
      I2cSclHighTimeout_NoTimeoutOccurred   = I2C_SMB_SHTF2(0),  ///< No timeout occurred
      I2cSclHighTimeout_TimeoutOccurred     = I2C_SMB_SHTF2(1),  ///< Timeout occurred
   };

   /**
    * SCL high/low timout Interrupt
    * (i2c_smb_shtf2ie)
    *
    * Enables SCL high and SDA low timeout interrupt
    */
   enum I2cSmbTimeoutInterrupt : uint8_t {
      I2cSmbTimeoutInterrupt_Disabled   = I2C_SMB_SHTF2IE(0),  ///< Interrupt disabled
      I2cSmbTimeoutInterrupt_Enabled    = I2C_SMB_SHTF2IE(1),  ///< Interrupt enabled
   };

   /**
    * Second I2C Address (SMB)
    * (i2c_smb_siicaen)
    *
    * Enables or disables SMBus device default address
    */
   enum I2cSmbAddressEnable : uint8_t {
      I2cSmbAddressEnable_Disabled   = I2C_SMB_SIICAEN(0),  ///< Address 2 (SMB) disabled
      I2cSmbAddressEnable_Enabled    = I2C_SMB_SIICAEN(1),  ///< Address 2 (SMB) enabled
   };

   /**
    * SCL low timeout value
    * (i2c_slt_value)
    *
    * SCL low timeout
    */
   enum I2cSmbLowTimeout : uint16_t {
   };


   // Bit operators for SMB register fields
   constexpr inline uint8_t operator|(I2cSclLowTimeout op1, I2cSclHighTimeout op2)  { return uint8_t(op1)|uint8_t(op2); };
   constexpr inline uint8_t operator|(I2cSclHighTimeout op1, I2cSclLowTimeout op2)  { return uint8_t(op1)|uint8_t(op2); };
   
class I2cBasicInfo {

public:

}; // class I2cBasicInfo 

class I2c0Info : public I2cBasicInfo {

public:

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: I2C0_SCL             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: I2C0_SDA             = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:i2c0_mk10d5
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with I2C0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with I2C0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = I2C0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to I2c0
    */
   static void enableClock() {
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_I2C0_MASK;
   }
   
   /**
    *  Disable clock to I2c0
    */
   static void disableClock() {
      SIM->SCGC4 = SIM->SCGC4 & ~SIM_SCGC4_I2C0_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = I2C0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<I2C_Type> i2c = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
}; // class I2c0Info





/**
 * End I2C_Group
 * @}
 */

} // End namespace USBDM

#endif // /I2C/_BasicInfoGuard

#endif /* INCLUDE_USBDM_I2C_H_ */
