/**
 * @file     i2s.h (180.ARM_Peripherals/Project_Headers/i2s.h)
 * @brief    I2S interface
 */

#ifndef HEADER_I2S_H
#define HEADER_I2S_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include "derivative.h"
#include "gpio.h"
#include "pin_mapping.h"

// No handler defined for I2S0 Tx
// No handler defined for I2S0 Rx


#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

#if false // /I2S/_BasicInfoGuard

namespace USBDM {

/**
 * @addtogroup I2S_Group I2S, Synchronous Audio Interface
 * @brief C++ Class allowing access to I2S interface
 * @{
 */
/**
 * Peripheral information for I2S, Synchronous Audio Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */

   /**
    * Channel Number
    * (channelNum)
    *
    * Selects transmit or receive channel
    */
   enum I2sChannelNum {
      I2sChannelNum_0   = 0,  ///< Channel 0
   };

   /**
    * Transmitter Enable
    * (i2s_tcsr_te)
    *
    * When software clears this field, the transmitter remains enabled, and
    * this bit remains set, until the end of the current frame
    */
   enum I2sTransmitEnable {
      I2sTransmitEnable_Disabled   = I2S_TCSR_TE(0),  ///< Transmitter disabled
      I2sTransmitEnable_Enabled    = I2S_TCSR_TE(1),  ///< Transmitter enabled
   };

   /**
    * Software Reset
    * (i2s_tcsr_sr)
    *
    * When set, resets the internal transmitter logic including the FIFO pointers.
    * Software-visible registers are not affected, except for the status
    */
   enum I2sTransmitReset {
      I2sTransmitReset_NoEffect        = I2S_TCSR_SR(0),  ///< No effect
      I2sTransmitReset_SoftwareReset   = I2S_TCSR_SR(1),  ///< Software reset
   };

   /**
    * FIFO Reset
    * (i2s_tcsr_fr)
    *
    * Resets the FIFO pointers. Reading this field will always return zero
    */
   enum I2sTransmitFifoReset {
      I2sTransmitFifoReset_Write1ToReset   = I2S_TCSR_FR(0),  ///< Write 1 to reset
   };

   /**
    * Stop Enable
    * (i2s_tcsr_stope)
    *
    * Configures transmitter operation in Stop mode.
    * This field is ignored and the transmitter is disabled in all low-leakage stop modes
    */
   enum I2sTransmitStopMode {
      I2sTransmitStopMode_DisabledInStopMode   = I2S_TCSR_STOPE(0),  ///< Disabled in Stop mode
      I2sTransmitStopMode_EnabledInStopMode    = I2S_TCSR_STOPE(1),  ///< Enabled in Stop mode
   };

   /**
    * Debug Enable
    * (i2s_tcsr_dbge)
    *
    * Enables/disables transmitter operation in Debug mode.
    * The transmit bit clock is not affected by debug mode
    */
   enum I2sTransmitDebugMode {
      I2sTransmitDebugMode_DisabledInDebugMode   = I2S_TCSR_DBGE(0),  ///< Disabled in Debug mode
      I2sTransmitDebugMode_EnabledInDebugMode    = I2S_TCSR_DBGE(1),  ///< Enabled in Debug mode
   };

   /**
    * Bit Clock Enable
    * (i2s_tcsr_bce)
    *
    * Enables the transmit bit clock, separately from the TE.
    * This field is automatically set whenever TE is set. 
    * When software clears this field, the transmit bit clock remains enabled,
    * and this bit remains set, until the end of the current frame
    */
   enum I2sTransmitBitClock {
      I2sTransmitBitClock_Disabled   = I2S_TCSR_BCE(0),  ///< Transmit clock disabled
      I2sTransmitBitClock_Enabled    = I2S_TCSR_BCE(1),  ///< Transmit clock enabled
   };

   /**
    * Word Start Flag
    * (i2s_tcsr_wsf)
    *
    * Indicates that the start of the configured word has been detected.
    * Write a logic 1 to this field to clear this flag
    */
   enum I2sTransmitWordStartFlag {
      I2sTransmitWordStartFlag_StartNotDetected   = I2S_TCSR_WSF(0),  ///< Start not detected
      I2sTransmitWordStartFlag_StartDetected      = I2S_TCSR_WSF(1),  ///< Start detected
   };

   /**
    * Sync Error Flag
    * (i2s_tcsr_sef)
    *
    * Indicates that an error in the externally-generated frame sync has been detected.
    * Write a logic 1 to this field to clear this flag
    */
   enum I2sTransmitSyncErrorFlag {
      I2sTransmitSyncErrorFlag_NoError             = I2S_TCSR_SEF(0),  ///< No error
      I2sTransmitSyncErrorFlag_SyncErrorDetected   = I2S_TCSR_SEF(1),  ///< Sync error detected
   };

   /**
    * FIFO Error Flag
    * (i2s_tcsr_fef)
    *
    * Indicates that an enabled transmit FIFO has underrun.
    * Write a logic 1 to this field to clear this flag
    */
   enum I2sTransmitFifoErrorFlag {
      I2sTransmitFifoErrorFlag_UnderrunNotDetected   = I2S_TCSR_FEF(0),  ///< Underrun not detected
      I2sTransmitFifoErrorFlag_UnderrunDetected      = I2S_TCSR_FEF(1),  ///< Underrun detected
   };

   /**
    * FIFO Warning Flag
    * (i2s_tcsr_fwf)
    *
    * Indicates that an enabled transmit FIFO is empty
    */
   enum I2sTransmitFifoEmptyFlag {
      I2sTransmitFifoEmptyFlag_NoTransmitFifoEmpty   = I2S_TCSR_FWF(0),  ///< No transmit FIFO empty
      I2sTransmitFifoEmptyFlag_TransmitFifoIsEmpty   = I2S_TCSR_FWF(1),  ///< Transmit FIFO is empty
   };

   /**
    * FIFO Request Flag
    * (i2s_tcsr_frf)
    *
    * Indicates that the number of words in an enabled transmit channel FIFO
    * is less than or equal to the transmit FIFO watermark
    */
   enum I2sTransmitFifoRequestFlag {
      I2sTransmitFifoRequestFlag_FifoWatermarkNotReached   = I2S_TCSR_FRF(0),  ///< FIFO watermark not reached
      I2sTransmitFifoRequestFlag_FifoWatermarkReached      = I2S_TCSR_FRF(1),  ///< FIFO watermark reached
   };

   /**
    * Word Start Action
    * (i2s_tcsr_wsie)
    *
    * Enables/disables word start interrupts
    */
   enum I2sTransmitWordStartAction {
      I2sTransmitWordStartAction_None        = I2S_TCSR_WSIE(0),  ///< Interrupt disabled
      I2sTransmitWordStartAction_Interrupt   = I2S_TCSR_WSIE(1),  ///< Interrupt enabled
   };

   /**
    * Sync Error Action
    * (i2s_tcsr_seie)
    *
    * Enables/disables sync error interrupts
    */
   enum I2sTransmitSyncErrorAction {
      I2sTransmitSyncErrorAction_None        = I2S_TCSR_SEIE(0),  ///< Interrupt disabled
      I2sTransmitSyncErrorAction_Interrupt   = I2S_TCSR_SEIE(1),  ///< Interrupt enabled
   };

   /**
    * FIFO Error Action
    * (i2s_tcsr_feie)
    *
    * Enables/disables FIFO error interrupts
    */
   enum I2sTransmitFifoErrorAction {
      I2sTransmitFifoErrorAction_None        = I2S_TCSR_FEIE(0),  ///< Interrupt disabled
      I2sTransmitFifoErrorAction_Interrupt   = I2S_TCSR_FEIE(1),  ///< Interrupt enabled
   };

   /**
    * FIFO Warning Action
    * (i2s_tcsr_warning)
    *
    * Action taken in FIFO warning level
    */
   enum I2sTransmitWarningAction {
      I2sTransmitWarningAction_None                     = I2S_TCSR_FWIE(0)|I2S_TCSR_FWDE(0),  ///< No action
      I2sTransmitWarningAction_Interrupt                = I2S_TCSR_FWIE(1)|I2S_TCSR_FWDE(0),  ///< Interrupt Request
      I2sTransmitWarningAction_DmaRequest               = I2S_TCSR_FWIE(0)|I2S_TCSR_FWDE(1),  ///< Dma Request
      I2sTransmitWarningAction_InterruptAndDmaRequest   = I2S_TCSR_FWIE(1)|I2S_TCSR_FWDE(1),  ///< Interrupt and Dma Request
   };

   /**
    * FIFO Warning Action
    * (i2s_tcsr_request)
    *
    * Action taken in FIFO request level
    */
   enum I2sTransmitRequestAction {
      I2sTransmitRequestAction_None                     = I2S_TCSR_FRIE(0)|I2S_TCSR_FRDE(0),  ///< No action
      I2sTransmitRequestAction_Interrupt                = I2S_TCSR_FRIE(1)|I2S_TCSR_FRDE(0),  ///< Interrupt Request
      I2sTransmitRequestAction_DmaRequest               = I2S_TCSR_FRIE(0)|I2S_TCSR_FRDE(1),  ///< Dma Request
      I2sTransmitRequestAction_InterruptAndDmaRequest   = I2S_TCSR_FRIE(1)|I2S_TCSR_FRDE(1),  ///< Interrupt and Dma Request
   };

   /**
    * Transmit FIFO Watermark
    * (i2s_tcr1_tfw)
    *
    * Configures the watermark level for all enabled transmit channels
    */
   enum I2sTransmitFifoWatermark {
      I2sTransmitFifoWatermark_Level0   = I2S_TCR1_TFW(0),  ///< Interrupt disabled
      I2sTransmitFifoWatermark_Level1   = I2S_TCR1_TFW(1),  ///< Interrupt enabled
   };

   /**
    * Synchronous Mode
    * (i2s_tcr2_sync)
    *
    * Configures between asynchronous and synchronous modes of operation. 
    * When configured for a synchronous mode of operation, the receiver must
    * be configured for asynchronous operation.
    */
   enum I2sTransmitSynchMode {
      I2sTransmitSynchMode_AsynchronousMode          = I2S_TCR2_SYNC(0),  ///< Asynchronous mode
      I2sTransmitSynchMode_SynchronousWithReceiver   = I2S_TCR2_SYNC(1),  ///< Synchronous with receiver
      I2sTransmitSynchMode_ExternalSaiTransmitter    = I2S_TCR2_SYNC(2),  ///< External SAI transmitter
      I2sTransmitSynchMode_ExternalSaiReceiver       = I2S_TCR2_SYNC(3),  ///< External SAI receiver
   };

   /**
    * Bit Clock Swap
    * (i2s_tcr2_bcs)
    *
    * When the SAI is in asynchronous mode and this field is set to 1,
    * the transmitter is clocked by the receiver bit clock. 
    * When the SAI is in synchronous mode and this field is set to 1,
    * the transmitter is clocked by the transmitter bit clock, but it 
    * uses the receiver frame sync.
    */
   enum I2sTransmitBitClockSwap {
      I2sTransmitBitClockSwap_NormalBitClockSource   = I2S_TCR2_BCS(0),  ///< Normal bit clock source
      I2sTransmitBitClockSwap_SwapBitClockSource     = I2S_TCR2_BCS(1),  ///< Swap bit clock source
   };

   /**
    * Bit Clock Input
    * (i2s_tcr2_bci)
    *
    * When set in either asynchronous or synchronous mode and using an
    * internally generated bit clock, configures the internal logic to be
    * clocked as if the bit clock was externally generated. 
    * This has the effect of decreasing data input setup time, but
    * increasing data output valid time.
    * This bit has no effect when configured for an externally generated bit clock.
    */
   enum I2sTransmitBitClockInput {
      I2sTransmitBitClockInput_NoEffect                                   = I2S_TCR2_BCI(0),  ///< No effect
      I2sTransmitBitClockInput_InternalLogicIsClockedByExternalBitClock   = I2S_TCR2_BCI(1),  ///< Internal logic is clocked by external bit clock
   };

   /**
    * Clocking mode
    * (i2s_tcr2_msel)
    *
    * When configured for external bit clock configures for asynchronous
    * or synchronous operation. 
    * When configured for internal bit clock, selects the Audio Master Clock
    * used to generate the internal bit clock
    */
   enum I2sTransmitMasterClock {
      I2sTransmitMasterClock_BusClockOrAsynchronous   = I2S_TCR2_MSEL(0),  ///< Bus Clock (or Asynchronous)
      I2sTransmitMasterClock_MasterClock1             = I2S_TCR2_MSEL(1),  ///< Master Clock 1
      I2sTransmitMasterClock_MasterClock2             = I2S_TCR2_MSEL(2),  ///< Master Clock 2
      I2sTransmitMasterClock_MasterClock3             = I2S_TCR2_MSEL(3),  ///< Master Clock 3
   };

   /**
    * Bit Clock Polarity
    * (i2s_tcr2_bcp)
    *
    * Configures the polarity of the bit clock
    */
   enum I2sTransmitBitClockPolarity {
      I2sTransmitBitClockPolarity_ActiveHigh   = I2S_TCR2_BCP(0),  ///< Active high
      I2sTransmitBitClockPolarity_ActiveLow    = I2S_TCR2_BCP(1),  ///< Active Low
   };

   /**
    * Bit Clock Direction
    * (i2s_tcr2_bcd)
    *
    * Configures the direction of the bit clock
    */
   enum I2sTransmitBitClockDirection {
      I2sTransmitBitClockDirection_ExternalBitClock   = I2S_TCR2_BCD(0),  ///< External bit clock
      I2sTransmitBitClockDirection_InternalBitClock   = I2S_TCR2_BCD(1),  ///< Internal bit clock
   };

   /**
    * Bit Clock Divide
    * (i2s_tcr2_div)
    *
    * Divides down the audio master clock to generate the bit clock when configured for an internal bit clock.
    * The division value is (DIV + 1) * 2
    */
   enum I2sTransmitBitClockDivider : uint8_t {
   };

   /**
    * Transmit Channel Enable
    * (i2s_tcr3_tce)
    *
    * Enables the corresponding data channel for transmit operation.
    * A channel must be enabled before its FIFO is accessed
    */
   enum I2sTransmitChannelEnable {
      I2sTransmitChannelEnable_ChannelDisabled   = I2S_TCR3_TCE(0),  ///< Channel disabled
      I2sTransmitChannelEnable_ChannelEnabled    = I2S_TCR3_TCE(1),  ///< Channel enabled
   };

   /**
    * Word Flag Configuration
    * (i2s_tcr3_wdfl)
    *
    * Configures which word sets the start of word flag.
    * The value written must be one less than the word number.
    * For example, writing 0 configures the first word in the frame
    */
   enum I2sTransmitWordFlagNum : uint8_t {
   };

   /**
    * Frame size
    * (i2s_tcr4_frsz)
    *
    * Configures the number of words in each frame.
    * The value written must be one less than the number of words in the frame.
    * For example, write 0 for one word per frame
    */
   enum I2sTransmitFrameSize : uint8_t {
   };

   /**
    * Sync Width
    * (i2s_tcr4_sywd)
    *
    * Configures the length of the frame sync in number of bit clocks.
    * The value written must be one less than the number of bit clocks.
    * or example, write 0 for the frame sync to assert for one bit clock only
    */
   enum I2sTransmitSyncWidth : uint8_t {
   };

   /**
    * MSB First
    * (i2s_tcr4_mf)
    *
    * Configures whether the LSB or the MSB is transmitted/received first
    */
   enum I2sTransmitBitOrder {
      I2sTransmitBitOrder_LsbFirst   = I2S_TCR4_MF(0),  ///< LSB first
      I2sTransmitBitOrder_MsbFirst   = I2S_TCR4_MF(1),  ///< MSB first
   };

   /**
    * Frame Sync Early
    * (i2s_tcr4_fse)
    *
    * Control where frame sync asserts relative to 1st bit of the frame
    */
   enum I2sTransmitEarlySync {
      I2sTransmitEarlySync_AssertsWithFirstBit           = I2S_TCR4_FSE(0),  ///< Asserts with first bit
      I2sTransmitEarlySync_AssertsOneBitBeforeFirstBit   = I2S_TCR4_FSE(1),  ///< Asserts one bit before first bit
   };

   /**
    * Frame Sync Polarity
    * (i2s_tcr4_fsp)
    *
    * Configures the polarity of the frame sync
    */
   enum I2sTransmitFrameSyncPolarity {
      I2sTransmitFrameSyncPolarity_ActiveHigh   = I2S_TCR4_FSP(0),  ///< Active high
      I2sTransmitFrameSyncPolarity_ActiveLow    = I2S_TCR4_FSP(1),  ///< Active low
   };

   /**
    * Frame Sync Direction
    * (i2s_tcr4_fsd)
    *
    * Configures the direction of the frame sync
    */
   enum I2sTransmitFrameSyncDirection {
      I2sTransmitFrameSyncDirection_ExternalFrameSync   = I2S_TCR4_FSD(0),  ///< External Frame Sync
      I2sTransmitFrameSyncDirection_InternalFrameSync   = I2S_TCR4_FSD(1),  ///< Internal Frame Sync
   };

   /**
    * Word N Width
    * (i2s_tcr5_wnw)
    *
    * Configures the number of bits in each word, for each word except the first in the frame.
    * The value written must be one less than the number of bits per word.
    * The value of WNW must be greater than or equal to the value of W0W even when there is only one word in each 
    * frame.
    * Word width of less than 8 bits is not supported
    */
   enum I2sTransmitWordNWidth : uint8_t {
   };

   /**
    * Word 0 Width
    * (i2s_tcr5_w0w)
    *
    * Configures the number of bits in the first word in each frame.
    * The value written must be one less than the number of bits in the first word.
    * Word width of less than 8 bits is not supported if there is only one word per frame
    */
   enum I2sTransmitWord0Width : uint8_t {
   };

   /**
    * First Bit Shifted
    * (i2s_tcr5_fbt)
    *
    * Configures the bit index for the first bit transmitted for each word in the frame.
    * If configured for MSB First, the index of the next bit transmitted is one less than the current bit 
    * transmitted.
    * If configured for LSB First, the index of the next bit transmitted is one more than the current bit transmitted
    */
   enum I2sTransmitFirstBitShifted : uint8_t {
   };

   /**
    * Transmit FIFO Write Pointer
    * (i2s_tfr_wfp)
    *
    * FIFO write pointer for transmit data channel
    */
   enum I2sTransmitFifoWritePointer : uint8_t {
   };

   /**
    * Transmit FIFO Read Pointer
    * (i2s_tfr_rfp)
    *
    * FIFO read pointer for transmit data channel
    */
   enum I2sTransmitFifoReadPointer : uint8_t {
   };

   /**
    * Transmit Word Mask
    * (i2s_tmr_twm)
    *
    * Configures whether the transmit word is masked (transmit data pin tri-stated and 
    * transmit data not read from FIFO) for the corresponding word in the frame
    */
   enum I2sTransmitWordMask {
      I2sTransmitWordMask_WordNEnabled    = I2S_TMR_TWM(0),  ///< Word N enabled
      I2sTransmitWordMask_WordNIsMasked   = I2S_TMR_TWM(1),  ///< Word N is masked
   };

   /**
    * Receiver Enable
    * (i2s_rcsr_re)
    *
    * When software clears this field, the receiver remains enabled, and
    * this bit remains set, until the end of the current frame
    */
   enum I2sReceiveEnable {
      I2sReceiveEnable_ReceiverDisabled   = I2S_RCSR_RE(0),  ///< Receiver disabled
      I2sReceiveEnable_ReceiverEnabled    = I2S_RCSR_RE(1),  ///< Receiver enabled
   };

   /**
    * Stop Enable
    * (i2s_rcsr_stope)
    *
    * Configures receiver operation in Stop mode.
    * This bit is ignored and the receiver is disabled in all low-leakage stop modes
    */
   enum I2sReceiveStopMode {
      I2sReceiveStopMode_DisabledInStopMode   = I2S_RCSR_STOPE(0),  ///< Disabled in Stop mode
      I2sReceiveStopMode_EnabledInStopMode    = I2S_RCSR_STOPE(1),  ///< Enabled in Stop mode
   };

   /**
    * Debug Enable
    * (i2s_rcsr_dbge)
    *
    * Enables/disables receiver operation in Debug mode. The receive bit clock is not affected by Debug mode
    */
   enum I2sReceiveDebugMode {
      I2sReceiveDebugMode_DisabledInDebugMode   = I2S_RCSR_DBGE(0),  ///< Disabled in Debug mode
      I2sReceiveDebugMode_EnabledInDebugMode    = I2S_RCSR_DBGE(1),  ///< Enabled in Debug mode
   };

   /**
    * Bit Clock Enable
    * (i2s_rcsr_bce)
    *
    * Enables the receive bit clock, separately from RE.
    * This field is automatically set whenever RE is set.
    * When software clears this field, the receive bit clock remains enabled,
    * and this field remains set, until the end of the current frame
    */
   enum I2sReceiveBitClock {
      I2sReceiveBitClock_ClockDisabled   = I2S_RCSR_BCE(0),  ///< Clock disabled
      I2sReceiveBitClock_ClockEnabled    = I2S_RCSR_BCE(1),  ///< Clock enabled
   };

   /**
    * FIFO Reset
    * (i2s_rcsr_fr)
    *
    * Resets the FIFO pointers. Reading this field will always return zero
    */
   enum I2sReceiveFifoReset {
      I2sReceiveFifoReset_NoEffect    = I2S_RCSR_FR(0),  ///< No effect
      I2sReceiveFifoReset_FifoReset   = I2S_RCSR_FR(1),  ///< FIFO reset
   };

   /**
    * Software Reset
    * (i2s_rcsr_sr)
    *
    * Resets the internal receiver logic including the FIFO pointers.
    * Software-visible registers are not affected, except for the status
    */
   enum I2sReceiveReset {
      I2sReceiveReset_NoEffect        = I2S_RCSR_SR(0),  ///< No effect
      I2sReceiveReset_SoftwareReset   = I2S_RCSR_SR(1),  ///< Software reset
   };

   /**
    * Word Start Flag
    * (i2s_rcsr_wsf)
    *
    * Indicates that the start of the configured word has been detected.
    * Write a logic 1 to this field to clear this flag
    */
   enum I2sReceiveWordStartFlag {
      I2sReceiveWordStartFlag_StartNotDetected   = I2S_RCSR_WSF(0),  ///< Start not detected
      I2sReceiveWordStartFlag_StartDetected      = I2S_RCSR_WSF(1),  ///< Start detected
   };

   /**
    * Sync Error Flag
    * (i2s_rcsr_sef)
    *
    * Indicates that an error in the externally-generated frame sync has been detected.
    * Write a logic 1 to this field to clear this flag
    */
   enum I2sReceiveErrorFlag {
      I2sReceiveErrorFlag_SyncErrorNotDetected   = I2S_RCSR_SEF(0),  ///< Sync error not detected
      I2sReceiveErrorFlag_SyncErrorDetected      = I2S_RCSR_SEF(1),  ///< Sync error detected
   };

   /**
    * FIFO Error Flag
Indicates that an enabled receive FIFO has overflowed.
    * (i2s_rcsr_fef)
    *
    * Write a logic 1 to this field to clear this flag
    */
   enum I2sReceiveOverflowFlag {
      I2sReceiveOverflowFlag_OverflowNotDetected   = I2S_RCSR_FEF(0),  ///< Overflow not detected
      I2sReceiveOverflowFlag_OverflowDetected      = I2S_RCSR_FEF(1),  ///< Overflow detected
   };

   /**
    * FIFO Warning Flag
    * (i2s_rcsr_fwf)
    *
    * Indicates that an enabled receive FIFO is full
    */
   enum I2sReceiveFifoFlag {
      I2sReceiveFifoFlag_NoFifoFull    = I2S_RCSR_FWF(0),  ///< No FIFO full
      I2sReceiveFifoFlag_AFifoIsFull   = I2S_RCSR_FWF(1),  ///< A FIFO is full
   };

   /**
    * FIFO Request Flag
    * (i2s_rcsr_frf)
    *
    * Indicates that the number of words in an enabled receive channel FIFO is greater than the receive FIFO 
    * watermark
    */
   enum I2sReceiveRequestFlag {
      I2sReceiveRequestFlag_WatermarkNotReached   = I2S_RCSR_FRF(0),  ///< Watermark not reached
      I2sReceiveRequestFlag_WatermarkReached      = I2S_RCSR_FRF(1),  ///< Watermark reached
   };

   /**
    * Word Start Interrupt Enable
    * (i2s_rcsr_wsie)
    *
    * Determines action on word start interrupts.
    */
   enum I2sReceiveWordStartAction {
      I2sReceiveWordStartAction_None        = I2S_RCSR_WSIE(0),  ///< Interrupts disabled
      I2sReceiveWordStartAction_Interrupt   = I2S_RCSR_WSIE(1),  ///< Interrupts enabled
   };

   /**
    * Sync Error Interrupt Enable
    * (i2s_rcsr_seie)
    *
    * Determines action on sync error
    */
   enum I2sReceiveErrorAction {
      I2sReceiveErrorAction_None        = I2S_RCSR_SEIE(0),  ///< Interrupts disabled
      I2sReceiveErrorAction_Interrupt   = I2S_RCSR_SEIE(1),  ///< Interrupts enabled
   };

   /**
    * FIFO Error Interrupt Enable
    * (i2s_rcsr_feie)
    *
    * Determines action on FIFO errors
    */
   enum I2sReceiveFifoErrorFlag {
      I2sReceiveFifoErrorFlag_None        = I2S_RCSR_FEIE(0),  ///< Interrupts disabled
      I2sReceiveFifoErrorFlag_Interrupt   = I2S_RCSR_FEIE(1),  ///< Interrupts enabled
   };

   /**
    * FIFO Warning Action
    * (i2s_rcsr_warning)
    *
    * Action taken in FIFO warning level
    */
   enum I2sReceiveWarningAction {
      I2sReceiveWarningAction_None                     = I2S_RCSR_FWIE(0)|I2S_RCSR_FWDE(0),  ///< No action
      I2sReceiveWarningAction_Interrupt                = I2S_RCSR_FWIE(1)|I2S_RCSR_FWDE(0),  ///< Interrupt Request
      I2sReceiveWarningAction_DmaRequest               = I2S_RCSR_FWIE(0)|I2S_RCSR_FWDE(1),  ///< Dma Request
      I2sReceiveWarningAction_InterruptAndDmaRequest   = I2S_RCSR_FWIE(1)|I2S_RCSR_FWDE(1),  ///< Interrupt and Dma Request
   };

   /**
    * FIFO Warning Action
    * (i2s_rcsr_request)
    *
    * Action taken in FIFO request level
    */
   enum I2sReceiveRequestAction {
      I2sReceiveRequestAction_None                     = I2S_RCSR_FRIE(0)|I2S_RCSR_FRDE(0),  ///< No action
      I2sReceiveRequestAction_Interrupt                = I2S_RCSR_FRIE(1)|I2S_RCSR_FRDE(0),  ///< Interrupt Request
      I2sReceiveRequestAction_DmaRequest               = I2S_RCSR_FRIE(0)|I2S_RCSR_FRDE(1),  ///< Dma Request
      I2sReceiveRequestAction_InterruptAndDmaRequest   = I2S_RCSR_FRIE(1)|I2S_RCSR_FRDE(1),  ///< Interrupt and Dma Request
   };

   /**
    * Receive FIFO Watermark
    * (i2s_rcr1_rfw)
    *
    * Configures the watermark level for all enabled receiver channels
    */
   enum I2sReceiveFifoWatermark : uint8_t {
   };

   /**
    * Synchronous Mode
    * (i2s_rcr2_sync)
    *
    * Configures between asynchronous and synchronous modes of operation.
    * When configured for a synchronous mode of operation, the transmitter 
    * must be configured for asynchronous operation.
    */
   enum I2sReceiveSynchMode {
      I2sReceiveSynchMode_AsynchronousMode                       = I2S_RCR2_SYNC(0),  ///< Asynchronous mode
      I2sReceiveSynchMode_SynchronousWithTransmitter             = I2S_RCR2_SYNC(1),  ///< Synchronous with transmitter
      I2sReceiveSynchMode_SynchronousWithAnotherSaiReceiver      = I2S_RCR2_SYNC(2),  ///< Synchronous with another SAI receiver
      I2sReceiveSynchMode_SynchronousWithAnotherSaiTransmitter   = I2S_RCR2_SYNC(3),  ///< Synchronous with another SAI transmitter
   };

   /**
    * Bit Clock Swap
    * (i2s_rcr2_bcs)
    *
    * When the SAI is in asynchronous mode and this field is set to 1, 
    * the receiver is clocked by the transmitter bit clock. 
    * When the SAI is in synchronous mode and this field is set to 1, 
    * the receiver is clocked by the receiver bit clock, but it uses the transmitter frame sync.
    */
   enum I2sReceiveBitClockSwap {
      I2sReceiveBitClockSwap_UseTheNormalBitClockSource   = I2S_RCR2_BCS(0),  ///< Use the normal bit clock source
      I2sReceiveBitClockSwap_SwapTheBitClockSource        = I2S_RCR2_BCS(1),  ///< Swap the bit clock source
   };

   /**
    * Bit Clock Input
    * (i2s_rcr2_bci)
    *
    * When set in either asynchronous or synchronous mode and the module is using an internally generated
    * bit clock, configures the internal logic to be clocked as if the bit clock was externally generated.
    * This has the effect of decreasing data input setup time, but increasing data output valid time. 
    * This bit has no effect when configured for an externally generated bit clock.
    */
   enum I2sReceiveBitClockInput {
      I2sReceiveBitClockInput_NoEffect                                                   = I2S_RCR2_BCI(0),  ///< No effect
      I2sReceiveBitClockInput_InternalLogicIsClockedAsIfBitClockWasExternallyGenerated   = I2S_RCR2_BCI(1),  ///< Internal logic is clocked as if bit clock was externally generated
   };

   /**
    * Clocking Mode
    * (i2s_rcr2_msel)
    *
    * When configured for external bit clock, this field configures for asynchronous or synchronous operation.
    * When configured for internal bit clock, this field selects the audio master clock used to generate the internal
    *  bit clock
    */
   enum I2sReceiveClockingMode {
      I2sReceiveClockingMode_BusClockOrAsynchronous   = I2S_RCR2_MSEL(0),  ///< Bus clock (or Asynchronous)
      I2sReceiveClockingMode_MasterClock1             = I2S_RCR2_MSEL(1),  ///< Master clock 1
      I2sReceiveClockingMode_MasterClock2             = I2S_RCR2_MSEL(2),  ///< Master clock 2
      I2sReceiveClockingMode_MasterClock3             = I2S_RCR2_MSEL(3),  ///< Master clock 3
   };

   /**
    * Bit Clock Polarity
    * (i2s_rcr2_bcp)
    *
    * Configures the polarity of the bit clock.
    */
   enum I2sReceiveBitClockPolarity {
      I2sReceiveBitClockPolarity_ActiveHigh   = I2S_RCR2_BCP(0),  ///< Active High
      I2sReceiveBitClockPolarity_ActiveLow    = I2S_RCR2_BCP(1),  ///< Active Low
   };

   /**
    * Bit Clock Direction
    * (i2s_rcr2_bcd)
    *
    * Configures the direction of the bit clock
    */
   enum I2sReceiveBitClockDirection {
      I2sReceiveBitClockDirection_ExternalBitClock   = I2S_RCR2_BCD(0),  ///< External bit clock
      I2sReceiveBitClockDirection_InternalBitClock   = I2S_RCR2_BCD(1),  ///< Internal bit clock
   };

   /**
    * Bit Clock Divide
    * (i2s_rcr2_div)
    *
    * Divides down the audio master clock to generate the bit clock when
    * configured for an internal bit clock.
    * The division value is (DIV + 1) * 2
    */
   enum I2sReceiveBitClockDivider : uint8_t {
   };

   /**
    * Receive Channel Enable
Enables the corresponding data channel for receive operation
    * (i2s_rcr3_rce)
    *
    * Enables a data channel for a receive operation.
    * A channel should be enabled before its FIFO is accessed.
    */
   enum I2sReceiveChannelEnable {
      I2sReceiveChannelEnable_Disabled   = I2S_RCR3_RCE(0),  ///< Disabled
      I2sReceiveChannelEnable_Enabled    = I2S_RCR3_RCE(1),  ///< Enabled
   };

   /**
    * Word Flag Configuration
    * (i2s_rcr3_wdfl)
    *
    * Configures which word the start of word flag is set.
    * The value written should be one less than the word number 
    * (for example, write zero to configure for the first word in the frame)
    */
   enum I2sReceiveWordFlag : uint8_t {
   };

   /**
    * Frame size
    * (i2s_rcr4_frsz)
    *
    * Configures the number of words in each frame.
    * The value written must be one less than the number of words in the frame.
    * For example, write 0 for one word per frame
    */
   enum I2sReceiveFrameSize : uint8_t {
   };

   /**
    * Sync Width
    * (i2s_rcr4_sywd)
    *
    * Configures the length of the frame sync in number of bit clocks.
    * The value written must be one less than the number of bit clocks.
    * or example, write 0 for the frame sync to assert for one bit clock only
    */
   enum I2sReceiveSyncWidth : uint8_t {
   };

   /**
    * MSB First
    * (i2s_rcr4_mf)
    *
    * Configures whether the LSB or the MSB is transmitted/received first
    */
   enum I2sReceiveBitOrder {
      I2sReceiveBitOrder_LsbFirst   = I2S_RCR4_MF(0),  ///< LSB first
      I2sReceiveBitOrder_MsbFirst   = I2S_RCR4_MF(1),  ///< MSB first
   };

   /**
    * Frame Sync Early
    * (i2s_rcr4_fse)
    *
    * Control where frame sync asserts relative to 1st bit of the frame
    */
   enum I2sReceiveFrameSyncEarly {
      I2sReceiveFrameSyncEarly_AssertsWithFirstBit           = I2S_RCR4_FSE(0),  ///< Asserts with first bit
      I2sReceiveFrameSyncEarly_AssertsOneBitBeforeFirstBit   = I2S_RCR4_FSE(1),  ///< Asserts one bit before first bit
   };

   /**
    * Frame Sync Polarity
    * (i2s_rcr4_fsp)
    *
    * Configures the polarity of the frame sync
    */
   enum I2sReceiveFrameSyncPolarity {
      I2sReceiveFrameSyncPolarity_ActiveHigh   = I2S_RCR4_FSP(0),  ///< Active high
      I2sReceiveFrameSyncPolarity_ActiveLow    = I2S_RCR4_FSP(1),  ///< Active low
   };

   /**
    * Frame Sync Direction
    * (i2s_rcr4_fsd)
    *
    * Configures the direction of the frame sync
    */
   enum I2sReceiveI2sReceiveFrameSyncDirection {
      I2sReceiveI2sReceiveFrameSyncDirection_GeneratedExternally   = I2S_RCR4_FSD(0),  ///< Generated externally
      I2sReceiveI2sReceiveFrameSyncDirection_GeneratedInternally   = I2S_RCR4_FSD(1),  ///< Generated internally
   };

   /**
    * Word N Width
    * (i2s_rcr5_wnw)
    *
    * Configures the number of bits in each word, for each word except the first in the frame.
    * The value written must be one less than the number of bits per word.
    * The value of WNW must be greater than or equal to the value of W0W even when there is only one word in each 
    * frame.
    * Word width of less than 8 bits is not supported
    */
   enum I2sReceiveWordNWidth : uint8_t {
   };

   /**
    * Word 0 Width
    * (i2s_rcr5_w0w)
    *
    * Configures the number of bits in the first word in each frame.
    * The value written must be one less than the number of bits in the first word.
    * Word width of less than 8 bits is not supported if there is only one word per frame
    */
   enum I2sReceiveWord0Width : uint8_t {
   };

   /**
    * First Bit Shifted
    * (i2s_rcr5_fbt)
    *
    * Configures the bit index for the first bit transmitted for each word in the frame.
    * If configured for MSB First, the index of the next bit transmitted is one less than the current bit 
    * transmitted.
    * If configured for LSB First, the index of the next bit transmitted is one more than the current bit transmitted
    */
   enum I2sReceiveFirstBitShifted : uint8_t {
   };

   /**
    * Receiver FIFO Write Pointer
    * (i2s_rfr_wfp)
    *
    * FIFO write pointer for receive data channel
    */
   enum I2sReceiveFifoWritePointer : uint8_t {
   };

   /**
    * Receiver FIFO Read Pointer
    * (i2s_rfr_rfp)
    *
    * FIFO read pointer for receive data channel
    */
   enum I2sReceiveFifoReadPointer : uint8_t {
   };

   /**
    * Receive Word Mask
    * (i2s_rmr_rwm)
    *
    * Configures whether the receive word is masked (received data ignored and
    * not written to receive FIFO) for the corresponding word in the frame
    */
   enum I2sReceiveWordMask {
      I2sReceiveWordMask_WordNIsEnabled   = I2S_RMR_RWM(0),  ///< Word N is enabled
      I2sReceiveWordMask_WordNIsMasked    = I2S_RMR_RWM(1),  ///< Word N is masked
   };

   /**
    * Divider Update Flag
    * (i2s_mcr_duf)
    *
    * Provides the status of on-the-fly updates to the MCLK divider ratio
    * Updates to the MCLK divider ratio are blocked while this flag remains set
    */
   enum I2sDriverUpdateFlag {
      I2sDriverUpdateFlag_RatioNotUpdating          = I2S_MCR_DUF(0),  ///< Ratio not updating
      I2sDriverUpdateFlag_RatioIsUpdatingOnTheFly   = I2S_MCR_DUF(1),  ///< Ratio is updating on-the-fly
   };

   /**
    * MCLK Output Enable
    * (i2s_mcr_moe)
    *
    * Enables the MCLK divider and configures the MCLK signal pin as an output.
    * When software clears this field, it remains set until the MCLK divider is fully disabled
    */
   enum I2sMasterClockEnable {
      I2sMasterClockEnable_PinIsInputBypassingTheMclkDivider   = I2S_MCR_MOE(0),  ///< Pin is input bypassing the MCLK Divider
      I2sMasterClockEnable_PinIsOutputFromTheMclkDivider       = I2S_MCR_MOE(1),  ///< Pin is output from the MCLK Divider
   };

   /**
    * Master Clock Input Clock Select
    * (i2s_mcr_mics)
    *
    * Selects the clock input to the MCLK divider
    */
   enum I2sMasterClockInput {
      I2sMasterClockInput_InputClock0   = I2S_MCR_MICS(0),  ///< Input clock 0
      I2sMasterClockInput_InputClock1   = I2S_MCR_MICS(1),  ///< Input clock 1
      I2sMasterClockInput_InputClock2   = I2S_MCR_MICS(2),  ///< Input clock 2
      I2sMasterClockInput_InputClock3   = I2S_MCR_MICS(3),  ///< Input clock 3
   };

   /**
    * Master Clock Fraction
    * (i2s_mdr_fract)
    *
    * Sets the MCLK divide ratio such that: 
    * MCLK output = MCLK input * ( (FRACT + 1) / (DIVIDE + 1) ).
    * FRACT must be set equal or less than the value in the DIVIDE field.
    */
   enum I2sMasterClockFraction : uint8_t {
   };

   /**
    * Master Clock Divider
    * (i2s_mdr_divide)
    *
    * Sets the MCLK divide ratio such that:
    * MCLK output = MCLK input * ( (FRACT + 1) / (DIVIDE + 1) ).
    * FRACT must be set equal or less than the value in the DIVIDE field.
    */
   enum I2sMasterClockDivider : uint8_t {
   };

class I2sBasicInfo {

public:

}; // class I2sBasicInfo 

class I2s0Info : public I2sBasicInfo {

public:

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PinInfo  info[] = {

         //      Signal                 Pin                                  PinIndex                PCR value
         /*   0: I2S0_MCLK            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   1: I2S0_RX_BCLK         = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   2: I2S0_RX_FS           = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   3: I2S0_TX_BCLK         = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   4: I2S0_TX_FS           = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   5: I2S0_TXD0            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
         /*   6: --                   = --                             */  { PinIndex::INVALID_PCR,  PcrValue(0)         },
         /*   7: I2S0_RXD0            = --                             */  { PinIndex::UNMAPPED_PCR, PcrValue(0)         },
   };

   /**
    * Initialise pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void initPCRs() {
   }

   /**
    * Release pins used by peripheral
    *
    * @note Only the lower 16-bits of the PCR registers are affected
    */
   static void clearPCRs() {
   }

   /*
    * Template:i2s0_1ch
    */
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = false;


   
   /**
    * Configures all mapped pins associated with I2S0
    *
    * @note Locked pins will be unaffected
    */
   static void configureAllPins() {
   
      // Configure pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         initPCRs();
      }
   }
   
   /**
    * Disabled all mapped pins associated with I2S0
    *
    * @note Only the lower 16-bits of the PCR registers are modified
    *
    * @note Locked pins will be unaffected
    */
   static void disableAllPins() {
   
      // Disable pins if selected and not already locked
      if constexpr (mapPinsOnEnable) {
         clearPCRs();
      }
   }
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = I2S0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * IRQ entry
    * (irq_enum)
    *
    * Select amongst interrupts associated with the peripheral
    */
   enum IrqNum {
      IrqNum_Tx   = 0,  ///< Maps to I2S0_Tx_IRQn
      IrqNum_Rx   = 1,  ///< Maps to I2S0_Rx_IRQn
   };

   /**
    * Enable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum) {
      NVIC_EnableIRQ(irqNums[irqNum]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void enableNvicInterrupts(IrqNum irqNum, NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[irqNum], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    * @param irqNum Select amongst interrupts associated with the peripheral
    */
   static void disableNvicInterrupts(IrqNum irqNum) {
      NVIC_DisableIRQ(irqNums[irqNum]);
   }
   
   /**
    *  Enable clock to I2s0
    */
   static void enableClock() {
      SIM->SCGC6 = SIM->SCGC6 | SIM_SCGC6_I2S0_MASK;
   }
   
   /**
    *  Disable clock to I2s0
    */
   static void disableClock() {
      SIM->SCGC6 = SIM->SCGC6 & ~SIM_SCGC6_I2S0_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = I2S0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<I2S_Type> i2s = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   /**
    * Write Transmit Data Register
    *
    * @param i2sChannelNum Selects transmit or receive channel
    * @param value         Data to transmit
    */
   static void writeData(
         I2sChannelNum i2sChannelNum,
         uint32_t      value) {
      i2s->TDR[i2sChannelNum] = value;
   }
   
   /**
    * Read Receive Data Register
    *
    * @param i2sChannelNum Selects transmit or receive channel
    */
   static uint32_t readData(I2sChannelNum i2sChannelNum) {
      return uint32_t(i2s->RDR[i2sChannelNum]);
   }
   
}; // class I2s0Info



/**
 * Virtual Base class for I2S interface
 */
class I2s {

protected:
   const HardwarePtr<I2S_Type> i2s;                 //!< I2S hardware instance

   /**
    * Construct I2S interface
    *
    * @param[in]  i2s     Base address of I2S hardware
    */
   I2s(uint32_t i2s) : i2s(i2s) {
   }

   /**
    * Destructor
    */
   ~I2s() {}

public:
};

/**
 * @brief Template class representing an I2S interface
 *
 * <b>Example</b>
 *
 * @code
 *  @endcode
 *
 * @tparam Info            Class describing I2S hardware
 */
template<class Info> class I2sBase_T : public I2s, public Info {

public:
   // Handle on I2S hardware
   static constexpr volatile I2S_Type *I2S = Info::i2s;

   // I2S SCL (clock) Pin
   using sclGpio = GpioTable_T<Info, 0, USBDM::ActiveLow>; // Inactive is high

   // I2S SDA (data) Pin
   using sdaGpio = GpioTable_T<Info, 1, USBDM::ActiveHigh>;

   /** Used by ISR to obtain handle of object */
   static I2S_Type *thisPtr;

public:
   // No class Info found

   /**
    * Construct I2S interface
    *
    * @param[in]  bps        Tx/Rx rate
    * @param[in]  myAddress  Address of this device on bus (not currently used)
    */
   I2sBase_T(unsigned bps=400000, uint8_t myAddress=0) : I2s(Info::baseAddress) {
   (void)bps; (void)myAddress;

#ifdef DEBUG_BUILD
      // Check pin assignments
//      static_assert(Info::info[0].gpioBit != UNMAPPED_PCR, "I2Sx_SCL has not been assigned to a pin - Modify Configure.usbdm");
//      static_assert(Info::info[1].gpioBit != UNMAPPED_PCR, "I2Sx_SDA has not been assigned to a pin - Modify Configure.usbdm");
#endif

   }

   /**
    * Destructor
    */
   virtual ~I2sBase_T() {}

// No declarations found
};

/** Used by ISR to obtain handle of object */
template<class Info> I2S_Type *I2sBase_T<Info>::thisPtr = 0;


/**
 * End I2S_Group
 * @}
 */

} // End namespace USBDM

#endif // /I2S/_BasicInfoGuard

#endif /* HEADER_I2S_H */
