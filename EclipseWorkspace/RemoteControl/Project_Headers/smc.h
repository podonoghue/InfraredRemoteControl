/**
 * @file     smc.h (180.ARM_Peripherals/Project_Headers/smc.h)
 * @brief    System Management Controller
 */

#ifndef HEADER_SMC_H
#define HEADER_SMC_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "string.h"
#include "mcg.h"
#include "pin_mapping.h"
#include "fmc.h"


// $/SMC/prototypes not found

namespace USBDM {

/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */
/**
 * Peripheral information for SMC, System Mode Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Allow Very Low Power modes
    * (smc_pmprot_avlp)
    *
    * Allows the MCU to enter any very low power modes: VLPR, VLPW, and VLPS
    */
   enum SmcAllowVeryLowPower : uint8_t {
      SmcAllowVeryLowPower_Disabled   = SMC_PMPROT_AVLP(0),  ///< VLPR, VLPW and VLPS are not allowed
      SmcAllowVeryLowPower_Enabled    = SMC_PMPROT_AVLP(1),  ///< VLPR, VLPW and VLPS are allowed
   };

   /**
    * Allow Low Leakage Stop mode
    * (smc_pmprot_alls)
    *
    * Allows the MCU to enter any low leakage stop mode: LLS
    */
   enum SmcAllowLowLeakageStop : uint8_t {
      SmcAllowLowLeakageStop_Disabled   = SMC_PMPROT_ALLS(0),  ///< LLS is not allowed
      SmcAllowLowLeakageStop_Enabled    = SMC_PMPROT_ALLS(1),  ///< LLS is allowed
   };

   /**
    * Allow Very Low Leakage Stop mode
    * (smc_pmprot_avlls)
    *
    * Allows the MCU to enter any low leakage stop mode: VLLSx
    */
   enum SmcAllowVeryLowLeakageStop : uint8_t {
      SmcAllowVeryLowLeakageStop_Disabled   = SMC_PMPROT_AVLLS(0),  ///< VLLSx is not allowed
      SmcAllowVeryLowLeakageStop_Enabled    = SMC_PMPROT_AVLLS(1),  ///< VLLSx is allowed
   };

   /**
    * Run mode
    * (smc_pmctrl_runm[0])
    *
    * Determines the clock speed restrictions that apply
    */
   enum SmcRunMode : uint8_t {
      SmcRunMode_Normal         = SMC_PMCTRL_RUNM(0),  ///< Normal RUN
      SmcRunMode_VeryLowPower   = SMC_PMCTRL_RUNM(2),  ///< Very Low Power RUN
   };

   /**
    * Exit low power on interrupt
    * (smc_pmctrl_lpwui)
    *
    * Causes the SMC to exit to normal RUN mode when any active interrupt
    * occurs while in a VLP mode (VLPR, VLPW or VLPS)
    */
   enum SmcExitLowPowerOnInt : uint8_t {
      SmcExitLowPowerOnInt_Disabled   = SMC_PMCTRL_LPWUI(0),  ///< Stay in VLPR on int
      SmcExitLowPowerOnInt_Enabled    = SMC_PMCTRL_LPWUI(1),  ///< Exit VLPR on int
   };

   /**
    * Stop Aborted
    * (smc_pmctrl_stopa)
    *
    * This read-only status bit indicates an interrupt occured during the previous stop mode entry 
    * sequence, preventing the system from entering that mode. 
    * This field is cleared by reset or by hardware at the beginning of any stop mode
    * entry sequence and is set if the sequence was aborted.
    */
   enum SmcStopOutcome {
      SmcStopOutcome_Successful   = SMC_PMCTRL_STOPA(0),  ///< Entry Successful
      SmcStopOutcome_Aborted      = SMC_PMCTRL_STOPA(1),  ///< Entry Aborted
   };

   /**
    * Stop Mode Control
    * (smc_pmctrl_stopm)
    *
    * Controls entry into the selected stop mode when Sleep-Now or Sleep-On-Exit 
    * mode is entered with SLEEPDEEP=1
    * This field is cleared by hardware on any successful write to the PMPROT register
    */
   enum SmcStopMode : uint8_t {
      SmcStopMode_NormalStop           = SMC_PMCTRL_STOPM(0),  ///< Normal Stop (STOP)
      SmcStopMode_VeryLowPowerStop     = SMC_PMCTRL_STOPM(2),  ///< Very-Low-Power Stop (VLPS)
      SmcStopMode_LowLeakageStop       = SMC_PMCTRL_STOPM(3),  ///< Low-Leakage Stop (LLSx)
      SmcStopMode_VeryLowLeakageStop   = SMC_PMCTRL_STOPM(4),  ///< Very-Low-Leakage Stop (VLLSx)
   };

   /**
    * Power-On_Reset Detection in VLLS0 mode
    * (smc_stopctrl_porpo)
    *
    * Controls whether the Power-On-Reset detect circuit is enabled in VLLS0 mode (Brown-out detection)
    */
   enum SmcPowerOnResetInVlls0 : uint8_t {
      SmcPowerOnResetInVlls0_Enabled    = SMC_STOPCTRL_PORPO(0),  ///< POR detect circuit is enabled in VLLS0
      SmcPowerOnResetInVlls0_Disabled   = SMC_STOPCTRL_PORPO(1),  ///< POR detect circuit is disabled in VLLS0
   };

   /**
    * Low Leakage Mode Control
    * (smc_stopctrl_vllsm)
    *
    * Controls which VLLS sub-mode to enter if STOPM = VLLSx
    */
   enum SmcLowLeakageStopMode : uint8_t {
      SmcLowLeakageStopMode_VLLS0   = SMC_STOPCTRL_VLLSM(0),  ///< Enter VLLS0 in VLLSx mode
      SmcLowLeakageStopMode_VLLS1   = SMC_STOPCTRL_VLLSM(1),  ///< Enter VLLS1 in VLLSx mode
      SmcLowLeakageStopMode_VLLS2   = SMC_STOPCTRL_VLLSM(2),  ///< Enter VLLS2 in VLLSx mode
      SmcLowLeakageStopMode_VLLS3   = SMC_STOPCTRL_VLLSM(3),  ///< Enter VLLS3 in VLLSx mode
   };

   /**
    * Power Mode Status
    * (smc_pmstat_pmstat)
    *
    * Shows the execution state of the processor
    */
   enum SmcStatus : uint8_t {
      SmcStatus_RUN    = SMC_PMSTAT_PMSTAT(1<<0),  ///< Processor is in Normal Run mode
      SmcStatus_VLPR   = SMC_PMSTAT_PMSTAT(1<<2),  ///< Processor is in Very Low Power Run mode
      SmcStatus_VLPW   = SMC_PMSTAT_PMSTAT(1<<3),  ///< Processor is in Very Low Power Wait mode
      SmcStatus_STOP   = SMC_PMSTAT_PMSTAT(1<<1),  ///< Processor is in Stop mode
      SmcStatus_VLPS   = SMC_PMSTAT_PMSTAT(1<<4),  ///< Processor is in Very Low Power Stop mode
      SmcStatus_LLS    = SMC_PMSTAT_PMSTAT(1<<5),  ///< Processor is in Low Leakage Stop mode
      SmcStatus_VLLS   = SMC_PMSTAT_PMSTAT(1<<6),  ///< Processor is in Very Low Leakage Stop mode
   };

   consteval uint32_t make16(uint8_t pmctrl, uint8_t stopctrl=0, uint8_t bias=0) {
      return pmctrl+(stopctrl<<8)+(bias<<16);
   }

   enum SmcPowerMode {
      /*                           value                                                                                    Entry             Trans  Core       Requirements                                           */ //
      SmcPowerMode_RUN           = make16(SmcRunMode_Normal),                                                            /* (VLPR,HSRUN)->RUN 3,12   Run        SMC_PMCTRL_RUNM(0)                                     */ ///<  Run mode
      SmcPowerMode_VLPR          = make16(SmcRunMode_VeryLowPower),                                                      /* RUN->VLPR         3      Run        SMC_PMCTRL_RUNM(2)                                     */ ///<  Very low power run mode     
   
      SmcPowerMode_WAIT          = make16(SmcRunMode_Normal,0,1),                                                        /* RUN->WAIT         1      Sleep      wfi+SMC_PMCTRL_RUNM(0)                                 */ ///<  Wait mode
      SmcPowerMode_VLPW          = make16(SmcRunMode_VeryLowPower,0,1),                                                  /* VLPR->VLPW        4      Sleep      wfi+SMC_PMCTRL_RUNM(2)                                 */ ///<  Very low power wait mode
   
      SmcPowerMode_NormalSTOP    = make16(SmcRunMode_Normal|SmcStopMode_NormalStop,0,2),                                 /* RUN->STOP         2a     Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0) RUN<->STOP           */ ///<  Stop mode                   
   
      SmcPowerMode_VLPS          = make16(SmcRunMode_Normal|SmcStopMode_VeryLowPowerStop),                               /* (RUN,VLPR)->VLPS  7,6    Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(2)                      */ ///<  Very low power stop mode
      /*                               or if SmcRunMode_VeryLowPower,                                                       VLPR->VLPS        6      Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0/2)                    */ ///<  Very low power stop mode    
   
      SmcPowerMode_VLLS0         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS0), /* (RUN,VLPR)->VLLS0 8,9a   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(0) */ ///<  Very low leakage stop mode 0
      SmcPowerMode_VLLS1         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS1), /* (RUN,VLPR)->VLLS1 8,9b   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(1) */ ///<  Very low leakage stop mode 1
      SmcPowerMode_VLLS2         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS2), /* (RUN,VLPR)->VLLS2 8,9c   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(2) */ ///<  Very low leakage stop mode 2
      SmcPowerMode_VLLS3         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS3), /* (RUN,VLPR)->VLLS3 8,9d   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(3) */ ///<  Very low leakage stop mode 3 
   };

class SmcInfo {

public:
   /*
    * Template:smc_mk10d5
    */
   /**
    * Basic enable of Smc
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
   }
   
   /**
    * Disables Smc
    */
   static void disable() {
   
      
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SMC_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<SMC_Type> smc = baseAddress;
   
   /**
    * Enable all power modes.
    * A power mode must be enabled before it can be entered.
    * (smc_pmprot_avlp,smc_pmprot_alls,smc_pmprot_avlls)
    *
    * @note This is a write-once-after-reset operation
    */
   static ErrorCode enableAllPowerModes() {
   
      smc->PMPROT = 0xFF;
      return E_NO_ERROR;
   }

   /**
    * Enable the given power modes
    * A mode must be enabled before it can be entered.
   
    * @note This is a write-once operation after reset
    *
    * @param smcAllowVeryLowPower       Allows the MCU to enter any very low power modes: VLPR, VLPW, and VLPS
    * @param smcAllowLowLeakageStop     Allows the MCU to enter any low leakage stop mode: LLS
    * @param smcAllowVeryLowLeakageStop Allows the MCU to enter any low leakage stop mode: VLLSx
    */
   static void enablePowerModes(
         SmcAllowVeryLowPower       smcAllowVeryLowPower,
         SmcAllowLowLeakageStop     smcAllowLowLeakageStop     = SmcAllowLowLeakageStop_Enabled,
         SmcAllowVeryLowLeakageStop smcAllowVeryLowLeakageStop = SmcAllowVeryLowLeakageStop_Enabled) {
   
      smc->PMPROT = smcAllowVeryLowPower|smcAllowLowLeakageStop|smcAllowVeryLowLeakageStop;
   }

   /**
    * Set Exit low power on interrupt
    * (smc_pmctrl_lpwui)
    *
    * @param smcExitLowPowerOnInt Causes the SMC to exit to normal RUN mode when any active interrupt
    *        occurs while in a VLP mode (VLPR, VLPW or VLPS)
    *
    * @return E_NO_ERROR                 Success
    * @return E_ILLEGAL_POWER_TRANSITION If not in RUN mode
    */
   static ErrorCode setExitVeryLowPowerOnInterrupt(SmcExitLowPowerOnInt smcExitLowPowerOnInt) {
      if (getStatus() != SmcStatus_RUN) {
         // Can only change in RUN mode
         return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
      }
   
      smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_LPWUI_MASK) | smcExitLowPowerOnInt;
   
      // Make sure write completes
      (void)smc->PMCTRL;
      return E_NO_ERROR;
   }

   /**
    * Set Power-On_Reset Detection in VLLS0 mode
    * (smc_stopctrl_porpo)
    *
    * @param smcPowerOnResetInVlls0 Controls whether the Power-On-Reset detect circuit is enabled in VLLS0 mode (Brown-out detection)
    */
   static void setPowerOnResetInVLLS0(SmcPowerOnResetInVlls0 smcPowerOnResetInVlls0) {
      smc->STOPCTRL = (smc->STOPCTRL&~SMC_STOPCTRL_PORPO_MASK) | smcPowerOnResetInVlls0;
   }

   /**
    * Set Low Leakage Mode Control
    * (smc_stopctrl_vllsm)
    *
    * @param smcLowLeakageStopMode Controls which VLLS sub-mode to enter if STOPM = VLLSx
    */
   static void setLowLeakageStopMode(SmcLowLeakageStopMode smcLowLeakageStopMode) {
      smc->STOPCTRL = (smc->STOPCTRL&~SMC_STOPCTRL_VLLSM_MASK) | smcLowLeakageStopMode;
   }

   /**
    * Allows the detailed operation in STOP mode to be controlled.
    * (smc_stopctrl_vllsm,smc_stopctrl_porpo)
    *
    * @param smcLowLeakageStopMode  Controls which VLLS sub-mode to enter if STOPM = VLLSx
    * @param smcPowerOnResetInVlls0 Controls whether the Power-On-Reset detect circuit is enabled in VLLS0 mode (Brown-out detection)
    */
   static void setStopOptions(
         SmcLowLeakageStopMode  smcLowLeakageStopMode,
         SmcPowerOnResetInVlls0 smcPowerOnResetInVlls0 = SmcPowerOnResetInVlls0_Enabled) {

      smc->STOPCTRL = smcLowLeakageStopMode|smcPowerOnResetInVlls0;
   }

   /**
    * Set Stop Mode Control
    * (smc_pmctrl_stopm)
    *
    * @param smcStopMode Controls entry into the selected stop mode when Sleep-Now or Sleep-On-Exit 
    *        mode is entered with SLEEPDEEP=1
    *        This field is cleared by hardware on any successful write to the PMPROT register
    */
   static void setStopMode(SmcStopMode smcStopMode) {
      smc->PMCTRL = (smc->PMCTRL&~SMC_PMCTRL_STOPM_MASK) | smcStopMode;
      // Make sure write has completed
      (void)(smc->PMCTRL);
   }
   
   /**
    * Get Stop Mode Control
    * (smc_pmctrl_stopm)
    *
    * @return Controls entry into the selected stop mode when Sleep-Now or Sleep-On-Exit 
    *        mode is entered with SLEEPDEEP=1
    *        This field is cleared by hardware on any successful write to the PMPROT register
    */
   static SmcStopMode getStopMode() {
      return SmcStopMode(smc->PMCTRL&SMC_PMCTRL_STOPM_MASK);
   }
   
   /**
    * Get Power Mode Status
    * (smc_pmstat_pmstat)
    *
    * @return Shows the execution state of the processor
    */
   static SmcStatus getStatus() {
      return SmcStatus(smc->PMSTAT&SMC_PMSTAT_PMSTAT_MASK);
   }
   
   /**
    * Class used to do initialisation of the Smc
    *
    * This class has a templated constructor that accepts various values.
    * Parameters available may vary with device - see Smc::DefaultInitValue for relevant example.
    * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * // Parameters may be in any order
    * // Omitted values are taken to be zero unless a default value is given
    * // Options available vary with target - See SmcInfo::DefaultInitValue for specific example
    * static const Smc::Init smcInit{
    *    // Allow all power modes
    *    SmcAllowVeryLowPower_Enabled, SmcAllowLowLeakageStop_Enabled, SmcAllowVeryLowLeakageStop_Enabled,
    *    // Partial Stop mode to use
    *    SmcPartialStopMode_Partial2,
    *    // (Very) Low leakage stop mode to use
    *    SmcLowLeakageStopMode_LLS3,
    *    // Allow brown-out detection in VLLS0
    *    SmcPowerOnResetInVlls0_Enabled,
    *    // Power RAM2 in in LLS2/VLLS2 mode
    *    SmcLowLeakageRam2_Enabled,
    *    // Stop mode to enter on Deep-sleep
    *    SmcStopMode_NormalStop
    *    // Optional value to build upon - must be last in parameter list
    *    // The value below is generated from Configure.usbdmProject
    *    Smc::DefaultInitValue,
    * };
    *
    * // This version initialises all registers including write-once
    * // Use for initial setup
    * smcInit.initialise();
    *
    * // This version initialises all registers apart from write-once
    * // It may be used to change settings later
    * smcInit.setOptions();
    *
    * The value can also be used with enterStopMode()
    * Smc::enterStopMode(smcInit);
    * @endcode
    *
    * Example2: Inline example
    * @code
    * Smc::Init{
    *    // Stop mode to enter on Deep-sleep
    *    SmcStopMode_NormalStop,
    *    // The value below is generated from Configure.usbdmProject
    *    Smc::DefaultInitValue}.setOptions();
    * @endcode
    */
   class Init {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr Init(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
   public:
      /**
       * Configure STOP mode options as specified in the constructor.
       * This does not include write-once registers.
       */
      inline void setOptions() const {
         smc->STOPCTRL  = stopctrl;
         smc->PMCTRL    = (smc->PMCTRL & ~(SMC_PMCTRL_STOPM_MASK))|pmctrl;
      }
   
      /**
       * Configure all STOP mode options as specified in the constructor.
       * This includes write-once registers
       */
      inline void initialise() const {
         smc->PMPROT    = pmprot;
         setOptions();
      }
   
      /**
       * Read the current STOP mode options from hardware registers
       */
      void readConfig() {
         pmprot   = smc->PMPROT;
         stopctrl = smc->STOPCTRL;
         pmctrl   = smc->PMCTRL & SMC_PMCTRL_STOPM_MASK;
      }
   
      /// Power Mode Protection Register
      uint8_t pmprot = 0;

      /// Power Mode Control Register
      uint8_t pmctrl = 0;

      /// Stop Control Register
      uint8_t stopctrl = 0;

      /**
       * Constructor for Allow Very Low Power modes
       * (smc_pmprot_avlp)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcAllowVeryLowPower Allows the MCU to enter any very low power modes: VLPR, VLPW, and VLPS
       */
      template <typename... Types>
      constexpr Init(SmcAllowVeryLowPower smcAllowVeryLowPower, Types... rest) : Init(rest...) {
   
         pmprot = (pmprot&~SMC_PMPROT_AVLP_MASK) | smcAllowVeryLowPower;
      }
   
      /**
       * Constructor for Allow Low Leakage Stop mode
       * (smc_pmprot_alls)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcAllowLowLeakageStop Allows the MCU to enter any low leakage stop mode: LLS
       */
      template <typename... Types>
      constexpr Init(SmcAllowLowLeakageStop smcAllowLowLeakageStop, Types... rest) : Init(rest...) {
   
         pmprot = (pmprot&~SMC_PMPROT_ALLS_MASK) | smcAllowLowLeakageStop;
      }
   
      /**
       * Constructor for Allow Very Low Leakage Stop mode
       * (smc_pmprot_avlls)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcAllowVeryLowLeakageStop Allows the MCU to enter any low leakage stop mode: VLLSx
       */
      template <typename... Types>
      constexpr Init(SmcAllowVeryLowLeakageStop smcAllowVeryLowLeakageStop, Types... rest) : Init(rest...) {
   
         pmprot = (pmprot&~SMC_PMPROT_AVLLS_MASK) | smcAllowVeryLowLeakageStop;
      }
   
      /**
       * Constructor for Stop Mode Control
       * (smc_pmctrl_stopm)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcStopMode Controls entry into the selected stop mode when Sleep-Now or Sleep-On-Exit 
       *        mode is entered with SLEEPDEEP=1
       *        This field is cleared by hardware on any successful write to the PMPROT register
       */
      template <typename... Types>
      constexpr Init(SmcStopMode smcStopMode, Types... rest) : Init(rest...) {
   
         pmctrl = (pmctrl&~SMC_PMCTRL_STOPM_MASK) | smcStopMode;
      }
   
      /**
       * Constructor for Exit low power on interrupt
       * (smc_pmctrl_lpwui)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcExitLowPowerOnInt Causes the SMC to exit to normal RUN mode when any active interrupt
       *        occurs while in a VLP mode (VLPR, VLPW or VLPS)
       */
      template <typename... Types>
      constexpr Init(SmcExitLowPowerOnInt smcExitLowPowerOnInt, Types... rest) : Init(rest...) {
   
         pmctrl = (pmctrl&~SMC_PMCTRL_LPWUI_MASK) | smcExitLowPowerOnInt;
      }
   
      /**
       * Constructor for Power-On_Reset Detection in VLLS0 mode
       * (smc_stopctrl_porpo)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcPowerOnResetInVlls0 Controls whether the Power-On-Reset detect circuit is enabled in VLLS0 mode (Brown-out detection)
       */
      template <typename... Types>
      constexpr Init(SmcPowerOnResetInVlls0 smcPowerOnResetInVlls0, Types... rest) : Init(rest...) {
   
         stopctrl = (stopctrl&~SMC_STOPCTRL_PORPO_MASK) | smcPowerOnResetInVlls0;
      }
   
      /**
       * Constructor for Low Leakage Mode Control
       * (smc_stopctrl_vllsm)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param smcLowLeakageStopMode Controls which VLLS sub-mode to enter if STOPM = VLLSx
       */
      template <typename... Types>
      constexpr Init(SmcLowLeakageStopMode smcLowLeakageStopMode, Types... rest) : Init(rest...) {
   
         stopctrl = (stopctrl&~SMC_STOPCTRL_VLLSM_MASK) | smcLowLeakageStopMode;
      }
   
   }; // class Smc/Init
   
}; // class SmcInfo



#if true // /SMC/_BasicInfoGuard
/**
 *  Sleep on exit from Interrupt Service Routine (ISR)\n
 *  This option controls whether the processor re-enters sleep mode when exiting the\n
 *  handler for the interrupt that awakened it.
 */
enum SmcSleepOnExit {
   SmcSleepOnExit_Disabled = 0,                       //!< Processor does not re-enter SLEEP/DEEPSLEEP mode on completion of interrupt.
   SmcSleepOnExit_Enabled  = SCB_SCR_SLEEPONEXIT_Msk, //!< Processor re-enters SLEEP/DEEPSLEEP mode on completion of interrupt.
};

/**
 * @brief Template class representing the System Mode Controller (SMC)
 *
 * Partially based on Freescale Application note AN4503\n
 * Support for Kinetis Low Power operation.
 *
 * @image html KinetisPowerModes.png
 */
class SmcBase : public SmcInfo {

protected:
	   /** Hardware instance pointer */
	   static constexpr HardwarePtr<SMC_Type> smc = baseAddress;

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the currently configured STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.\n
    * The stop mode to enter may be set by setStopMode().
    * Other options that affect stop mode may be set by setStopOptions().
    *
    * @note This function is loaded in RAM as stop may power down flash
    */
__attribute__((section(".ram_functions")))
__attribute__((long_call))
__attribute__((noinline))
   static void _enterStopMode() {
      // Set deep sleep
      SCB->SCR = SCB->SCR | SCB_SCR_SLEEPDEEP_Msk;
      (void)SCB->SCR;
      __DSB();
      __WFI();
      __ISB();
   }

public:

   /**
    * Get name from SMC status e.g. RUN, VLPR, HSRUN
    *
    * @param status
    *
    * @return Pointer to static string
    */
   static const char *getSmcStatusName(SmcStatus status) {
#ifdef SMC_PMPROT_AHSRUN
      if (status == SmcStatus_HSRUN) {
         return "HSRUN";
      }
#endif
      if (status == SmcStatus_RUN) {
         return "RUN";
      }
      if (status == SmcStatus_VLPR) {
         return "VLPR";
      }
      return "Impossible while running!";
   }

   /**
    * Get name for current SMC status  e.g. RUN, VLPR, HSRUN
    *
    * @return Pointer to static string
    */
   static const char *getSmcStatusName() {
      return getSmcStatusName(getStatus());
   }

   /**
    * Basic enable of SMC\n
    * Includes configuring all pins
    */
   static __attribute__((always_inline)) void enable() {
      // No clock or pins
   }

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the given STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.
    *
    * @param[in] smcStopMode Stop mode to set.  This will become the default STOP mode.
    *
    * @return E_NO_ERROR    Processor entered STOP
    * @return E_INTERRUPTED Processor failed to enter STOP mode due to interrupt
    */
   static ErrorCode enterStopMode(SmcStopMode smcStopMode) {
      setStopMode(smcStopMode);

      return enterStopMode();
   }

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)  with the current STOP settings
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the given STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.
    *
    *
    * @return E_NO_ERROR    Processor entered STOP
    * @return E_INTERRUPTED Processor failed to enter STOP mode due to interrupt
    */
   static ErrorCode enterStopMode() {
      /*
       * Actions required before entry to STOP modes
       */
      // Save current Flash Bank0 settings
      FmcInfo::FlashBank0Init savedFlashBank0Settings;
      savedFlashBank0Settings.readConfig();
      // Disable Flash Bank0 prefetch
      FmcInfo::setFlashBank0Speculation(FmcFlashSpeculation_Disabled);

      _enterStopMode();
      /*
       * Actions required after exit from STOP modes
       */
      // Restore flash Bank0 settings
      savedFlashBank0Settings.configure();

      return (smc->PMCTRL & SMC_PMCTRL_STOPA_MASK)?E_INTERRUPTED:E_NO_ERROR;
   }

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)  with given STOP settings
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the given STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.
    *
    * @param smcInit    Settings to apply before entering STOP mode
    *
    * @return E_NO_ERROR    Processor entered STOP
    * @return E_INTERRUPTED Processor failed to enter STOP mode due to interrupt
    */
   static ErrorCode enterStopMode(Init smcInit) {
      smcInit.setOptions();
      return enterStopMode();
   }

   /**
    * Enter Wait Mode (WAIT, VLPW)\n
    * (ARM core SLEEP mode)
    *
    * The processor will stop execution and enter WAIT/VLPW mode.\n
    * This function can be used to enter normal WAIT mode or VLPW mode
    * depending upon current run mode.\n
    * In wait mode the core clock is disabled (no code executing),
    * but bus clocks are enabled (peripheral modules are operational).
    *
    * Possible power mode transitions:
    * - RUN  -> WAIT
    * - VLPR -> VLPW
    *
    * WAIT mode is exited using any enabled interrupt or RESET.
    *
    * For Kinetis K:
    * If in VLPW mode, the statue of the SMC_PMCTRL[LPWUI] bit
    * determines if the processor exits to VLPR or RUN mode.\n
    * Use setExitVeryLowPowerOnInterrupt() to modify this action.
    *
    * For Kinetis L:
    * LPWUI does not exist.\n
    * Exits with an interrupt from VLPW will always be back to VLPR.\n
    * Exits from an interrupt from WAIT will always be back to RUN.
    *
    * @note Some modules include a programmable option to disable them in wait mode.\n
    * If those modules are programmed to disable in wait mode, they will not be able to
    * generate interrupts to wake the core.
    */
   static void enterWaitMode() {
      SCB->SCR = SCB->SCR & ~SCB_SCR_SLEEPDEEP_Msk;
      // Make sure write completes
      (void)(SCB->SCR);
      __asm volatile( "dsb" ::: "memory" );
      __asm volatile( "wfi" );
      __asm volatile( "isb" );
   }

   /**
    * Set Sleep-on-exit action
    *
    * If enabled, when the processor completes the execution of all exception handlers it
    * returns to Thread mode and immediately enters WAIT/STOP mode (ARM core SLEEP/DEEPSLEEP mode).\n
    * Use this mechanism in applications that only require the processor to run when
    * an exception occurs.
    *
    * @param[in] smcSleepOnExit Determines action on completion of all exception handlers
    */
   static void setSleepOnExit(SmcSleepOnExit smcSleepOnExit=SmcSleepOnExit_Enabled) {
      if (smcSleepOnExit) {
         SCB->SCR = SCB->SCR | SCB_SCR_SLEEPONEXIT_Msk;
      }
      else {
         SCB->SCR = SCB->SCR & ~SCB_SCR_SLEEPONEXIT_Msk;
      }
      // Make sure write completes
      (void)(SCB->SCR);
   }
   /**
    * Enter Run Mode.
    *
    * This may be used to change between supported RUN modes (RUN, VLPR, HSRUN).

    * Only the following transitions are allowed: VLPR <-> RUN <-> HSRUN.
    *
    * @param[in] clockConfig Clock configuration (Includes run mode to enter)
    *
    * @return E_NO_ERROR                 No error
    * @return E_CLOCK_INIT_FAILED        Clock transition failure
    * @return E_ILLEGAL_POWER_TRANSITION Cannot transition to smcRunMode from current run mode
    */
   static ErrorCode enterRunMode(ClockConfig clockConfig) {
   
      SmcRunMode smcRunMode = Mcg::clockInfo[clockConfig].runMode;
   
      ErrorCode rc = E_NO_ERROR;
   
      /*
       * Transition    Change clock configuration
       * VLPR->RUN     After
       * RUN->VLPR     Before
       */
      switch(smcRunMode) {
   
         case SmcRunMode_Normal:
            // Change power mode
            SMC->PMCTRL = (SMC->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
   
            // Wait for power status to change
            while (getStatus() != SmcStatus_RUN) {
               __asm__("nop");
            }
            // Change clock mode
            rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
            break;
   
         case SmcRunMode_VeryLowPower:
            // Change clock mode
            rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
            if (rc != E_NO_ERROR) {
               break;
            }
            // Change power mode
            SMC->PMCTRL = (SMC->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
   
            // Wait for power status to change
            while (getStatus() != SmcStatus_VLPR) {
               __asm__("nop");
            }
            break;
         default:
            return setErrorCode(E_ILLEGAL_PARAM);
      }
      return rc;
   }

   
   /**
    * Change power mode.
    *
    * @note Note this method does not affect advanced STOP options such as PORPO and RAM2PO
    *       These should be set beforehand.
    *
    * @param smcPowerMode  Power mode to change to (apart from SmcPowerMode_RUN/VLPR/HSRUN)
    *
    * @return E_NOERROR                   Success
    * @return E_ILLEGAL_PARAM             Cannot enter RUN or VLPR using this method (use enterRunMode())
    * @return E_ILLEGAL_POWER_TRANSITION  It is not possible to transition directly to the given power mode
    * @return E_INTERRUPTED               Processor failed to change mode due to interrupt
    */
   static ErrorCode enterPowerMode(SmcPowerMode smcPowerMode) {
   
      switch(smcPowerMode) {
   
         // Transition refers to Figure 15-5. Power mode state diagram in MK22F Manual (K22P121M120SF7RM)
   
         case SmcPowerMode_RUN   : // (VLPR,HSRUN)->RUN Transition 3,12
         case SmcPowerMode_VLPR  : // RUN->VLPR         Transition 3
            // Clock changes needed etc. Use enterRunMode()
            return E_ILLEGAL_PARAM;
   
         case SmcPowerMode_VLPW  : // VLPR->VLPW        Transition 4
            // Check if in correct run mode
            if (SmcRunMode_VeryLowPower != (SMC->PMCTRL&SMC_PMCTRL_RUNM_MASK)) {
               return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
            }
            [[fallthrough]];
         case SmcPowerMode_WAIT  : // (RUN,VLPR)->VLPW  Transition 1,4
            enterWaitMode();
            return E_NO_ERROR;
            break;
   
         case SmcPowerMode_NormalSTOP   : // RUN->STOP Transition 2a
            // Check if in correct run mode
            if (SmcRunMode_Normal != (SMC->PMCTRL&SMC_PMCTRL_RUNM_MASK)) {
               return E_ILLEGAL_POWER_TRANSITION;
            }
            [[fallthrough]];
         case SmcPowerMode_VLPS  :        // (RUN,VLPR)->VLPS  Transition 7,6 
         case SmcPowerMode_VLLS0 :        // (RUN,VLPR)->VLLS0 Transition 8a,9a
         case SmcPowerMode_VLLS1 :        // (RUN,VLPR)->VLLS1 Transition 8b,9b
         case SmcPowerMode_VLLS2 :        // (RUN,VLPR)->VLLS2/LLS2 Transition 8c,9c
         case SmcPowerMode_VLLS3 :        // (RUN,VLPR)->VLLS3/LLS3 Transition 8d,9d 
            // Set partial_stop and (v)lls options
            smc->STOPCTRL = (smc->STOPCTRL&~SMC_STOPCTRL_VLLSM_MASK)|(smcPowerMode>>8);
   
            return enterStopMode((SmcStopMode)(smcPowerMode&SMC_PMCTRL_STOPM_MASK));
      }
      return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
   }

   
   /**
    * Default initialisation value for Smc
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      SmcAllowVeryLowPower_Enabled , // (smc_pmprot_avlp)          Allow Very Low Power modes - VLPR, VLPW and VLPS are allowed
      SmcAllowLowLeakageStop_Enabled , // (smc_pmprot_alls)          Allow Low Leakage Stop mode - LLS is allowed
      SmcAllowVeryLowLeakageStop_Enabled , // (smc_pmprot_avlls)         Allow Very Low Leakage Stop mode - VLLSx is allowed
      SmcLowLeakageStopMode_VLLS3,  // (smc_stopctrl_vllsm)       Low Leakage Mode Control - Enter VLLS3 in VLLSx mode
   };
   

   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   static inline void defaultConfigure() {
   
      // Update settings
      DefaultInitValue.initialise();
   }
   

};

   /**
    * Class representing SMC
    */
   class Smc : public SmcBase {};
   

#endif // /SMC/_BasicInfoGuard
/**
 * End SMC_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_SMC_H */
