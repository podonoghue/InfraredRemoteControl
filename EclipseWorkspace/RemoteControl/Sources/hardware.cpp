/**
 * @file      hardware.cpp (generated from MK20D5.usbdmHardware)
 * @version   1.3.0
 * @brief     Pin initialisation for MK20DX128VLF5
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */

#include "hardware.h"
// /HARDWARE/Includes not found

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */

/**
 * Startup code for C++ classes
 */
extern "C" void __attribute__((constructor)) cpp_initialise() {
   if constexpr (MapAllPinsOnStartup) {
      mapAllPins();
   }
}

// Hardware definitions
// /HARDWARE_CPP/Definitions not found

// User definitions
// None

#ifdef PORT_PCR_MUX

/**
 * Map all configured pins to peripheral signals.
 *
 * PCRs of allocated pins are set according to settings in Configure.usbdmProject
 *
 * @note Only the lower 16-bits of the PCR registers are initialised
 */
void mapAllPins() {
#if false


#endif

   enablePortClocks(USBDM::PORTA_CLOCK_MASK|USBDM::PORTB_CLOCK_MASK|USBDM::PORTC_CLOCK_MASK|USBDM::PORTD_CLOCK_MASK|USBDM::PORTE_CLOCK_MASK);
   PORTA->GPCHR = uint32_t(ForceLockedPins)|(0x0000UL|PORT_GPCHR_GPWE(0x000CUL));
   PORTA->GPCLR = uint32_t(ForceLockedPins)|(0x0100UL|PORT_GPCLR_GPWE(0x0010UL));
   PORTA->GPCLR = uint32_t(ForceLockedPins)|(0x0200UL|PORT_GPCLR_GPWE(0x0006UL));
   PORTA->GPCLR = uint32_t(ForceLockedPins)|(0x0700UL|PORT_GPCLR_GPWE(0x0009UL));
   PORTB->GPCLR = uint32_t(ForceLockedPins)|(0x0000UL|PORT_GPCLR_GPWE(0x0008UL));
   PORTB->GPCLR = uint32_t(ForceLockedPins)|(0x0100UL|PORT_GPCLR_GPWE(0x0007UL));
   PORTC->GPCLR = uint32_t(ForceLockedPins)|(0x0100UL|PORT_GPCLR_GPWE(0x0010UL));
   PORTC->GPCLR = uint32_t(ForceLockedPins)|(0x0200UL|PORT_GPCLR_GPWE(0x00EEUL));
   PORTD->GPCLR = uint32_t(ForceLockedPins)|(0x0100UL|PORT_GPCLR_GPWE(0x003FUL));
   PORTD->GPCLR = uint32_t(ForceLockedPins)|(0x0200UL|PORT_GPCLR_GPWE(0x0080UL));

   if constexpr (ForceLockoutUnbondedPins) {
      PORTA->GPCLR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCLR_GPWE(0xFFE0UL)); // Lockout unavailable pins
      PORTA->GPCHR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCHR_GPWE(0xFFF3UL)); // Lockout unavailable pins
      PORTB->GPCLR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCLR_GPWE(0xFFF0UL)); // Lockout unavailable pins
      PORTB->GPCHR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCHR_GPWE(0xFFFCUL)); // Lockout unavailable pins
      PORTC->GPCLR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCLR_GPWE(0xFF00UL)); // Lockout unavailable pins
      PORTC->GPCHR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCHR_GPWE(0xFFFFUL)); // Lockout unavailable pins
      PORTD->GPCLR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCLR_GPWE(0xFF00UL)); // Lockout unavailable pins
      PORTD->GPCHR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCHR_GPWE(0xFFFFUL)); // Lockout unavailable pins
      PORTE->GPCLR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCLR_GPWE(0xFFFFUL)); // Lockout unavailable pins
      PORTE->GPCHR = uint32_t(PinLock_Locked)|(0x0000UL|PORT_GPCHR_GPWE(0xFFFFUL)); // Lockout unavailable pins
   }

}
#endif 
/**
 * End group USBDM_Group
 * @}
 */
/*
 *  Static objects
 */
   /**
    * Shared callback to catch unhandled interrupt
    * Only used for callbacks with no parameters
    */
   void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }
   


} // End namespace USBDM

